// index.ts
import "source-map-support/register.js";

// lib/require.ts
import { createRequire } from "module";
var require2 = createRequire(import.meta.url);

// lib/stdout.ts
import cp from "child_process";
var orginal = cp.spawn;
cp.spawn = function(command, args, options) {
  if (command.match(/Cypress/)) {
    const process2 = orginal(command, args, {
      ...options,
      // using pipe enables capturing stdout and stderr
      stdio: ["pipe", "pipe", "pipe"]
    });
    return process2;
  }
  return orginal(command, args, options);
};

// lib/ws/ws.ts
import Debug from "debug";
import http from "http";
import HttpTerminator from "lil-http-terminator";
import { match, P } from "ts-pattern";
import * as WebSocket from "ws";

// lib/pubsub.ts
import EventEmitter from "events";
var pubsub = new EventEmitter();

// lib/ws/ws.ts
var debug = Debug("currents:ws");
var server = null;
var wss = null;
var httpTerminator = null;
var getWSSPort = () => match(server?.address()).with({ port: P.number }, (address) => address.port).otherwise(() => 0);
var stopWSS = async () => {
  debug("terminating wss server: %d", getWSSPort());
  if (!httpTerminator) {
    debug("no wss server");
    return;
  }
  const { success, code, message, error: error2 } = await httpTerminator.terminate();
  if (!success) {
    if (code === "TIMED_OUT")
      error2(message);
    if (code === "SERVER_ERROR")
      error2(message, error2);
    if (code === "INTERNAL_ERROR")
      error2(message, error2);
  }
  debug("terminated wss server: %d", getWSSPort());
};
var startWSS = () => {
  if (wss) {
    return;
  }
  server = http.createServer().on("listening", () => {
    if (!server) {
      throw new Error("Server not initialized");
    }
    wss = new WebSocket.WebSocketServer({
      server
    });
    debug("starting wss on port %d", getWSSPort());
    wss.on("connection", function connection(ws) {
      ws.on("message", function incoming(event) {
        const message = JSON.parse(event.toString());
        pubsub.emit(message.type, message.payload);
      });
    });
  }).listen();
  httpTerminator = HttpTerminator({
    server
  });
};

// lib/capture.ts
import Debug2 from "debug";
var debug2 = Debug2("currents:capture");
var _write = process.stdout.write;
var _log = process.log;
var restore = function() {
  process.stdout.write = _write;
  process.log = _log;
};
var stdout = function() {
  debug2("capturing stdout");
  let logs = [];
  const { write } = process.stdout;
  const { log: log2 } = process;
  if (log2) {
    process.log = function(str) {
      logs.push(str);
      return log2.apply(this, arguments);
    };
  }
  process.stdout.write = function(str) {
    logs.push(str);
    return write.apply(this, arguments);
  };
  return {
    toString() {
      return logs.join("");
    },
    data: logs,
    restore,
    reset: () => {
      debug2("resetting captured stdout");
      logs = [];
    }
  };
};
var initialOutput = "";
var capturedOutput = null;
var initCapture = () => capturedOutput = stdout();
var cutInitialOutput = () => {
  if (!capturedOutput)
    throw new Error("capturedOutput is null");
  initialOutput = capturedOutput.toString();
  capturedOutput.reset();
};
var resetCapture = () => {
  if (!capturedOutput)
    throw new Error("capturedOutput is null");
  capturedOutput.reset();
};
var getCapturedOutput = () => {
  if (!capturedOutput)
    throw new Error("capturedOutput is null");
  return capturedOutput.toString();
};
var getInitialOutput = () => initialOutput;

// lib/httpClient/config.ts
import { isAxiosError } from "axios";
var isRetriableError = (err) => {
  if (err.code === "ECONNABORTED") {
    return true;
  }
  if (err.code === "ECONNREFUSED") {
    return true;
  }
  if (err.code === "ETIMEDOUT") {
    return true;
  }
  if (!isAxiosError(err)) {
    return false;
  }
  return !!(err?.response?.status && 500 <= err.response.status && err.response.status < 600);
};
var getDelay = (i) => [5 * 1e3, 10 * 1e3, 30 * 1e3][i - 1];
var baseURL = "https://cy.currents.dev";
var getAPIBaseUrl = () => baseURL ?? "https://cy.currents.dev";
var setAPIBaseUrl = (url) => baseURL = url ?? "https://cy.currents.dev";

// lib/httpClient/httpClient.ts
import axios from "axios";
import axiosRetry from "axios-retry";
import Debug7 from "debug";
import _5 from "lodash";
import prettyMilliseconds from "pretty-ms";

// lib/config/config.ts
import Debug5 from "debug";
import { P as P2, match as match2 } from "ts-pattern";

// lib/bootstrap/bootstrap.ts
import { getBinPath } from "cy2";
import Debug4 from "debug";
import execa from "execa";
import fs from "fs";

// lib/errors.ts
var ValidationError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "";
  }
};

// lib/fs.ts
import { file } from "tmp-promise";
var createTempFile = async () => {
  const { path: path4 } = await file();
  return path4;
};

// lib/log.ts
import chalk from "chalk";
import util from "util";
var log = (...args) => console.log(util.format(...args));
var info = log;
var withError = (msg) => chalk.bgRed.white(" ERROR ") + " " + msg;
var withWarning = (msg) => chalk.bgYellow.black(" WARNING ") + " " + msg;
var warn = (...args) => log(withWarning(util.format(...args)));
var error = (...args) => log(withError(util.format(...args)) + "\n");
var title = (color, ...args) => info("\n  " + chalk[color].bold(util.format(...args)) + "  \n");
var divider = () => console.log("\n" + chalk.gray(Array(100).fill("=").join("")) + "\n");
var spacer = (n = 0) => console.log(Array(n).fill("").join("\n"));
var cyan = chalk.cyan;
var blue = chalk.blueBright;
var red = chalk.red;
var green = chalk.greenBright;
var gray = chalk.gray;
var white = chalk.white;
var magenta = chalk.magenta;
var bold = chalk.bold;

// lib/bootstrap/serializer.ts
import Debug3 from "debug";
import _ from "lodash";
import { customAlphabet } from "nanoid";
var debug3 = Debug3("currents:boot");
var getDummySpec = customAlphabet("abcdefghijklmnopqrstuvwxyz", 10);
function getBootstrapArgs({
  params,
  tempFilePath
}) {
  return _.chain(getCypressCLIParams(params)).thru((opts) => ({
    ...opts,
    // merge the env with the currents specific env variables
    env: {
      ...opts.env ?? {},
      currents_temp_file: tempFilePath,
      currents_debug_enabled: process.env.DEBUG?.includes("currents:") ? true : false
    }
  })).tap((opts) => {
    debug3("cypress bootstrap params: %o", opts);
  }).thru(serializeOptions).tap((opts) => {
    debug3("cypress bootstrap serialized params: %o", opts);
  }).thru((args) => {
    return [
      ...args,
      "--spec",
      getDummySpec(),
      params.testingType === "component" ? "--component" : "--e2e"
    ];
  }).value();
}
function getCypressCLIParams(params) {
  const result = getCypressRunAPIParams(params);
  const testingType = result.testingType === "component" ? {
    component: true
  } : {};
  return {
    ..._.omit(result, "testingType"),
    ...testingType
  };
}
function serializeOptions(options) {
  return Object.entries(options).flatMap(([key, value]) => {
    const _key = dashed(key);
    if (typeof value === "boolean") {
      return value === true ? [`--${_key}`] : [`--${_key}`, false];
    }
    if (_.isObject(value)) {
      return [`--${_key}`, serializeComplexParam(value)];
    }
    return [`--${_key}`, value.toString()];
  });
}
function serializeComplexParam(param) {
  return JSON.stringify(param);
}
var dashed = (v) => v.replace(/[A-Z]/g, (m) => "-" + m.toLowerCase());

// lib/bootstrap/bootstrap.ts
var debug4 = Debug4("currents:boot");
var bootCypress = async (params) => {
  debug4("booting cypress...");
  const tempFilePath = await createTempFile();
  const cypressBin = await getBinPath(require2.resolve("cypress"));
  debug4("cypress executable location: %s", cypressBin);
  const args = getBootstrapArgs({ tempFilePath, params });
  debug4("booting cypress with args: %o", args);
  const { stdout: stdout2, stderr } = await execCypress(cypressBin, args);
  if (!fs.existsSync(tempFilePath)) {
    throw new Error(
      `Cannot resolve cypress configuration from ${tempFilePath}. Please report the issue.`
    );
  }
  try {
    const f = fs.readFileSync(tempFilePath, "utf-8");
    if (!f) {
      throw new Error("Is cypress-cloud/plugin installed?");
    }
    debug4("cypress config '%s': '%s'", tempFilePath, f);
    return JSON.parse(f);
  } catch (err) {
    debug4("read config temp file failed: %o", err);
    info(bold("Cypress stdout:\n"), stdout2);
    info(bold("Cypress stderr:\n"), stderr);
    throw new ValidationError(`Unable to resolve cypress configuration
- make sure that 'cypress-cloud/plugin' is installed
- report the issue together with cypress stdout and stderr
`);
  }
};
async function execCypress(cypressBin, args) {
  let stdout2 = "";
  let stderr = "";
  try {
    await execa(cypressBin, ["run", ...args], {
      stdio: "pipe",
      env: {
        ...process.env,
        // prevent warnings about recording mode
        CYPRESS_RECORD_KEY: void 0,
        CYPRESS_PROJECT_ID: void 0
      }
    });
  } catch (err) {
    debug4("exec cypress failed (certain failures are expected): %o", err);
    stdout2 = err.stdout;
    stderr = err.stderr;
  }
  return { stdout: stdout2, stderr };
}

// lib/config/path.ts
import isAbsolute from "is-absolute";
import _2 from "lodash";
import path from "path";
var defaultFilenames = [
  "currents.config.js",
  "currents.config.cjs",
  "currents.config.mjs"
];
function getConfigFilePath(projectRoot = null, explicitConfigFilePath) {
  const prefix = projectRoot ?? process.cwd();
  if (_2.isString(explicitConfigFilePath) && isAbsolute(explicitConfigFilePath)) {
    return [explicitConfigFilePath];
  }
  if (_2.isString(explicitConfigFilePath)) {
    return [normalizePath(prefix, explicitConfigFilePath)];
  }
  return defaultFilenames.map((p) => normalizePath(prefix, p));
}
function normalizePath(prefix, filename) {
  return `file://${path.resolve(prefix, filename)}`;
}

// lib/config/config.ts
var debug5 = Debug5("currents:config");
var _config = null;
var defaultConfig = {
  e2e: {
    batchSize: 3
  },
  component: {
    batchSize: 5
  },
  cloudServiceUrl: "https://cy.currents.dev",
  networkHeaders: void 0
};
async function getCurrentsConfig(projectRoot, explicitConfigFilePath) {
  if (_config) {
    return _config;
  }
  const configFilePath = getConfigFilePath(projectRoot, explicitConfigFilePath);
  for (const filepath of configFilePath) {
    const config = match2(await loadConfigFile(filepath)).with({ default: P2.not(P2.nullish) }, (c) => c.default).with(P2.not(P2.nullish), (c) => c).otherwise(() => null);
    if (config) {
      debug5("loaded currents config from '%s'\n%O", filepath, config);
      info("Using config file: '%s'", filepath);
      _config = {
        ...defaultConfig,
        ...config
      };
      return _config;
    }
  }
  warn(
    "Failed to load config file, falling back to the default config. Attempted locations: %s",
    configFilePath
  );
  _config = defaultConfig;
  return _config;
}
async function loadConfigFile(filepath) {
  try {
    debug5("loading currents config file from '%s'", filepath);
    return await import(filepath);
  } catch (e) {
    debug5("failed loading config file from: %s", e);
    return null;
  }
}
async function getMergedConfig(params) {
  debug5("resolving cypress config");
  const cypressResolvedConfig = await bootCypress(params);
  debug5("cypress resolvedConfig: %O", cypressResolvedConfig);
  const rawE2EPattern = cypressResolvedConfig.rawJson?.e2e?.specPattern;
  let additionalIgnorePattern = [];
  if (params.testingType === "component" && rawE2EPattern) {
    additionalIgnorePattern = rawE2EPattern;
  }
  const result = {
    projectRoot: cypressResolvedConfig?.projectRoot || process.cwd(),
    projectId: params.projectId,
    specPattern: cypressResolvedConfig?.specPattern || "**/*.*",
    excludeSpecPattern: (
      // @ts-ignore
      cypressResolvedConfig?.resolved.excludeSpecPattern.value ?? []
    ),
    additionalIgnorePattern,
    resolved: cypressResolvedConfig
  };
  debug5("merged config: %O", result);
  return result;
}

// lib/config/params.ts
import Debug6 from "debug";
import _3 from "lodash";
var debug6 = Debug6("currents:validateParams");
async function resolveCurrentsParams(params) {
  const configFromFile = await getCurrentsConfig(
    params.project,
    params.cloudConfigFile
  );
  debug6("resolving currents params: %o", params);
  debug6("resolving currents config file: %o", configFromFile);
  const cloudServiceUrl = params.cloudServiceUrl ?? process.env.CURRENTS_API_URL ?? configFromFile.cloudServiceUrl;
  const recordKey = params.recordKey ?? process.env.CURRENTS_RECORD_KEY ?? configFromFile.recordKey;
  const projectId = params.projectId ?? process.env.CURRENTS_PROJECT_ID ?? configFromFile.projectId;
  const testingType = params.testingType ?? "e2e";
  const batchSize = testingType === "e2e" ? configFromFile.e2e.batchSize : configFromFile.component.batchSize;
  return {
    ...params,
    cloudServiceUrl,
    recordKey,
    projectId,
    batchSize,
    testingType
  };
}
var projectIdError = `Cannot resolve projectId. Please use one of the following:
- provide it as a "projectId" property for "run" API method
- set CURRENTS_PROJECT_ID environment variable
- set "projectId" in "currents.config.{c}js" file`;
var cloudServiceUrlError = `Cannot resolve cloud service URL. Please use one of the following:
- provide it as a "cloudServiceUrl" property for "run" API method
- set CURRENTS_API_URL environment variable
- set "cloudServiceUrl" in "currents.config.{c}js" file`;
var cloudServiceInvalidUrlError = `Invalid cloud service URL provided`;
var recordKeyError = `Cannot resolve record key. Please use one of the following:

- pass it as a CLI flag '-k, --key <record-key>'
- provide it as a "recordKey" property for "run" API method
- set CURRENTS_RECORD_KEY environment variable
- set "recordKey" in "currents.config.{c}js" file
`;
async function validateParams(_params) {
  const params = await resolveCurrentsParams(_params);
  debug6("validating currents params: %o", params);
  if (!params.cloudServiceUrl) {
    throw new ValidationError(cloudServiceUrlError);
  }
  if (!params.projectId) {
    throw new ValidationError(projectIdError);
  }
  if (!params.recordKey) {
    throw new ValidationError(recordKeyError);
  }
  validateURL(params.cloudServiceUrl);
  const requiredParameters = [
    "testingType",
    "batchSize",
    "projectId"
  ];
  requiredParameters.forEach((key) => {
    if (typeof params[key] === "undefined") {
      error('Missing required parameter "%s"', key);
      throw new Error("Missing required parameter");
    }
  });
  params.tag = parseTags(params.tag);
  params.autoCancelAfterFailures = getAutoCancelValue(
    params.autoCancelAfterFailures
  );
  debug6("validated currents params: %o", params);
  return params;
}
function getAutoCancelValue(value) {
  if (typeof value === "undefined") {
    return void 0;
  }
  if (typeof value === "boolean") {
    return value ? 1 : false;
  }
  if (typeof value === "number" && value > 0) {
    return value;
  }
  throw new ValidationError(
    `autoCancelAfterFailures: should be a positive integer or "false". Got: "${value}"`
  );
}
function isOffline(params) {
  return params.record === false;
}
function parseTags(tagString) {
  if (!tagString) {
    return [];
  }
  if (Array.isArray(tagString)) {
    return tagString.filter(Boolean);
  }
  return tagString.split(",").map((tag) => tag.trim()).filter(Boolean);
}
function validateURL(url) {
  try {
    new URL(url);
  } catch (err) {
    throw new ValidationError(`${cloudServiceInvalidUrlError}: "${url}"`);
  }
}
function getCypressRunAPIParams(params) {
  return {
    ..._3.pickBy(
      _3.omit(params, [
        "cloudDebug",
        "cloudConfigFile",
        "autoCancelAfterFailures",
        "cloudServiceUrl",
        "batchSize",
        "projectId",
        "key",
        "recordKey",
        "record",
        "group",
        "parallel",
        "tag",
        "ciBuildId",
        "spec",
        "exit",
        "headless"
      ]),
      Boolean
    ),
    record: false
  };
}
function preprocessParams(params) {
  return {
    ...params,
    spec: processSpecParam(params.spec)
  };
}
function processSpecParam(spec) {
  if (!spec) {
    return void 0;
  }
  if (Array.isArray(spec)) {
    return _3.flatten(spec.map((i) => i.split(",")));
  }
  return spec.split(",");
}

// lib/httpClient/printErrors.ts
import _4 from "lodash";
function maybePrintErrors(err) {
  if (!err.response?.data || !err.response?.status) {
    return;
  }
  const { message, errors } = err.response.data;
  switch (err.response.status) {
    case 401:
      warn("Received 401 Unauthorized");
      break;
    case 422:
      spacer(1);
      warn(...formatGenericError(message, errors));
      spacer(1);
      break;
    default:
      break;
  }
}
function formatGenericError(message, errors) {
  if (!_4.isString(message)) {
    return ["Unexpected error from the cloud service"];
  }
  if (errors?.length === 0) {
    return [message];
  }
  return [
    message,
    `
${(errors ?? []).map((e) => `  - ${e}`).join("\n")}
`
  ];
}

// lib/httpClient/httpClient.ts
var debug7 = Debug7("currents:api");
var MAX_RETRIES = 3;
var TIMEOUT_MS = 30 * 1e3;
var _client = null;
async function getClient() {
  if (_client) {
    return _client;
  }
  const currentsConfig = await getCurrentsConfig();
  _client = axios.create({
    baseURL: getAPIBaseUrl(),
    timeout: TIMEOUT_MS
  });
  _client.interceptors.request.use((config) => {
    const ccyVerson = _currentsVersion ?? "0.0.0";
    const headers = {
      ...config.headers,
      // @ts-ignore
      "x-cypress-request-attempt": config["axios-retry"]?.retryCount ?? 0,
      "x-cypress-version": _cypressVersion ?? "0.0.0",
      "x-ccy-version": ccyVerson,
      "User-Agent": `cypress-cloud/${ccyVerson}`
    };
    if (_runId) {
      headers["x-cypress-run-id"] = _runId;
    }
    if (!headers["Content-Type"]) {
      headers["Content-Type"] = "application/json";
    }
    if (currentsConfig.networkHeaders) {
      const filteredHeaders = _5.omit(currentsConfig.networkHeaders, [
        "x-cypress-request-attempt",
        "x-cypress-version",
        "x-ccy-version",
        "x-cypress-run-id",
        "Content-Type"
      ]);
      debug7("using custom network headers: %o", filteredHeaders);
      Object.assign(headers, filteredHeaders);
    }
    const req = {
      ...config,
      headers
    };
    debug7("network request: %o", {
      ..._5.pick(req, "method", "url", "headers"),
      data: Buffer.isBuffer(req.data) ? "buffer" : req.data
    });
    return req;
  });
  axiosRetry(_client, {
    retries: MAX_RETRIES,
    retryCondition: isRetriableError,
    retryDelay: getDelay,
    // @ts-ignore
    onRetry,
    shouldResetTimeout: true
  });
  return _client;
}
var _runId = void 0;
var setRunId = (runId) => {
  _runId = runId;
};
var _cypressVersion = void 0;
var setCypressVersion = (cypressVersion) => {
  _cypressVersion = cypressVersion;
};
var _currentsVersion = void 0;
var setCurrentsVersion = (v) => {
  _currentsVersion = v;
};
function onRetry(retryCount, err, config) {
  warn(
    "Network request '%s' failed: '%s'. Next attempt is in %s (%d/%d).",
    `${config.method} ${config.url}`,
    err.message,
    prettyMilliseconds(getDelay(retryCount)),
    retryCount,
    MAX_RETRIES
  );
}
var makeRequest = async (config) => {
  return (await getClient())(config).then((res) => {
    debug7("network response: %o", _5.omit(res, "request", "config"));
    return res;
  }).catch((error2) => {
    maybePrintErrors(error2);
    throw new ValidationError(error2.message);
  });
};

// lib/init.ts
var cypressPkg = require2("cypress/package.json");
var pkg = require2("cypress-cloud/package.json");
initCapture();
setCypressVersion(cypressPkg.version);
setCurrentsVersion(pkg.version);

// lib/run.ts
import Debug19 from "debug";

// legal.ts
function getLegalNotice() {
  return `
Copyright (C) ${(/* @__PURE__ */ new Date()).getFullYear()} Currents Software Inc https://currents.dev
This is free software, and you are welcome to redistribute it under certain
conditions. This program comes with no warranty. Parts of this program are MIT
licensed. Refer to the license for details
https://github.com/currents-dev/cypress-cloud/blob/main/LICENSE.md
`;
}

// lib/api/warnings.ts
import _6 from "lodash";
function printWarnings(warnings) {
  warn("Notice from cloud service:");
  warnings.map((w) => {
    spacer(1);
    info(magenta.bold(w.message));
    Object.entries(_6.omit(w, "message")).map(([key, value]) => {
      info("- %s: %s", key, value);
    });
    spacer(1);
  });
}

// lib/api/api.ts
var createRun = async (payload) => {
  const response = await makeRequest({
    method: "POST",
    url: "/runs",
    data: payload
  });
  if ((response.data.warnings?.length ?? 0) > 0) {
    printWarnings(response.data.warnings);
  }
  return response.data;
};
var createInstance = async ({
  runId,
  groupId,
  machineId,
  platform: platform2
}) => {
  const response = await makeRequest({
    method: "POST",
    url: `runs/${runId}/instances`,
    data: {
      runId,
      groupId,
      machineId,
      platform: platform2
    }
  });
  return response.data;
};
var createBatchedInstances = async (data) => {
  const respone = await makeRequest({
    method: "POST",
    url: `runs/${data.runId}/cy/instances`,
    data
  });
  return respone.data;
};
var setInstanceTests = (instanceId, payload) => makeRequest({
  method: "POST",
  url: `instances/${instanceId}/tests`,
  data: payload
}).then((result) => result.data);
var updateInstanceResults = (instanceId, payload) => makeRequest({
  method: "POST",
  url: `instances/${instanceId}/results`,
  data: payload
}).then((result) => result.data);
var reportInstanceResultsMerged = (instanceId, payload) => makeRequest({
  method: "POST",
  url: `instances/${instanceId}/cy/results`,
  data: payload
}).then((result) => result.data);
var updateInstanceStdout = (instanceId, stdout2) => makeRequest({
  method: "PUT",
  url: `instances/${instanceId}/stdout`,
  data: {
    stdout: stdout2
  }
});

// lib/ciProvider.ts
import debugFn from "debug";
import _7 from "lodash";
var debug8 = debugFn("currents:ci");
var join = (char, ...pieces) => {
  return _7.chain(pieces).compact().join(char).value();
};
var toCamelObject = (obj, key) => {
  return _7.set(obj, _7.camelCase(key), process.env[key]);
};
var extract = (envKeys) => {
  return _7.transform(envKeys, toCamelObject, {});
};
var isTeamFoundation = () => {
  return process.env.TF_BUILD && process.env.TF_BUILD_BUILDNUMBER;
};
var isAzureCi = () => {
  return process.env.TF_BUILD && process.env.AZURE_HTTP_USER_AGENT;
};
var isAWSCodeBuild = () => {
  return _7.some(process.env, (val, key) => {
    return /^CODEBUILD_/.test(key);
  });
};
var isBamboo = () => {
  return process.env.bamboo_buildNumber;
};
var isCodeshipBasic = () => {
  return process.env.CI_NAME && process.env.CI_NAME === "codeship" && process.env.CODESHIP;
};
var isCodeshipPro = () => {
  return process.env.CI_NAME && process.env.CI_NAME === "codeship" && !process.env.CODESHIP;
};
var isConcourse = () => {
  return _7.some(process.env, (val, key) => {
    return /^CONCOURSE_/.test(key);
  });
};
var isGitlab = () => {
  return process.env.GITLAB_CI || process.env.CI_SERVER_NAME && /^GitLab/.test(process.env.CI_SERVER_NAME);
};
var isGoogleCloud = () => {
  return process.env.GCP_PROJECT || process.env.GCLOUD_PROJECT || process.env.GOOGLE_CLOUD_PROJECT;
};
var isJenkins = () => {
  return process.env.JENKINS_URL || process.env.JENKINS_HOME || process.env.JENKINS_VERSION || process.env.HUDSON_URL || process.env.HUDSON_HOME;
};
var isWercker = () => {
  return process.env.WERCKER || process.env.WERCKER_MAIN_PIPELINE_STARTED;
};
var CI_PROVIDERS = {
  appveyor: "APPVEYOR",
  azure: isAzureCi,
  awsCodeBuild: isAWSCodeBuild,
  bamboo: isBamboo,
  bitbucket: "BITBUCKET_BUILD_NUMBER",
  buildkite: "BUILDKITE",
  circle: "CIRCLECI",
  codeshipBasic: isCodeshipBasic,
  codeshipPro: isCodeshipPro,
  concourse: isConcourse,
  codeFresh: "CF_BUILD_ID",
  drone: "DRONE",
  githubActions: "GITHUB_ACTIONS",
  gitlab: isGitlab,
  goCD: "GO_JOB_NAME",
  googleCloud: isGoogleCloud,
  jenkins: isJenkins,
  semaphore: "SEMAPHORE",
  shippable: "SHIPPABLE",
  teamcity: "TEAMCITY_VERSION",
  teamfoundation: isTeamFoundation,
  travis: "TRAVIS",
  wercker: isWercker,
  netlify: "NETLIFY",
  layerci: "LAYERCI"
};
function _detectProviderName() {
  const { env } = process;
  return _7.findKey(CI_PROVIDERS, (value) => {
    if (_7.isString(value)) {
      return env[value];
    }
    if (_7.isFunction(value)) {
      return value();
    }
  });
}
var _providerCiParams = () => {
  return {
    appveyor: extract([
      "APPVEYOR_JOB_ID",
      "APPVEYOR_ACCOUNT_NAME",
      "APPVEYOR_PROJECT_SLUG",
      "APPVEYOR_BUILD_NUMBER",
      "APPVEYOR_BUILD_VERSION",
      "APPVEYOR_PULL_REQUEST_NUMBER",
      "APPVEYOR_PULL_REQUEST_HEAD_REPO_BRANCH"
    ]),
    azure: extract([
      "BUILD_BUILDID",
      "BUILD_BUILDNUMBER",
      "BUILD_CONTAINERID",
      "BUILD_REPOSITORY_URI"
    ]),
    awsCodeBuild: extract([
      "CODEBUILD_BUILD_ID",
      "CODEBUILD_BUILD_NUMBER",
      "CODEBUILD_RESOLVED_SOURCE_VERSION",
      "CODEBUILD_SOURCE_REPO_URL",
      "CODEBUILD_SOURCE_VERSION"
    ]),
    bamboo: extract([
      "bamboo_buildNumber",
      "bamboo_buildResultsUrl",
      "bamboo_planRepository_repositoryUrl",
      "bamboo_buildKey"
    ]),
    bitbucket: extract([
      "BITBUCKET_REPO_SLUG",
      "BITBUCKET_REPO_OWNER",
      "BITBUCKET_BUILD_NUMBER",
      "BITBUCKET_PARALLEL_STEP",
      "BITBUCKET_STEP_RUN_NUMBER",
      // the PR variables are only set on pull request builds
      "BITBUCKET_PR_ID",
      "BITBUCKET_PR_DESTINATION_BRANCH",
      "BITBUCKET_PR_DESTINATION_COMMIT"
    ]),
    buildkite: extract([
      "BUILDKITE_REPO",
      "BUILDKITE_SOURCE",
      "BUILDKITE_JOB_ID",
      "BUILDKITE_BUILD_ID",
      "BUILDKITE_BUILD_URL",
      "BUILDKITE_BUILD_NUMBER",
      "BUILDKITE_PULL_REQUEST",
      "BUILDKITE_PULL_REQUEST_REPO",
      "BUILDKITE_PULL_REQUEST_BASE_BRANCH"
    ]),
    circle: extract([
      "CIRCLE_JOB",
      "CIRCLE_BUILD_NUM",
      "CIRCLE_BUILD_URL",
      "CIRCLE_PR_NUMBER",
      "CIRCLE_PR_REPONAME",
      "CIRCLE_PR_USERNAME",
      "CIRCLE_COMPARE_URL",
      "CIRCLE_WORKFLOW_ID",
      "CIRCLE_PULL_REQUEST",
      "CIRCLE_REPOSITORY_URL",
      "CI_PULL_REQUEST"
    ]),
    codeshipBasic: extract([
      "CI_BUILD_ID",
      "CI_REPO_NAME",
      "CI_BUILD_URL",
      "CI_PROJECT_ID",
      "CI_BUILD_NUMBER",
      "CI_PULL_REQUEST"
    ]),
    // CodeshipPro provides very few CI variables
    // https://documentation.codeship.com/pro/builds-and-configuration/environment-variables/
    codeshipPro: extract(["CI_BUILD_ID", "CI_REPO_NAME", "CI_PROJECT_ID"]),
    // https://concourse-ci.org/implementing-resource-types.html#resource-metadata
    concourse: extract([
      "BUILD_ID",
      "BUILD_NAME",
      "BUILD_JOB_NAME",
      "BUILD_PIPELINE_NAME",
      "BUILD_TEAM_NAME",
      "ATC_EXTERNAL_URL"
    ]),
    // https://codefresh.io/docs/docs/codefresh-yaml/variables/
    codeFresh: extract([
      "CF_BUILD_ID",
      "CF_BUILD_URL",
      "CF_CURRENT_ATTEMPT",
      "CF_STEP_NAME",
      "CF_PIPELINE_NAME",
      "CF_PIPELINE_TRIGGER_ID",
      // variables added for pull requests
      "CF_PULL_REQUEST_ID",
      "CF_PULL_REQUEST_IS_FORK",
      "CF_PULL_REQUEST_NUMBER",
      "CF_PULL_REQUEST_TARGET"
    ]),
    drone: extract([
      "DRONE_JOB_NUMBER",
      "DRONE_BUILD_LINK",
      "DRONE_BUILD_NUMBER",
      "DRONE_PULL_REQUEST"
    ]),
    // https://help.github.com/en/actions/automating-your-workflow-with-github-actions/using-environment-variables#default-environment-variables
    githubActions: extract([
      "GITHUB_WORKFLOW",
      "GITHUB_ACTION",
      "GITHUB_EVENT_NAME",
      "GITHUB_RUN_ID",
      "GITHUB_RUN_ATTEMPT",
      "GITHUB_REPOSITORY"
    ]),
    // see https://docs.gitlab.com/ee/ci/variables/
    gitlab: extract([
      // pipeline is common among all jobs
      "CI_PIPELINE_ID",
      "CI_PIPELINE_URL",
      // individual jobs
      "CI_BUILD_ID",
      // build id and job id are aliases
      "CI_JOB_ID",
      "CI_JOB_URL",
      "CI_JOB_NAME",
      // other information
      "GITLAB_HOST",
      "CI_PROJECT_ID",
      "CI_PROJECT_URL",
      "CI_REPOSITORY_URL",
      "CI_ENVIRONMENT_URL",
      "CI_DEFAULT_BRANCH"
      // for PRs: https://gitlab.com/gitlab-org/gitlab-ce/issues/23902
    ]),
    // https://docs.gocd.org/current/faq/dev_use_current_revision_in_build.html#standard-gocd-environment-variables
    goCD: extract([
      "GO_SERVER_URL",
      "GO_ENVIRONMENT_NAME",
      "GO_PIPELINE_NAME",
      "GO_PIPELINE_COUNTER",
      "GO_PIPELINE_LABEL",
      "GO_STAGE_NAME",
      "GO_STAGE_COUNTER",
      "GO_JOB_NAME",
      "GO_TRIGGER_USER",
      "GO_REVISION",
      "GO_TO_REVISION",
      "GO_FROM_REVISION",
      "GO_MATERIAL_HAS_CHANGED"
    ]),
    googleCloud: extract([
      // individual jobs
      "BUILD_ID",
      "PROJECT_ID",
      // other information
      "REPO_NAME",
      "BRANCH_NAME",
      "TAG_NAME",
      "COMMIT_SHA",
      "SHORT_SHA"
      // https://cloud.google.com/cloud-build/docs/api/reference/rest/Shared.Types/Build
    ]),
    jenkins: extract(["BUILD_ID", "BUILD_URL", "BUILD_NUMBER", "ghprbPullId"]),
    // https://semaphoreci.com/docs/available-environment-variables.html
    // some come from v1, some from v2 of semaphore
    semaphore: extract([
      "SEMAPHORE_BRANCH_ID",
      "SEMAPHORE_BUILD_NUMBER",
      "SEMAPHORE_CURRENT_JOB",
      "SEMAPHORE_CURRENT_THREAD",
      "SEMAPHORE_EXECUTABLE_UUID",
      "SEMAPHORE_GIT_BRANCH",
      "SEMAPHORE_GIT_DIR",
      "SEMAPHORE_GIT_REF",
      "SEMAPHORE_GIT_REF_TYPE",
      "SEMAPHORE_GIT_REPO_SLUG",
      "SEMAPHORE_GIT_SHA",
      "SEMAPHORE_GIT_URL",
      "SEMAPHORE_JOB_COUNT",
      "SEMAPHORE_JOB_ID",
      // v2
      "SEMAPHORE_JOB_NAME",
      "SEMAPHORE_JOB_UUID",
      // v1
      "SEMAPHORE_PIPELINE_ID",
      "SEMAPHORE_PLATFORM",
      "SEMAPHORE_PROJECT_DIR",
      "SEMAPHORE_PROJECT_HASH_ID",
      "SEMAPHORE_PROJECT_ID",
      // v2
      "SEMAPHORE_PROJECT_NAME",
      "SEMAPHORE_PROJECT_UUID",
      // v1
      "SEMAPHORE_REPO_SLUG",
      "SEMAPHORE_TRIGGER_SOURCE",
      "SEMAPHORE_WORKFLOW_ID",
      "PULL_REQUEST_NUMBER"
      // pull requests from forks ONLY
    ]),
    // see http://docs.shippable.com/ci/env-vars/
    shippable: extract([
      // build variables
      "SHIPPABLE_BUILD_ID",
      // "5b93354cabfabb07007f01fd"
      "SHIPPABLE_BUILD_NUMBER",
      // "4"
      "SHIPPABLE_COMMIT_RANGE",
      // "sha1...sha2"
      "SHIPPABLE_CONTAINER_NAME",
      // "c.exec.cypress-example-kitchensink.4.1"
      "SHIPPABLE_JOB_ID",
      // "1"
      "SHIPPABLE_JOB_NUMBER",
      // "1"
      "SHIPPABLE_REPO_SLUG",
      // "<username>/<repo>"
      // additional information that Shippable provides
      "IS_FORK",
      // "true"
      "IS_GIT_TAG",
      // "false"
      "IS_PRERELEASE",
      // "false"
      "IS_RELEASE",
      // "false"
      "REPOSITORY_URL",
      // "https://github.com/....git"
      "REPO_FULL_NAME",
      // "<username>/<repo>"
      "REPO_NAME",
      // "cypress-example-kitchensink"
      "BUILD_URL",
      // "https://app.shippable.com/github/<username>/<repo>/runs/1"
      // Pull request information
      "BASE_BRANCH",
      // Name of the target branch into which the pull request changes will be merged.
      "HEAD_BRANCH",
      // This is only set for pull requests and is the name of the branch the pull request was opened from.
      "IS_PULL_REQUEST",
      // "false" or "true"
      "PULL_REQUEST",
      // Pull request number if the job is a pull request. If not, this will be set to false.
      "PULL_REQUEST_BASE_BRANCH",
      // Name of the branch that the pull request will be merged into. It should be the same as BASE_BRANCH.
      "PULL_REQUEST_REPO_FULL_NAME"
      // Full name of the repository from where the pull request originated.
    ]),
    teamcity: null,
    teamfoundation: extract([
      "BUILD_BUILDID",
      "BUILD_BUILDNUMBER",
      "BUILD_CONTAINERID"
    ]),
    travis: extract([
      "TRAVIS_JOB_ID",
      "TRAVIS_BUILD_ID",
      "TRAVIS_BUILD_WEB_URL",
      "TRAVIS_REPO_SLUG",
      "TRAVIS_JOB_NUMBER",
      "TRAVIS_EVENT_TYPE",
      "TRAVIS_COMMIT_RANGE",
      "TRAVIS_BUILD_NUMBER",
      "TRAVIS_PULL_REQUEST",
      "TRAVIS_PULL_REQUEST_BRANCH",
      "TRAVIS_PULL_REQUEST_SHA"
    ]),
    wercker: null,
    // https://docs.netlify.com/configure-builds/environment-variables/#deploy-urls-and-metadata
    netlify: extract([
      "BUILD_ID",
      "CONTEXT",
      "URL",
      "DEPLOY_URL",
      "DEPLOY_PRIME_URL",
      "DEPLOY_ID"
    ]),
    // https://layerci.com/docs/layerfile-reference/build-env
    layerci: extract([
      "LAYERCI_JOB_ID",
      "LAYERCI_RUNNER_ID",
      "RETRY_INDEX",
      "LAYERCI_PULL_REQUEST",
      "LAYERCI_REPO_NAME",
      "LAYERCI_REPO_OWNER",
      "LAYERCI_BRANCH",
      "GIT_TAG"
      // short hex for commits
    ])
  };
};
var _providerCommitParams = () => {
  const { env } = process;
  return {
    appveyor: {
      sha: env.APPVEYOR_REPO_COMMIT,
      // since APPVEYOR_REPO_BRANCH will be the target branch on a PR
      // we need to use PULL_REQUEST_HEAD_REPO_BRANCH if it exists.
      // e.g. if you have a PR: develop <- my-feature-branch
      // my-feature-branch is APPVEYOR_PULL_REQUEST_HEAD_REPO_BRANCH
      // develop           is APPVEYOR_REPO_BRANCH
      branch: env.APPVEYOR_PULL_REQUEST_HEAD_REPO_BRANCH || env.APPVEYOR_REPO_BRANCH,
      message: join(
        "\n",
        env.APPVEYOR_REPO_COMMIT_MESSAGE,
        env.APPVEYOR_REPO_COMMIT_MESSAGE_EXTENDED
      ),
      authorName: env.APPVEYOR_REPO_COMMIT_AUTHOR,
      authorEmail: env.APPVEYOR_REPO_COMMIT_AUTHOR_EMAIL
      // remoteOrigin: ???
      // defaultBranch: ???
    },
    awsCodeBuild: {
      sha: env.CODEBUILD_RESOLVED_SOURCE_VERSION,
      // branch: ???,
      // message: ???
      // authorName: ???
      // authorEmail: ???
      remoteOrigin: env.CODEBUILD_SOURCE_REPO_URL
      // defaultBranch: ???
    },
    azure: {
      sha: env.BUILD_SOURCEVERSION,
      branch: env.BUILD_SOURCEBRANCHNAME,
      message: env.BUILD_SOURCEVERSIONMESSAGE,
      authorName: env.BUILD_SOURCEVERSIONAUTHOR,
      authorEmail: env.BUILD_REQUESTEDFOREMAIL
    },
    bamboo: {
      sha: env.bamboo_planRepository_revision,
      branch: env.bamboo_planRepository_branch,
      // message: ???
      authorName: env.bamboo_planRepository_username,
      // authorEmail: ???
      remoteOrigin: env.bamboo_planRepository_repositoryURL
      // defaultBranch: ???
    },
    bitbucket: {
      sha: env.BITBUCKET_COMMIT,
      branch: env.BITBUCKET_BRANCH
      // message: ???
      // authorName: ???
      // authorEmail: ???
      // remoteOrigin: ???
      // defaultBranch: ???
    },
    buildkite: {
      sha: env.BUILDKITE_COMMIT,
      branch: env.BUILDKITE_BRANCH,
      message: env.BUILDKITE_MESSAGE,
      authorName: env.BUILDKITE_BUILD_CREATOR,
      authorEmail: env.BUILDKITE_BUILD_CREATOR_EMAIL,
      remoteOrigin: env.BUILDKITE_REPO,
      defaultBranch: env.BUILDKITE_PIPELINE_DEFAULT_BRANCH
    },
    circle: {
      sha: env.CIRCLE_SHA1,
      branch: env.CIRCLE_BRANCH,
      // message: ???
      authorName: env.CIRCLE_USERNAME,
      // authorEmail: ???
      remoteOrigin: env.CIRCLE_REPOSITORY_URL
      // defaultBranch: ???
    },
    codeshipBasic: {
      sha: env.CI_COMMIT_ID,
      branch: env.CI_BRANCH,
      message: env.CI_COMMIT_MESSAGE,
      authorName: env.CI_COMMITTER_NAME,
      authorEmail: env.CI_COMMITTER_EMAIL
      // remoteOrigin: ???
      // defaultBranch: ???
    },
    codeshipPro: {
      sha: env.CI_COMMIT_ID,
      branch: env.CI_BRANCH,
      message: env.CI_COMMIT_MESSAGE,
      authorName: env.CI_COMMITTER_NAME,
      authorEmail: env.CI_COMMITTER_EMAIL
      // remoteOrigin: ???
      // defaultBranch: ???
    },
    codeFresh: {
      sha: env.CF_REVISION,
      branch: env.CF_BRANCH,
      message: env.CF_COMMIT_MESSAGE,
      authorName: env.CF_COMMIT_AUTHOR
    },
    drone: {
      sha: env.DRONE_COMMIT_SHA,
      // https://docs.drone.io/pipeline/environment/reference/drone-source-branch/
      branch: env.DRONE_SOURCE_BRANCH,
      message: env.DRONE_COMMIT_MESSAGE,
      authorName: env.DRONE_COMMIT_AUTHOR,
      authorEmail: env.DRONE_COMMIT_AUTHOR_EMAIL,
      remoteOrigin: env.DRONE_GIT_HTTP_URL,
      defaultBranch: env.DRONE_REPO_BRANCH
    },
    githubActions: {
      sha: env.GITHUB_SHA,
      branch: env.GH_BRANCH || env.GITHUB_REF,
      defaultBranch: env.GITHUB_BASE_REF,
      remoteBranch: env.GITHUB_HEAD_REF,
      runAttempt: env.GITHUB_RUN_ATTEMPT
    },
    gitlab: {
      sha: env.CI_COMMIT_SHA,
      branch: env.CI_COMMIT_REF_NAME,
      message: env.CI_COMMIT_MESSAGE,
      authorName: env.GITLAB_USER_NAME,
      authorEmail: env.GITLAB_USER_EMAIL,
      remoteOrigin: env.CI_REPOSITORY_URL,
      defaultBranch: env.CI_DEFAULT_BRANCH
    },
    googleCloud: {
      sha: env.COMMIT_SHA,
      branch: env.BRANCH_NAME
      // message: ??
      // authorName: ??
      // authorEmail: ??
      // remoteOrigin: ???
      // defaultBranch: ??
    },
    jenkins: {
      sha: env.GIT_COMMIT,
      branch: env.GIT_BRANCH
      // message: ???
      // authorName: ???
      // authorEmail: ???
      // remoteOrigin: ???
      // defaultBranch: ???
    },
    // Only from forks? https://semaphoreci.com/docs/available-environment-variables.html
    semaphore: {
      sha: env.SEMAPHORE_GIT_SHA,
      branch: env.SEMAPHORE_GIT_BRANCH,
      // message: ???
      // authorName: ???
      // authorEmail: ???
      remoteOrigin: env.SEMAPHORE_GIT_REPO_SLUG
      // defaultBranch: ???
    },
    shippable: {
      sha: env.COMMIT,
      branch: env.BRANCH,
      message: env.COMMIT_MESSAGE,
      authorName: env.COMMITTER
      // authorEmail: ???
      // remoteOrigin: ???
      // defaultBranch: ???
    },
    snap: null,
    teamcity: null,
    teamfoundation: {
      sha: env.BUILD_SOURCEVERSION,
      branch: env.BUILD_SOURCEBRANCHNAME,
      message: env.BUILD_SOURCEVERSIONMESSAGE,
      authorName: env.BUILD_SOURCEVERSIONAUTHOR
    },
    travis: {
      sha: env.TRAVIS_PULL_REQUEST_SHA || env.TRAVIS_COMMIT,
      // for PRs, TRAVIS_BRANCH is the base branch being merged into
      branch: env.TRAVIS_PULL_REQUEST_BRANCH || env.TRAVIS_BRANCH,
      // authorName: ???
      // authorEmail: ???
      message: env.TRAVIS_COMMIT_MESSAGE
      // remoteOrigin: ???
      // defaultBranch: ???
    },
    wercker: null,
    netlify: {
      sha: env.COMMIT_REF,
      branch: env.BRANCH,
      remoteOrigin: env.REPOSITORY_URL
    },
    layerci: {
      sha: env.GIT_COMMIT,
      branch: env.LAYERCI_BRANCH,
      message: env.GIT_COMMIT_TITLE
    }
  };
};
var _get = (fn) => {
  const providerName = getCiProvider();
  if (!providerName)
    return {};
  return _7.chain(fn()).get(providerName).value();
};
function checkForCiBuildFromCi(ciProvider) {
  if (ciProvider && detectableCiBuildIdProviders().includes(ciProvider))
    return true;
  throw new ValidationError(
    `Could not determine CI build ID from the environment. Please provide a unique CI build ID using the --ci-build-id CLI flag or 'ciBuildId' parameter for 'run' method.`
  );
}
function detectableCiBuildIdProviders() {
  return _7.chain(_providerCiParams()).omitBy(_7.isNull).keys().value();
}
function getCiProvider() {
  return _detectProviderName() || null;
}
function getCiParams() {
  return _get(_providerCiParams);
}
function getCommitParams() {
  return _get(_providerCommitParams);
}
function getCI(ciBuildId) {
  const params = getCiParams();
  const provider = getCiProvider();
  if (!ciBuildId)
    checkForCiBuildFromCi(provider);
  debug8("detected CI provider: %s", provider);
  debug8("detected CI params: %O", params);
  return {
    params,
    provider
  };
}
function getCommitDefaults(existingInfo) {
  debug8("git commit existing info");
  debug8(existingInfo);
  const commitParamsObj = getCommitParams();
  debug8("commit info from provider environment variables: %O", commitParamsObj);
  const combined = _7.transform(
    existingInfo,
    (memo, value, key) => {
      return memo[key] = _7.defaultTo(value || commitParamsObj[key], null);
    }
  );
  debug8("combined git and environment variables from provider");
  debug8(combined);
  return combined;
}

// lib/cypress/cypress.ts
import cypress from "cypress";
import Debug8 from "debug";
import _8 from "lodash";

// lib/lang.ts
import bluebird from "bluebird";
bluebird.Promise.config({
  cancellation: true
});
var BPromise = bluebird.Promise;
var safe = (fn, ifFaled, ifSucceed) => async (...args) => {
  try {
    const r = await fn(...args);
    ifSucceed();
    return r;
  } catch (e) {
    return ifFaled(e);
  }
};

// lib/cypress/cypress.ts
var debug9 = Debug8("currents:cypress");
function runBareCypress(params = {}) {
  const p = {
    ...params,
    ciBuildId: void 0,
    tag: void 0,
    parallel: void 0,
    record: false,
    group: void 0,
    spec: _8.flatten(params.spec).join(",")
  };
  debug9("Running bare Cypress with params %o", p);
  return cypress.run(p);
}
async function runSpecFile({ spec }, cypressRunOptions) {
  const runAPIOptions = getCypressRunAPIParams(cypressRunOptions);
  const options = {
    ...runAPIOptions,
    config: {
      ...runAPIOptions.config,
      trashAssetsBeforeRuns: false
    },
    env: {
      ...runAPIOptions.env,
      currents_ws: getWSSPort()
    },
    spec
  };
  debug9("running cypress with options %o", options);
  const result = await cypress.run(options);
  if (result.status === "failed") {
    warn('Cypress runner failed with message: "%s"', result.message);
    warn(
      "The following spec files will be marked as failed: %s",
      spec.split(",").map((i) => `
 - ${i}`).join("")
    );
  }
  debug9("cypress run result %o", result);
  return result;
}
var runSpecFileSafe = (spec, cypressRunOptions) => safe(
  runSpecFile,
  (error2) => {
    const message = `Cypress runnner crashed with an error:
${error2.message}
${error2.stack}}`;
    debug9("cypress run exception %o", error2);
    warn('Cypress runner crashed: "%s"', message);
    warn(
      "The following spec files will be marked as failed: %s",
      spec.spec.split(",").map((i) => `
 - ${i}`).join("")
    );
    return {
      status: "failed",
      failures: 1,
      message
    };
  },
  () => {
  }
)(spec, cypressRunOptions);

// lib/debug/index.ts
import debug10 from "debug";
import { match as match3, P as P3 } from "ts-pattern";
function activateDebug(mode) {
  match3(mode).with(P3.instanceOf(Array), (i) => i.forEach(setDebugMode)).with(true, () => setDebugMode("all" /* All */)).with(
    P3.union(
      "all" /* All */,
      "currents" /* Currents */,
      "cypress" /* Cypress */,
      "commit-info" /* CommitInfo */
    ),
    (i) => setDebugMode(i)
  ).otherwise(() => setDebugMode("none" /* None */));
}
function setDebugMode(mode) {
  if (mode === "none" /* None */) {
    return;
  }
  const tokens = new Set(process.env.DEBUG ? process.env.DEBUG.split(",") : []);
  match3(mode).with("all" /* All */, () => {
    tokens.add("commit-info" /* CommitInfo */);
    tokens.add("currents:*" /* Currents */);
    tokens.add("cypress:*" /* Cypress */);
  }).with("currents" /* Currents */, () => tokens.add("currents:*" /* Currents */)).with("cypress" /* Cypress */, () => tokens.add("cypress:*" /* Cypress */)).with("commit-info" /* CommitInfo */, () => tokens.add("commit-info" /* CommitInfo */)).otherwise(() => {
  });
  debug10.enable(Array.from(tokens).join(","));
}

// lib/env.ts
var isCurrents = () => !!process.env.CURRENTS_ENFORCE_IS_CURRENTS || getAPIBaseUrl() === "https://cy.currents.dev";

// lib/git.ts
import git from "@cypress/commit-info";
var getGitInfo = async (projectRoot) => {
  const commitInfo = await git.commitInfo(projectRoot);
  return getCommitDefaults({
    branch: commitInfo.branch,
    remoteOrigin: commitInfo.remote,
    authorEmail: commitInfo.email,
    authorName: commitInfo.author,
    message: commitInfo.message,
    sha: commitInfo.sha
  });
};

// lib/platform/browser.ts
import Debug9 from "debug";
var debug11 = Debug9("currents:browser");
function guessBrowser(browser, availableBrowsers = []) {
  debug11(
    "guessing browser from '%s', available browsers: %o",
    browser,
    availableBrowsers
  );
  let result = availableBrowsers.find((b) => b.name === browser);
  if (result) {
    debug11("identified browser by name: %o", result);
    return {
      browserName: result.displayName,
      browserVersion: result.version
    };
  }
  result = availableBrowsers.find((b) => b.path === browser);
  if (result) {
    debug11("identified browser by path: %o", result);
    return {
      browserName: result.displayName ?? result.name,
      browserVersion: result.version
    };
  }
  warn("Unable to identify browser name and version");
  return {
    browserName: "unknown",
    browserVersion: "unknown"
  };
}

// lib/platform/platform.ts
import Debug10 from "debug";
import getos from "getos";
import { cpus, freemem, platform, release, totalmem } from "os";
import { promisify } from "util";
var debug12 = Debug10("currents:platform");
var getOsVersion = async () => {
  if (platform() === "linux") {
    try {
      const linuxOs = await promisify(getos)();
      if ("dist" in linuxOs && "release" in linuxOs) {
        return [linuxOs.dist, linuxOs.release].join(" - ");
      } else {
        return release();
      }
    } catch {
      return release();
    }
  }
  return release();
};
var getPlatformInfo = async () => {
  const osVersion = await getOsVersion();
  const result = {
    osName: platform(),
    osVersion,
    osCpus: cpus(),
    osMemory: {
      free: freemem(),
      total: totalmem()
    }
  };
  debug12("platform info: %o", result);
  return result;
};

// lib/platform/index.ts
async function getPlatform({
  browser,
  config
}) {
  return {
    ...await getPlatformInfo(),
    ...guessBrowser(browser ?? "electron", config.resolved?.browsers)
  };
}

// lib/results/results.ts
import Debug11 from "debug";
import _9 from "lodash";
import { nanoid } from "nanoid";
var debug13 = Debug11("currents:results");
var isSuccessResult = (result) => {
  return result.status === "finished";
};
var getScreenshotsSummary = (tests = []) => {
  return tests.flatMap(
    (test, i) => test.attempts.flatMap(
      (a, ai) => a.screenshots.flatMap((s) => ({
        ...s,
        testId: `r${i}`,
        testAttemptIndex: ai,
        screenshotId: nanoid()
      }))
    )
  );
};
var getStats = (stats) => {
  return {
    ...stats,
    wallClockDuration: stats.duration,
    wallClockStartedAt: stats.startedAt,
    wallClockEndedAt: stats.endedAt
  };
};
var getTestAttempt = (attempt) => {
  return {
    ...attempt,
    state: attempt.state,
    wallClockDuration: attempt.duration,
    wallClockStartedAt: attempt.startedAt
  };
};
var getInstanceResultPayload = (runResult) => {
  return {
    stats: getStats(runResult.stats),
    reporterStats: runResult.reporterStats,
    exception: runResult.error ?? null,
    video: !!runResult.video,
    // Did the instance generate a video?
    screenshots: getScreenshotsSummary(runResult.tests ?? []),
    tests: runResult.tests?.map((test, i) => ({
      displayError: test.displayError,
      state: test.state,
      hooks: runResult.hooks,
      attempts: test.attempts?.map(getTestAttempt) ?? [],
      clientId: `r${i}`
    })) ?? []
  };
};
function getFakeTestFromException(error2, stats) {
  return {
    title: ["Unknown"],
    body: "",
    displayError: error2.split("\n")[0],
    state: "failed",
    hooks: [],
    attempts: [
      getTestAttempt({
        state: "failed",
        duration: 0,
        error: {
          name: "Error",
          message: error2.split("\n")[0],
          stack: error2
        },
        screenshots: [],
        startedAt: stats.startedAt,
        videoTimestamp: 0
      })
    ],
    clientId: "r0"
  };
}
var getInstanceTestsPayload = (runResult, config) => {
  return {
    config,
    tests: runResult.tests?.map((test, i) => ({
      title: test.title,
      config: null,
      body: test.body,
      clientId: `r${i}`,
      hookIds: []
    })) ?? [],
    hooks: runResult.hooks
  };
};
var summarizeTestResults = (input, config) => {
  if (!input.length) {
    return getEmptyCypressResults(config);
  }
  const overall = input.reduce(
    (acc, {
      totalDuration,
      totalFailed,
      totalPassed,
      totalPending,
      totalSkipped,
      totalTests,
      totalSuites
    }) => ({
      totalDuration: acc.totalDuration + totalDuration,
      totalSuites: acc.totalSuites + totalSuites,
      totalPending: acc.totalPending + totalPending,
      totalFailed: acc.totalFailed + totalFailed,
      totalSkipped: acc.totalSkipped + totalSkipped,
      totalPassed: acc.totalPassed + totalPassed,
      totalTests: acc.totalTests + totalTests
    }),
    emptyStats
  );
  const firstResult = input[0];
  const startItems = input.map((i) => i.startedTestsAt).sort();
  const endItems = input.map((i) => i.endedTestsAt).sort();
  const runs = input.map((i) => i.runs).flat();
  return {
    ...overall,
    runs,
    startedTestsAt: _9.first(startItems),
    endedTestsAt: _9.last(endItems),
    ..._9.pick(
      firstResult,
      "browserName",
      "browserVersion",
      "browserPath",
      "osName",
      "osVersion",
      "cypressVersion",
      "config"
    ),
    status: "finished"
  };
};
function getEmptyCypressResults(config) {
  return {
    ...emptyStats,
    status: "finished",
    startedTestsAt: (/* @__PURE__ */ new Date()).toISOString(),
    endedTestsAt: (/* @__PURE__ */ new Date()).toISOString(),
    runs: [],
    // @ts-ignore
    config
  };
}
var emptyStats = {
  totalDuration: 0,
  totalSuites: 0,
  totalPending: 0,
  totalFailed: 0,
  totalSkipped: 0,
  totalPassed: 0,
  totalTests: 0
};
var getDummyFailedTest = (start, error2) => ({
  title: ["Unknown"],
  state: "failed",
  body: "// This test is automatically generated due to execution failure",
  displayError: error2,
  attempts: [
    {
      state: "failed",
      startedAt: start,
      duration: 0,
      videoTimestamp: 0,
      screenshots: [],
      error: {
        name: "CypressExecutionError",
        message: error2,
        stack: ""
      }
    }
  ]
});
function getFailedDummyResult(configState, {
  specs,
  error: error2
}) {
  const start = (/* @__PURE__ */ new Date()).toISOString();
  const end = (/* @__PURE__ */ new Date()).toISOString();
  return {
    // @ts-ignore
    config: configState.getConfig() ?? {},
    status: "finished",
    startedTestsAt: (/* @__PURE__ */ new Date()).toISOString(),
    endedTestsAt: (/* @__PURE__ */ new Date()).toISOString(),
    totalDuration: 0,
    totalSuites: 1,
    totalFailed: 1,
    totalPassed: 0,
    totalPending: 0,
    totalSkipped: 0,
    totalTests: 1,
    browserName: "unknown",
    browserVersion: "unknown",
    browserPath: "unknown",
    osName: "unknown",
    osVersion: "unknown",
    cypressVersion: "unknown",
    runs: specs.map((s) => ({
      stats: {
        suites: 1,
        tests: 1,
        passes: 0,
        pending: 0,
        skipped: 0,
        failures: 1,
        startedAt: start,
        endedAt: end,
        duration: 0
      },
      reporter: "spec",
      reporterStats: {},
      hooks: [],
      error: error2,
      video: null,
      spec: {
        name: s,
        relative: s,
        absolute: s,
        relativeToCommonRoot: s
      },
      tests: [getDummyFailedTest(start, error2)],
      shouldUploadVideo: false,
      skippedSpec: false
    }))
  };
}
function getCypressRunResultForSpec(spec, cypressResult) {
  if (!isSuccessResult(cypressResult)) {
    return;
  }
  const run3 = cypressResult.runs.find((r) => r.spec.relative === spec);
  if (!run3) {
    return;
  }
  const stats = getStats(run3.stats);
  return {
    ...cypressResult,
    runs: [run3],
    totalSuites: 1,
    totalDuration: stats.wallClockDuration,
    totalTests: stats.tests,
    totalFailed: stats.failures,
    totalPassed: stats.passes,
    totalPending: stats.pending,
    totalSkipped: stats.skipped,
    startedTestsAt: stats.wallClockStartedAt,
    endedTestsAt: stats.wallClockEndedAt
  };
}

// lib/results/table.ts
import _10 from "lodash";
import prettyMS from "pretty-ms";
import { table } from "table";
var failureIcon = red("\u2716");
var successIcon = green("\u2714");
var summaryTable = (r) => {
  const overallSpecCount = r.runs.length;
  const failedSpecsCount = _10.sum(
    r.runs.filter((v) => v.stats.failures + v.stats.skipped > 0).map(() => 1)
  );
  const hasFailed = failedSpecsCount > 0;
  const verdict = hasFailed ? red(`${failedSpecsCount} of ${overallSpecCount} failed`) : overallSpecCount > 0 ? "All specs passed!" : "No specs executed";
  const data = r.runs.map((r2) => [
    r2.stats.failures + r2.stats.skipped > 0 ? failureIcon : successIcon,
    r2.spec.relativeToCommonRoot,
    gray(prettyMS(r2.stats.duration)),
    white(r2.stats.tests ?? 0),
    r2.stats.passes ? green(r2.stats.passes) : gray("-"),
    r2.stats.failures ? red(r2.stats.failures) : gray("-"),
    r2.stats.pending ? cyan(r2.stats.pending) : gray("-"),
    r2.stats.skipped ? red(r2.stats.skipped) : gray("-")
  ]);
  return table(
    [
      [
        "",
        // marker
        gray("Spec"),
        "",
        gray("Tests"),
        gray("Passing"),
        gray("Failing"),
        gray("Pending"),
        gray("Skipped")
      ],
      ...data,
      [
        hasFailed ? failureIcon : successIcon,
        // marker
        verdict,
        gray(prettyMS(r.totalDuration ?? 0)),
        overallSpecCount > 0 ? white(r.totalTests ?? 0) : gray("-"),
        r.totalPassed ? green(r.totalPassed) : gray("-"),
        r.totalFailed ? red(r.totalFailed) : gray("-"),
        r.totalPending ? cyan(r.totalPending) : gray("-"),
        r.totalSkipped ? red(r.totalSkipped) : gray("-")
      ]
    ],
    {
      border,
      columnDefault: {
        width: 8
      },
      columns: [
        { alignment: "left", width: 2 },
        { alignment: "left", width: 30 },
        { alignment: "right" },
        { alignment: "right" },
        { alignment: "right" },
        { alignment: "right" },
        { alignment: "right" },
        { alignment: "right" }
      ],
      // singleLine: true,
      drawHorizontalLine: (lineIndex, rowCount) => {
        return lineIndex === 1 || lineIndex === 0 || lineIndex === rowCount - 1 || lineIndex === rowCount;
      },
      drawVerticalLine: (lineIndex, rowCount) => {
        return lineIndex === 0 || rowCount === lineIndex;
      }
    }
  );
};
var border = _10.mapValues(
  {
    topBody: `\u2500`,
    topJoin: `\u252C`,
    topLeft: `  \u250C`,
    topRight: `\u2510`,
    bottomBody: `\u2500`,
    bottomJoin: `\u2534`,
    bottomLeft: `  \u2514`,
    bottomRight: `\u2518`,
    bodyLeft: `  \u2502`,
    bodyRight: `\u2502`,
    bodyJoin: `\u2502`,
    joinBody: `\u2500`,
    joinLeft: `  \u251C`,
    joinRight: `\u2524`,
    joinJoin: `\u253C`
  },
  (v) => gray(v)
);

// lib/results/uploadResults.ts
import Debug14 from "debug";

// lib/artifacts.ts
import Debug13 from "debug";

// lib/upload.ts
import Debug12 from "debug";
import fs2 from "fs";
var readFile = fs2.promises.readFile;
var debug14 = Debug12("currents:upload");
function uploadVideo(file2, url) {
  return uploadFile(file2, url, "video/mp4");
}
function uploadImage(file2, url) {
  return uploadFile(file2, url, "image/png");
}
async function uploadFile(file2, url, type) {
  debug14('uploading file "%s" to "%s"', file2, url);
  const f = await readFile(file2);
  await makeRequest({
    url,
    method: "PUT",
    data: f,
    headers: {
      "Content-Type": type,
      "Content-Disposition": `inline`
    }
  });
}

// lib/artifacts.ts
var debug15 = Debug13("currents:artifacts");
async function uploadArtifacts({
  videoPath,
  videoUploadUrl,
  screenshots,
  screenshotUploadUrls
}) {
  debug15("uploading artifacts: %o", {
    videoPath,
    videoUploadUrl,
    screenshots,
    screenshotUploadUrls
  });
  const totalUploads = (videoPath ? 1 : 0) + screenshots.length;
  if (totalUploads === 0) {
    return;
  }
  if (videoUploadUrl && videoPath) {
    await safe(
      uploadVideo,
      (e) => debug15("failed uploading video %s. Error: %o", videoPath, e),
      () => debug15("success uploading", videoPath)
    )(videoPath, videoUploadUrl);
  }
  if (screenshotUploadUrls && screenshotUploadUrls.length) {
    await Promise.all(
      screenshots.map((screenshot) => {
        const url = screenshotUploadUrls.find(
          (urls) => urls.screenshotId === screenshot.screenshotId
        )?.uploadUrl;
        if (!url) {
          debug15(
            "No upload url for screenshot %o, screenshotUploadUrls: %o",
            screenshot,
            screenshotUploadUrls
          );
          warn("Cannot find upload url for screenshot: %s", screenshot.path);
          return Promise.resolve();
        }
        return safe(
          uploadImage,
          (e) => debug15(
            "failed uploading screenshot %s. Error: %o",
            screenshot.path,
            e
          ),
          () => debug15("success uploading", screenshot.path)
        )(screenshot.path, url);
      })
    );
  }
}
var uploadStdoutSafe = safe(
  updateInstanceStdout,
  () => {
  },
  () => {
  }
);

// lib/cancellation/cancellation.ts
var state = {
  cancellationReason: null
};
var setCancellationReason = (reason) => {
  if (state.cancellationReason) {
    return;
  }
  state.cancellationReason = reason;
  pubsub.emit("runCancelled" /* RUN_CANCELLED */, reason);
};

// lib/results/uploadResults.ts
var debug16 = Debug14("currents:results");
async function getReportResultsTask(instanceId, results, stdout2) {
  const run3 = results.runs[0];
  if (!run3) {
    throw new Error("No run found in Cypress results");
  }
  const instanceResults = getInstanceResultPayload(run3);
  const instanceTests = getInstanceTestsPayload(run3, results.config);
  const { videoUploadUrl, screenshotUploadUrls, cloud } = await reportResults(
    instanceId,
    instanceTests,
    instanceResults
  );
  if (cloud?.shouldCancel) {
    debug16("instance %s should cancel", instanceId);
    setCancellationReason(cloud.shouldCancel);
  }
  debug16("instance %s artifact upload instructions %o", instanceId, {
    videoUploadUrl,
    screenshotUploadUrls
  });
  return Promise.all([
    uploadArtifacts({
      videoUploadUrl,
      videoPath: run3.video,
      screenshotUploadUrls,
      screenshots: instanceResults.screenshots
    }),
    uploadStdoutSafe(instanceId, getInitialOutput() + stdout2)
  ]);
}
async function reportResults(instanceId, instanceTests, instanceResults) {
  debug16("reporting instance %s results...", instanceId);
  if (isCurrents()) {
    return reportInstanceResultsMerged(instanceId, {
      tests: instanceTests,
      results: instanceResults
    });
  }
  await setInstanceTests(instanceId, instanceTests);
  return updateInstanceResults(instanceId, instanceResults);
}

// lib/runner/runner.ts
import Debug16 from "debug";

// lib/runner/reportTask.ts
import Debug15 from "debug";
var debug17 = Debug15("currents:reportTask");
var reportTasks = [];
var createReportTask = (configState, executionState, instanceId) => {
  const instance = executionState.getInstance(instanceId);
  if (!instance) {
    error("Cannot find execution state for instance %s", instanceId);
    return;
  }
  if (instance.reportStartedAt) {
    debug17("Report task already created for instance %s", instanceId);
    return;
  }
  instance.reportStartedAt = /* @__PURE__ */ new Date();
  debug17("Creating report task for instanceId %s", instanceId);
  reportTasks.push(
    getReportResultsTask(
      instanceId,
      executionState.getInstanceResults(configState, instanceId),
      instance.output ?? "no output captured"
    ).catch(error)
  );
};
var createReportTaskSpec = (configState, executionState, spec) => {
  const i = executionState.getSpec(spec);
  if (!i) {
    error("Cannot find execution state for spec %s", spec);
    return;
  }
  debug17("Creating report task for spec %s", spec);
  return createReportTask(configState, executionState, i.instanceId);
};

// lib/runner/runner.ts
var debug18 = Debug16("currents:runner");
async function runTillDone(executionState, configState, {
  runId,
  groupId,
  machineId,
  platform: platform2,
  specs: allSpecs
}, params) {
  let hasMore = true;
  while (hasMore) {
    const newTasks = await runBatch(executionState, configState, {
      runMeta: {
        runId,
        groupId,
        machineId,
        platform: platform2
      },
      allSpecs,
      params
    });
    if (!newTasks.length) {
      debug18("No more tasks to run. Uploads queue: %d", reportTasks.length);
      hasMore = false;
      break;
    }
    newTasks.forEach(
      (t) => createReportTask(configState, executionState, t.instanceId)
    );
  }
}
async function runBatch(executionState, configState, {
  runMeta,
  params,
  allSpecs
}) {
  let batch = {
    specs: [],
    claimedInstances: 0,
    totalInstances: 0
  };
  if (isCurrents()) {
    debug18("Getting batched tasks: %d", params.batchSize);
    batch = await createBatchedInstances({
      ...runMeta,
      batchSize: params.batchSize
    });
    debug18("Got batched tasks: %o", batch);
  } else {
    const response = await createInstance(runMeta);
    if (response.spec !== null && response.instanceId !== null) {
      batch.specs.push({
        spec: response.spec,
        instanceId: response.instanceId
      });
    }
    batch.claimedInstances = response.claimedInstances;
    batch.totalInstances = response.totalInstances;
  }
  if (batch.specs.length === 0) {
    return [];
  }
  batch.specs.forEach((i) => executionState.initInstance(i));
  divider();
  info(
    "Running: %s (%d/%d)",
    batch.specs.map((s) => s.spec).join(", "),
    batch.claimedInstances,
    batch.totalInstances
  );
  const rawResult = await runSpecFileSafe(
    {
      // use absolute paths - user can run the program from a different directory, e.g. nx or a monorepo workspace
      // cypress still report the path relative to the project root
      spec: batch.specs.map((bs) => getSpecAbsolutePath(allSpecs, bs.spec)).join(",")
    },
    params
  );
  title("blue", "Reporting results and artifacts in background...");
  const output = getCapturedOutput();
  batch.specs.forEach((spec) => {
    executionState.setInstanceOutput(spec.instanceId, output);
    const specRunResult = getCypressRunResultForSpec(spec.spec, rawResult);
    if (!specRunResult) {
      return;
    }
    executionState.setInstanceResult(
      configState,
      spec.instanceId,
      specRunResult
    );
  });
  resetCapture();
  return batch.specs;
}
function getSpecAbsolutePath(allSpecs, relative) {
  const absolutePath = allSpecs.find((i) => i.relative === relative)?.absolute;
  if (!absolutePath) {
    warn(
      'Cannot find absolute path for spec. Spec: "%s", candidates: %o',
      relative,
      allSpecs
    );
    throw new Error(`Cannot find absolute path for spec`);
  }
  return absolutePath;
}

// lib/runner/cancellable.ts
var cancellable = null;
function onRunCancelled(reason) {
  warn(
    `Run cancelled: %s. Waiting for uploads to complete and stopping execution...`,
    reason
  );
  cancellable?.cancel();
}
async function runTillDoneOrCancelled(...args) {
  return new Promise((_resolve, _reject) => {
    cancellable = new BPromise((resolve, reject, onCancel) => {
      if (!onCancel) {
        _reject(new Error("BlueBird is misconfigured: onCancel is undefined"));
        return;
      }
      onCancel(() => _resolve(void 0));
      runTillDone(...args).then(
        () => {
          resolve();
          _resolve(void 0);
        },
        (error2) => {
          reject();
          _reject(error2);
        }
      );
    });
    pubsub.addListener("runCancelled" /* RUN_CANCELLED */, onRunCancelled);
  }).finally(() => {
    pubsub.removeListener("runCancelled" /* RUN_CANCELLED */, onRunCancelled);
  });
}

// lib/shutdown.ts
async function shutdown() {
  await stopWSS();
}

// lib/specMatcher/specMatcher.ts
import Debug17 from "debug";
import path3 from "path";
import commonPathPrefix from "common-path-prefix";
import globby from "globby";
import _11 from "lodash";
import os from "os";

// lib/utils.ts
import path2 from "path";
function toArray(val) {
  return val ? typeof val === "string" ? [val] : val : [];
}
function toPosix(file2, sep = path2.sep) {
  return file2.split(sep).join(path2.posix.sep);
}

// lib/specMatcher/specMatcher.ts
var debug19 = Debug17("currents:specs");
async function findSpecs({
  projectRoot,
  testingType,
  specPattern,
  configSpecPattern,
  excludeSpecPattern,
  additionalIgnorePattern
}) {
  configSpecPattern = toArray(configSpecPattern);
  specPattern = toArray(specPattern);
  excludeSpecPattern = toArray(excludeSpecPattern) || [];
  additionalIgnorePattern = toArray(additionalIgnorePattern) || [];
  debug19("exploring spec files for execution %O", {
    testingType,
    projectRoot,
    specPattern,
    configSpecPattern,
    excludeSpecPattern,
    additionalIgnorePattern
  });
  if (!specPattern || !configSpecPattern) {
    throw Error("Could not find glob patterns for exploring specs");
  }
  let specAbsolutePaths = await getFilesByGlob(projectRoot, specPattern, {
    absolute: true,
    ignore: [...excludeSpecPattern, ...additionalIgnorePattern]
  });
  if (!_11.isEqual(specPattern, configSpecPattern)) {
    const defaultSpecAbsolutePaths = await getFilesByGlob(
      projectRoot,
      configSpecPattern,
      {
        absolute: true,
        ignore: [...excludeSpecPattern, ...additionalIgnorePattern]
      }
    );
    specAbsolutePaths = _11.intersection(
      specAbsolutePaths,
      defaultSpecAbsolutePaths
    );
  }
  return matchedSpecs({
    projectRoot,
    testingType,
    specAbsolutePaths,
    specPattern
  });
}
async function getFilesByGlob(projectRoot, glob, globOptions) {
  const workingDirectoryPrefix = path3.join(projectRoot, path3.sep);
  const globs = [].concat(glob).map(
    (globPattern) => globPattern.startsWith("./") ? globPattern.replace("./", "") : globPattern
  ).map((globPattern) => {
    if (globPattern.startsWith(workingDirectoryPrefix)) {
      return globPattern.replace(workingDirectoryPrefix, "");
    }
    return globPattern;
  });
  if (os.platform() === "win32") {
    debug19("updating glob patterns to POSIX");
    for (const i in globs) {
      const cur = globs[i];
      if (!cur)
        throw new Error("undefined glob received");
      globs[i] = toPosix(cur);
    }
  }
  try {
    debug19("globbing pattern(s): %o", globs);
    debug19("within directory: %s", projectRoot);
    return matchGlobs(globs, {
      onlyFiles: true,
      absolute: true,
      cwd: projectRoot,
      ...globOptions,
      ignore: (globOptions?.ignore ?? []).concat("**/node_modules/**")
    });
  } catch (e) {
    debug19("error in getFilesByGlob %o", e);
    return [];
  }
}
var matchGlobs = async (globs, globbyOptions) => {
  return await globby(globs, globbyOptions);
};
function matchedSpecs({
  projectRoot,
  testingType,
  specAbsolutePaths
}) {
  debug19("found specs %o", specAbsolutePaths);
  let commonRoot = "";
  if (specAbsolutePaths.length === 1) {
    commonRoot = path3.dirname(specAbsolutePaths[0]);
  } else {
    commonRoot = commonPathPrefix(specAbsolutePaths);
  }
  return specAbsolutePaths.map(
    (absolute) => transformSpec({
      projectRoot,
      absolute,
      testingType,
      commonRoot,
      platform: os.platform(),
      sep: path3.sep
    })
  );
}
function transformSpec({
  projectRoot,
  absolute,
  testingType,
  commonRoot,
  platform: platform2,
  sep
}) {
  if (platform2 === "win32") {
    absolute = toPosix(absolute, sep);
    projectRoot = toPosix(projectRoot, sep);
  }
  const relative = path3.relative(projectRoot, absolute);
  const parsedFile = path3.parse(absolute);
  const fileExtension = path3.extname(absolute);
  const specFileExtension = [".spec", ".test", "-spec", "-test", ".cy"].map((ext) => ext + fileExtension).find((ext) => absolute.endsWith(ext)) || fileExtension;
  const parts = absolute.split(projectRoot);
  let name = parts[parts.length - 1] || "";
  if (name.startsWith("/")) {
    name = name.slice(1);
  }
  const LEADING_SLASH = /^\/|/g;
  const relativeToCommonRoot = absolute.replace(commonRoot, "").replace(LEADING_SLASH, "");
  return {
    fileExtension,
    baseName: parsedFile.base,
    fileName: parsedFile.base.replace(specFileExtension, ""),
    specFileExtension,
    relativeToCommonRoot,
    specType: testingType === "component" ? "component" : "integration",
    name,
    relative,
    absolute
  };
}

// lib/specMatcher/getSpecFiles.ts
var getSpecFiles = async ({
  config,
  params
}) => {
  const specPattern = getSpecPattern(config.specPattern, params.spec);
  const specs = await findSpecs({
    // https://docs.cypress.io/guides/guides/command-line#cypress-run-spec-lt-spec-gt
    projectRoot: params.project ?? config.projectRoot,
    testingType: params.testingType,
    specPattern,
    configSpecPattern: config.specPattern,
    excludeSpecPattern: config.excludeSpecPattern,
    additionalIgnorePattern: config.additionalIgnorePattern
  });
  if (specs.length === 0) {
    warn(
      "Found no spec files. Was looking for spec files that match both configSpecPattern and specPattern relative to projectRoot. Configuration: %O",
      {
        projectRoot: config.projectRoot,
        specPattern,
        configSpecPattern: config.specPattern,
        excludeSpecPattern: [
          config.excludeSpecPattern,
          config.additionalIgnorePattern
        ].flat(2),
        testingType: params.testingType
      }
    );
  }
  return { specs, specPattern };
};
function getSpecPattern(configPattern, explicit) {
  return explicit || configPattern;
}

// lib/state/config.ts
var ConfigState = class {
  constructor() {
    this._config = void 0;
  }
  setConfig(c) {
    this._config = c;
  }
  getConfig() {
    return this._config;
  }
};

// lib/results/mapResult.ts
function getScreenshot(s) {
  return {
    ...s,
    name: s.name ?? "screenshot"
  };
}
function getTestAttempt2(attempt, screenshots) {
  return {
    ...attempt,
    startedAt: attempt.wallClockStartedAt,
    duration: attempt.wallClockDuration,
    screenshots: screenshots.map(getScreenshot)
  };
}
function getTest(t, screenshots) {
  const _screenshots = screenshots.filter((s) => s.testId === t.testId);
  return {
    ...t,
    attempts: t.attempts.map(
      (a, i) => getTestAttempt2(
        a,
        _screenshots.filter((s) => s.testAttemptIndex === i)
      )
    )
  };
}
function specResultsToCypressResults(configState, specAfterResult) {
  return {
    status: "finished",
    // @ts-ignore
    config: configState.getConfig(),
    totalDuration: specAfterResult.stats.wallClockDuration,
    totalSuites: specAfterResult.stats.suites,
    totalTests: specAfterResult.stats.tests,
    totalFailed: specAfterResult.stats.failures,
    totalPassed: specAfterResult.stats.passes,
    totalPending: specAfterResult.stats.pending,
    totalSkipped: specAfterResult.stats.skipped,
    startedTestsAt: specAfterResult.stats.wallClockStartedAt,
    endedTestsAt: specAfterResult.stats.wallClockEndedAt,
    runs: [
      {
        stats: {
          ...specAfterResult.stats,
          startedAt: specAfterResult.stats.wallClockStartedAt,
          endedAt: specAfterResult.stats.wallClockEndedAt,
          duration: specAfterResult.stats.wallClockDuration
        },
        reporter: specAfterResult.reporter,
        reporterStats: specAfterResult.reporterStats ?? {},
        spec: specAfterResult.spec,
        error: specAfterResult.error,
        video: specAfterResult.video,
        shouldUploadVideo: true,
        // not really used
        // @ts-ignore
        // wrong typedef for CypressCommandLine.CypressRunResult
        // actual HookName is "before all" | "before each" | "after all" | "after each"
        hooks: specAfterResult.hooks,
        tests: (specAfterResult.tests ?? []).map(
          (t) => getTest(t, specAfterResult.screenshots)
        )
      }
    ]
  };
}
var backfillException = (result) => {
  return {
    ...result,
    runs: result.runs.map(backfillExceptionRun)
  };
};
var backfillExceptionRun = (run3) => {
  if (!run3.error) {
    return run3;
  }
  return {
    ...run3,
    tests: [getFakeTestFromException(run3.error, run3.stats)]
  };
};

// lib/state/execution.ts
import Debug18 from "debug";
var debug20 = Debug18("currents:state");
var ExecutionState = class {
  constructor() {
    this.state = {};
  }
  getResults(configState) {
    return Object.values(this.state).map(
      (i) => this.getInstanceResults(configState, i.instanceId)
    );
  }
  getInstance(instanceId) {
    return this.state[instanceId];
  }
  getSpec(spec) {
    return Object.values(this.state).find((i) => i.spec === spec);
  }
  initInstance({
    instanceId,
    spec
  }) {
    debug20('Init execution state for "%s"', spec);
    this.state[instanceId] = {
      instanceId,
      spec,
      createdAt: /* @__PURE__ */ new Date()
    };
  }
  setSpecBefore(spec) {
    const i = this.getSpec(spec);
    if (!i) {
      warn('Cannot find execution state for spec "%s"', spec);
      return;
    }
    i.specBefore = /* @__PURE__ */ new Date();
  }
  setSpecAfter(spec, results) {
    const i = this.getSpec(spec);
    if (!i) {
      warn('Cannot find execution state for spec "%s"', spec);
      return;
    }
    i.specAfter = /* @__PURE__ */ new Date();
    i.specAfterResults = results;
  }
  setSpecOutput(spec, output) {
    const i = this.getSpec(spec);
    if (!i) {
      warn('Cannot find execution state for spec "%s"', spec);
      return;
    }
    this.setInstanceOutput(i.instanceId, output);
  }
  setInstanceOutput(instanceId, output) {
    const i = this.state[instanceId];
    if (!i) {
      warn('Cannot find execution state for instance "%s"', instanceId);
      return;
    }
    if (i.output) {
      debug20('Instance "%s" already has output', instanceId);
      return;
    }
    i.output = output;
  }
  setInstanceResult(configState, instanceId, results) {
    const i = this.state[instanceId];
    if (!i) {
      warn('Cannot find execution state for instance "%s"', instanceId);
      return;
    }
    i.runResults = results;
    i.runResultsReportedAt = /* @__PURE__ */ new Date();
  }
  getInstanceResults(configState, instanceId) {
    const i = this.getInstance(instanceId);
    if (!i) {
      error('Cannot find execution state for instance "%s"', instanceId);
      return getFailedDummyResult(configState, {
        specs: ["unknown"],
        error: "Cannot find execution state for instance"
      });
    }
    if (i.specAfterResults) {
      return backfillException(
        specResultsToCypressResults(configState, i.specAfterResults)
      );
    }
    if (i.runResults) {
      return backfillException(i.runResults);
    }
    debug20('No results detected for "%s"', i.spec);
    return getFailedDummyResult(configState, {
      specs: [i.spec],
      error: `No results detected for the spec file. That usually happens because of cypress crash. See the console output for details.`
    });
  }
};

// lib/run.ts
var debug21 = Debug19("currents:run");
async function run(params = {}) {
  const executionState = new ExecutionState();
  const configState = new ConfigState();
  activateDebug(params.cloudDebug);
  debug21("run params %o", params);
  params = preprocessParams(params);
  debug21("params after preprocess %o", params);
  if (isOffline(params)) {
    info(`Skipping cloud orchestration because --record is set to false`);
    return runBareCypress(params);
  }
  const validatedParams = await validateParams(params);
  setAPIBaseUrl(validatedParams.cloudServiceUrl);
  if (!isCurrents()) {
    console.log(getLegalNotice());
  }
  const {
    recordKey,
    projectId,
    group,
    parallel,
    ciBuildId,
    tag,
    testingType,
    batchSize,
    autoCancelAfterFailures
  } = validatedParams;
  const config = await getMergedConfig(validatedParams);
  configState.setConfig(config?.resolved);
  const { specs, specPattern } = await getSpecFiles({
    config,
    params: validatedParams
  });
  if (specs.length === 0) {
    return;
  }
  const platform2 = await getPlatform({
    config,
    browser: validatedParams.browser
  });
  info("Discovered %d spec files", specs.length);
  info(
    `Tags: ${tag.length > 0 ? tag.join(",") : false}; Group: ${group ?? false}; Parallel: ${parallel ?? false}; Batch Size: ${batchSize}`
  );
  info("Connecting to cloud orchestration service...");
  const run3 = await createRun({
    ci: getCI(ciBuildId),
    specs: specs.map((spec) => spec.relative),
    commit: await getGitInfo(config.projectRoot),
    group,
    platform: platform2,
    parallel: parallel ?? false,
    ciBuildId,
    projectId,
    recordKey,
    specPattern: [specPattern].flat(2),
    tags: tag,
    testingType,
    batchSize,
    autoCancelAfterFailures
  });
  setRunId(run3.runId);
  info("\u{1F3A5} Run URL:", bold(run3.runUrl));
  cutInitialOutput();
  await startWSS();
  listenToSpecEvents(configState, executionState);
  await runTillDoneOrCancelled(
    executionState,
    configState,
    {
      runId: run3.runId,
      groupId: run3.groupId,
      machineId: run3.machineId,
      platform: platform2,
      specs
    },
    validatedParams
  );
  divider();
  await Promise.allSettled(reportTasks);
  const _summary = summarizeTestResults(
    executionState.getResults(configState),
    config
  );
  title("white", "Cloud Run Finished");
  console.log(summaryTable(_summary));
  info("\u{1F3C1} Recorded Run:", bold(run3.runUrl));
  await shutdown();
  spacer();
  if (_summary.status === "finished") {
    return {
      ..._summary,
      runUrl: run3.runUrl
    };
  }
  return _summary;
}
function listenToSpecEvents(configState, executionState) {
  pubsub.on("before:spec", async ({ spec }) => {
    debug21("before:spec %o", spec);
    executionState.setSpecBefore(spec.relative);
  });
  pubsub.on(
    "after:spec",
    async ({ spec, results }) => {
      debug21("after:spec %o %o", spec, results);
      executionState.setSpecAfter(spec.relative, results);
      executionState.setSpecOutput(spec.relative, getCapturedOutput());
      createReportTaskSpec(configState, executionState, spec.relative);
    }
  );
}

// index.ts
function run2(params) {
  return run(params);
}
export {
  run2 as run
};
/*! @preserve

### MIT

Parts of this code was copied from https://github.com/cypress-io/cypress and is subject to MIT license.

MIT License

Copyright (c) 2022 Cypress.io

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vaW5kZXgudHMiLCAiLi4vbGliL3JlcXVpcmUudHMiLCAiLi4vbGliL3N0ZG91dC50cyIsICIuLi9saWIvd3Mvd3MudHMiLCAiLi4vbGliL3B1YnN1Yi50cyIsICIuLi9saWIvY2FwdHVyZS50cyIsICIuLi9saWIvaHR0cENsaWVudC9jb25maWcudHMiLCAiLi4vbGliL2h0dHBDbGllbnQvaHR0cENsaWVudC50cyIsICIuLi9saWIvY29uZmlnL2NvbmZpZy50cyIsICIuLi9saWIvYm9vdHN0cmFwL2Jvb3RzdHJhcC50cyIsICIuLi9saWIvZXJyb3JzLnRzIiwgIi4uL2xpYi9mcy50cyIsICIuLi9saWIvbG9nLnRzIiwgIi4uL2xpYi9ib290c3RyYXAvc2VyaWFsaXplci50cyIsICIuLi9saWIvY29uZmlnL3BhdGgudHMiLCAiLi4vbGliL2NvbmZpZy9wYXJhbXMudHMiLCAiLi4vbGliL2h0dHBDbGllbnQvcHJpbnRFcnJvcnMudHMiLCAiLi4vbGliL2luaXQudHMiLCAiLi4vbGliL3J1bi50cyIsICIuLi9sZWdhbC50cyIsICIuLi9saWIvYXBpL3dhcm5pbmdzLnRzIiwgIi4uL2xpYi9hcGkvYXBpLnRzIiwgIi4uL2xpYi9jaVByb3ZpZGVyLnRzIiwgIi4uL2xpYi9jeXByZXNzL2N5cHJlc3MudHMiLCAiLi4vbGliL2xhbmcudHMiLCAiLi4vbGliL2RlYnVnL2luZGV4LnRzIiwgIi4uL2xpYi9lbnYudHMiLCAiLi4vbGliL2dpdC50cyIsICIuLi9saWIvcGxhdGZvcm0vYnJvd3Nlci50cyIsICIuLi9saWIvcGxhdGZvcm0vcGxhdGZvcm0udHMiLCAiLi4vbGliL3BsYXRmb3JtL2luZGV4LnRzIiwgIi4uL2xpYi9yZXN1bHRzL3Jlc3VsdHMudHMiLCAiLi4vbGliL3Jlc3VsdHMvdGFibGUudHMiLCAiLi4vbGliL3Jlc3VsdHMvdXBsb2FkUmVzdWx0cy50cyIsICIuLi9saWIvYXJ0aWZhY3RzLnRzIiwgIi4uL2xpYi91cGxvYWQudHMiLCAiLi4vbGliL2NhbmNlbGxhdGlvbi9jYW5jZWxsYXRpb24udHMiLCAiLi4vbGliL3J1bm5lci9ydW5uZXIudHMiLCAiLi4vbGliL3J1bm5lci9yZXBvcnRUYXNrLnRzIiwgIi4uL2xpYi9ydW5uZXIvY2FuY2VsbGFibGUudHMiLCAiLi4vbGliL3NodXRkb3duLnRzIiwgIi4uL2xpYi9zcGVjTWF0Y2hlci9zcGVjTWF0Y2hlci50cyIsICIuLi9saWIvdXRpbHMudHMiLCAiLi4vbGliL3NwZWNNYXRjaGVyL2dldFNwZWNGaWxlcy50cyIsICIuLi9saWIvc3RhdGUvY29uZmlnLnRzIiwgIi4uL2xpYi9yZXN1bHRzL21hcFJlc3VsdC50cyIsICIuLi9saWIvc3RhdGUvZXhlY3V0aW9uLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyIvLy8gPHJlZmVyZW5jZSB0eXBlcz1cImN5cHJlc3NcIiAvPlxuaW1wb3J0IFwic291cmNlLW1hcC1zdXBwb3J0L3JlZ2lzdGVyLmpzXCI7XG5cbmltcG9ydCB7IHJ1biBhcyBpbnRlcm5hbFJ1biB9IGZyb20gXCIuL2xpYi9ydW5cIjtcbmltcG9ydCB7IEN1cnJlbnRzUnVuQVBJIH0gZnJvbSBcIi4vdHlwZXNcIjtcbmV4cG9ydCB0eXBlIHsgQ3VycmVudHNSdW5BUEkgfSBmcm9tIFwiLi90eXBlc1wiO1xuLyoqXG4gKiBSdW4gQ3lwcmVzcyB0ZXN0cyB3aXRoIGEgY2xvdWQgc2VydmljZSBvZiB5b3VyIGNob2ljZSBhbmQgcmV0dXJuIHRoZSByZXN1bHRzXG4gKlxuICogQGF1Z21lbnRzIEN1cnJlbnRzUnVuQVBJXG4gKiBAcmV0dXJucyB7Q3lwcmVzc0NvbW1hbmRMaW5lLkN5cHJlc3NSdW5SZXN1bHQgfCBDeXByZXNzQ29tbWFuZExpbmUuQ3lwcmVzc0ZhaWxlZFJ1blJlc3VsdCB8IHVuZGVmaW5lZH0gVGhlIHRlc3QgcmVzdWx0cywgb3IgdW5kZWZpbmVkIGlmIG5vIHRlc3RzIHdlcmUgcnVuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBydW4ocGFyYW1zPzogQ3VycmVudHNSdW5BUEkpIHtcbiAgcmV0dXJuIGludGVybmFsUnVuKHBhcmFtcyk7XG59XG4iLCAiaW1wb3J0IHsgY3JlYXRlUmVxdWlyZSB9IGZyb20gXCJtb2R1bGVcIjtcbi8vIHJlcXVpcmVzIHNoaW09dHJ1ZSBpbiBwYWNrYWdlLmpzb25cbmV4cG9ydCBjb25zdCByZXF1aXJlID0gY3JlYXRlUmVxdWlyZShpbXBvcnQubWV0YS51cmwpO1xuIiwgImltcG9ydCBjcCBmcm9tIFwiY2hpbGRfcHJvY2Vzc1wiO1xuY29uc3Qgb3JnaW5hbCA9IGNwLnNwYXduO1xuXG4vLyBAdHMtaWdub3JlXG5jcC5zcGF3biA9IGZ1bmN0aW9uIChjb21tYW5kLCBhcmdzLCBvcHRpb25zKSB7XG4gIC8vIEB0cy1pZ25vcmVcbiAgaWYgKGNvbW1hbmQubWF0Y2goL0N5cHJlc3MvKSkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBwcm9jZXNzID0gb3JnaW5hbChjb21tYW5kLCBhcmdzLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgLy8gdXNpbmcgcGlwZSBlbmFibGVzIGNhcHR1cmluZyBzdGRvdXQgYW5kIHN0ZGVyclxuICAgICAgc3RkaW86IFtcInBpcGVcIiwgXCJwaXBlXCIsIFwicGlwZVwiXSxcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvY2VzcztcbiAgfVxuXG4gIC8vIEB0cy1pZ25vcmVcbiAgcmV0dXJuIG9yZ2luYWwoY29tbWFuZCwgYXJncywgb3B0aW9ucyk7XG59O1xuIiwgImltcG9ydCBEZWJ1ZyBmcm9tIFwiZGVidWdcIjtcbmltcG9ydCBodHRwIGZyb20gXCJodHRwXCI7XG4vLyBAdHMtaWdub3JlXG5pbXBvcnQgSHR0cFRlcm1pbmF0b3IgZnJvbSBcImxpbC1odHRwLXRlcm1pbmF0b3JcIjtcbmltcG9ydCB7IG1hdGNoLCBQIH0gZnJvbSBcInRzLXBhdHRlcm5cIjtcbmltcG9ydCAqIGFzIFdlYlNvY2tldCBmcm9tIFwid3NcIjtcbmltcG9ydCB7IHB1YnN1YiB9IGZyb20gXCIuLi9wdWJzdWJcIjtcblxuY29uc3QgZGVidWcgPSBEZWJ1ZyhcImN1cnJlbnRzOndzXCIpO1xuXG5sZXQgc2VydmVyOiBodHRwLlNlcnZlciB8IG51bGwgPSBudWxsO1xubGV0IHdzczogV2ViU29ja2V0LlNlcnZlciB8IG51bGwgPSBudWxsO1xubGV0IGh0dHBUZXJtaW5hdG9yOiBIdHRwVGVybWluYXRvciB8IG51bGwgPSBudWxsO1xuXG5leHBvcnQgY29uc3QgZ2V0V1NTUG9ydCA9ICgpID0+XG4gIG1hdGNoKHNlcnZlcj8uYWRkcmVzcygpKVxuICAgIC53aXRoKHsgcG9ydDogUC5udW1iZXIgfSwgKGFkZHJlc3MpID0+IGFkZHJlc3MucG9ydClcbiAgICAub3RoZXJ3aXNlKCgpID0+IDApO1xuXG5leHBvcnQgY29uc3Qgc3RvcFdTUyA9IGFzeW5jICgpID0+IHtcbiAgZGVidWcoXCJ0ZXJtaW5hdGluZyB3c3Mgc2VydmVyOiAlZFwiLCBnZXRXU1NQb3J0KCkpO1xuICBpZiAoIWh0dHBUZXJtaW5hdG9yKSB7XG4gICAgZGVidWcoXCJubyB3c3Mgc2VydmVyXCIpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB7IHN1Y2Nlc3MsIGNvZGUsIG1lc3NhZ2UsIGVycm9yIH0gPSBhd2FpdCBodHRwVGVybWluYXRvci50ZXJtaW5hdGUoKTtcbiAgaWYgKCFzdWNjZXNzKSB7XG4gICAgaWYgKGNvZGUgPT09IFwiVElNRURfT1VUXCIpIGVycm9yKG1lc3NhZ2UpO1xuICAgIGlmIChjb2RlID09PSBcIlNFUlZFUl9FUlJPUlwiKSBlcnJvcihtZXNzYWdlLCBlcnJvcik7XG4gICAgaWYgKGNvZGUgPT09IFwiSU5URVJOQUxfRVJST1JcIikgZXJyb3IobWVzc2FnZSwgZXJyb3IpO1xuICB9XG4gIGRlYnVnKFwidGVybWluYXRlZCB3c3Mgc2VydmVyOiAlZFwiLCBnZXRXU1NQb3J0KCkpO1xufTtcbmV4cG9ydCBjb25zdCBzdGFydFdTUyA9ICgpID0+IHtcbiAgaWYgKHdzcykge1xuICAgIHJldHVybjtcbiAgfVxuICBzZXJ2ZXIgPSBodHRwXG4gICAgLmNyZWF0ZVNlcnZlcigpXG4gICAgLm9uKFwibGlzdGVuaW5nXCIsICgpID0+IHtcbiAgICAgIGlmICghc2VydmVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNlcnZlciBub3QgaW5pdGlhbGl6ZWRcIik7XG4gICAgICB9XG4gICAgICB3c3MgPSBuZXcgV2ViU29ja2V0LldlYlNvY2tldFNlcnZlcih7XG4gICAgICAgIHNlcnZlcixcbiAgICAgIH0pO1xuICAgICAgZGVidWcoXCJzdGFydGluZyB3c3Mgb24gcG9ydCAlZFwiLCBnZXRXU1NQb3J0KCkpO1xuICAgICAgd3NzLm9uKFwiY29ubmVjdGlvblwiLCBmdW5jdGlvbiBjb25uZWN0aW9uKHdzKSB7XG4gICAgICAgIHdzLm9uKFwibWVzc2FnZVwiLCBmdW5jdGlvbiBpbmNvbWluZyhldmVudCkge1xuICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBKU09OLnBhcnNlKGV2ZW50LnRvU3RyaW5nKCkpO1xuICAgICAgICAgIHB1YnN1Yi5lbWl0KG1lc3NhZ2UudHlwZSwgbWVzc2FnZS5wYXlsb2FkKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KVxuICAgIC5saXN0ZW4oKTtcblxuICBodHRwVGVybWluYXRvciA9IEh0dHBUZXJtaW5hdG9yKHtcbiAgICBzZXJ2ZXIsXG4gIH0pO1xufTtcbiIsICJpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gXCJldmVudHNcIjtcbmV4cG9ydCBlbnVtIEV2ZW50IHtcbiAgUlVOX0NBTkNFTExFRCA9IFwicnVuQ2FuY2VsbGVkXCIsXG59XG5leHBvcnQgY29uc3QgcHVic3ViID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuIiwgImltcG9ydCBEZWJ1ZyBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gRGVidWcoXCJjdXJyZW50czpjYXB0dXJlXCIpO1xuXG5jb25zdCBfd3JpdGUgPSBwcm9jZXNzLnN0ZG91dC53cml0ZTtcbmNvbnN0IF9sb2cgPSBwcm9jZXNzLmxvZztcblxuZXhwb3J0IGNvbnN0IHJlc3RvcmUgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIHJlc3RvcmUgdG8gdGhlIG9yaWdpbmFsc1xuICBwcm9jZXNzLnN0ZG91dC53cml0ZSA9IF93cml0ZTtcbiAgcHJvY2Vzcy5sb2cgPSBfbG9nO1xufTtcblxuY29uc3QgbG9nczogUmVjb3JkPHN0cmluZywgc3RyaW5nW10+ID0ge307XG5cbmNvbnN0IHN0ZG91dCA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoXCJjYXB0dXJpbmcgc3Rkb3V0XCIpO1xuICBsZXQgbG9nczogc3RyaW5nW10gPSBbXTtcblxuICAvLyBsYXppbHkgYmFja3VwIHdyaXRlIHRvIGVuYWJsZSBpbmplY3Rpb25cbiAgY29uc3QgeyB3cml0ZSB9ID0gcHJvY2Vzcy5zdGRvdXQ7XG4gIGNvbnN0IHsgbG9nIH0gPSBwcm9jZXNzO1xuXG4gIC8vIGVsZWN0cm9uIGFkZHMgYSBuZXcgcHJvY2Vzcy5sb2dcbiAgLy8gbWV0aG9kIGZvciB3aW5kb3dzIGluc3RlYWQgb2YgcHJvY2Vzcy5zdGRvdXQud3JpdGVcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2N5cHJlc3MtaW8vY3lwcmVzcy9pc3N1ZXMvOTc3XG4gIGlmIChsb2cpIHtcbiAgICBwcm9jZXNzLmxvZyA9IGZ1bmN0aW9uIChzdHI6IHN0cmluZykge1xuICAgICAgbG9ncy5wdXNoKHN0cik7XG5cbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItcmVzdC1wYXJhbXNcbiAgICAgIHJldHVybiBsb2cuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgcHJvY2Vzcy5zdGRvdXQud3JpdGUgPSBmdW5jdGlvbiAoc3RyOiBzdHJpbmcpIHtcbiAgICBsb2dzLnB1c2goc3RyKTtcblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLXJlc3QtcGFyYW1zXG4gICAgcmV0dXJuIHdyaXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBsb2dzLmpvaW4oXCJcIik7XG4gICAgfSxcbiAgICBkYXRhOiBsb2dzLFxuICAgIHJlc3RvcmUsXG4gICAgcmVzZXQ6ICgpID0+IHtcbiAgICAgIGRlYnVnKFwicmVzZXR0aW5nIGNhcHR1cmVkIHN0ZG91dFwiKTtcbiAgICAgIGxvZ3MgPSBbXTtcbiAgICB9LFxuICB9O1xufTtcblxubGV0IGluaXRpYWxPdXRwdXQ6IHN0cmluZyA9IFwiXCI7XG5sZXQgY2FwdHVyZWRPdXRwdXQ6IG51bGwgfCBSZXR1cm5UeXBlPHR5cGVvZiBzdGRvdXQ+ID0gbnVsbDtcblxuZXhwb3J0IGNvbnN0IGluaXRDYXB0dXJlID0gKCkgPT4gKGNhcHR1cmVkT3V0cHV0ID0gc3Rkb3V0KCkpO1xuXG5leHBvcnQgY29uc3QgY3V0SW5pdGlhbE91dHB1dCA9ICgpID0+IHtcbiAgaWYgKCFjYXB0dXJlZE91dHB1dCkgdGhyb3cgbmV3IEVycm9yKFwiY2FwdHVyZWRPdXRwdXQgaXMgbnVsbFwiKTtcbiAgaW5pdGlhbE91dHB1dCA9IGNhcHR1cmVkT3V0cHV0LnRvU3RyaW5nKCk7XG4gIGNhcHR1cmVkT3V0cHV0LnJlc2V0KCk7XG59O1xuZXhwb3J0IGNvbnN0IHJlc2V0Q2FwdHVyZSA9ICgpID0+IHtcbiAgaWYgKCFjYXB0dXJlZE91dHB1dCkgdGhyb3cgbmV3IEVycm9yKFwiY2FwdHVyZWRPdXRwdXQgaXMgbnVsbFwiKTtcbiAgY2FwdHVyZWRPdXRwdXQucmVzZXQoKTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRDYXB0dXJlZE91dHB1dCA9ICgpID0+IHtcbiAgaWYgKCFjYXB0dXJlZE91dHB1dCkgdGhyb3cgbmV3IEVycm9yKFwiY2FwdHVyZWRPdXRwdXQgaXMgbnVsbFwiKTtcbiAgcmV0dXJuIGNhcHR1cmVkT3V0cHV0LnRvU3RyaW5nKCk7XG59O1xuZXhwb3J0IGNvbnN0IGdldEluaXRpYWxPdXRwdXQgPSAoKSA9PiBpbml0aWFsT3V0cHV0O1xuIiwgImltcG9ydCB7IEF4aW9zRXJyb3IsIGlzQXhpb3NFcnJvciB9IGZyb20gXCJheGlvc1wiO1xuXG5leHBvcnQgY29uc3QgaXNSZXRyaWFibGVFcnJvciA9IChlcnI6IEF4aW9zRXJyb3IpOiBib29sZWFuID0+IHtcbiAgaWYgKGVyci5jb2RlID09PSBcIkVDT05OQUJPUlRFRFwiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGVyci5jb2RlID09PSBcIkVDT05OUkVGVVNFRFwiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGVyci5jb2RlID09PSBcIkVUSU1FRE9VVFwiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoIWlzQXhpb3NFcnJvcihlcnIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuICEhKFxuICAgIGVycj8ucmVzcG9uc2U/LnN0YXR1cyAmJlxuICAgIDUwMCA8PSBlcnIucmVzcG9uc2Uuc3RhdHVzICYmXG4gICAgZXJyLnJlc3BvbnNlLnN0YXR1cyA8IDYwMFxuICApO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldERlbGF5ID0gKGk6IG51bWJlcikgPT4gWzUgKiAxMDAwLCAxMCAqIDEwMDAsIDMwICogMTAwMF1baSAtIDFdO1xuXG5sZXQgYmFzZVVSTCA9IFwiaHR0cHM6Ly9jeS5jdXJyZW50cy5kZXZcIjtcbmV4cG9ydCBjb25zdCBnZXRBUElCYXNlVXJsID0gKCkgPT4gYmFzZVVSTCA/PyBcImh0dHBzOi8vY3kuY3VycmVudHMuZGV2XCI7XG5leHBvcnQgY29uc3Qgc2V0QVBJQmFzZVVybCA9ICh1cmw/OiBzdHJpbmcpID0+XG4gIChiYXNlVVJMID0gdXJsID8/IFwiaHR0cHM6Ly9jeS5jdXJyZW50cy5kZXZcIik7XG4iLCAiaW1wb3J0IGF4aW9zLCB7XG4gIEF4aW9zRXJyb3IsXG4gIEF4aW9zSW5zdGFuY2UsXG4gIEF4aW9zUmVxdWVzdENvbmZpZyxcbiAgQXhpb3NSZXNwb25zZSxcbiAgUmF3QXhpb3NSZXF1ZXN0SGVhZGVycyxcbn0gZnJvbSBcImF4aW9zXCI7XG5pbXBvcnQgYXhpb3NSZXRyeSBmcm9tIFwiYXhpb3MtcmV0cnlcIjtcbmltcG9ydCBEZWJ1ZyBmcm9tIFwiZGVidWdcIjtcbmltcG9ydCBfIGZyb20gXCJsb2Rhc2hcIjtcbmltcG9ydCBwcmV0dHlNaWxsaXNlY29uZHMgZnJvbSBcInByZXR0eS1tc1wiO1xuaW1wb3J0IHsgZ2V0Q3VycmVudHNDb25maWcgfSBmcm9tIFwiLi4vY29uZmlnXCI7XG5pbXBvcnQgeyBWYWxpZGF0aW9uRXJyb3IgfSBmcm9tIFwiLi4vZXJyb3JzXCI7XG5pbXBvcnQgeyB3YXJuIH0gZnJvbSBcIi4uL2xvZ1wiO1xuaW1wb3J0IHsgZ2V0QVBJQmFzZVVybCwgZ2V0RGVsYXksIGlzUmV0cmlhYmxlRXJyb3IgfSBmcm9tIFwiLi9jb25maWdcIjtcbmltcG9ydCB7IG1heWJlUHJpbnRFcnJvcnMgfSBmcm9tIFwiLi9wcmludEVycm9yc1wiO1xuXG5jb25zdCBkZWJ1ZyA9IERlYnVnKFwiY3VycmVudHM6YXBpXCIpO1xuXG5jb25zdCBNQVhfUkVUUklFUyA9IDM7XG5jb25zdCBUSU1FT1VUX01TID0gMzAgKiAxMDAwO1xubGV0IF9jbGllbnQ6IEF4aW9zSW5zdGFuY2UgfCBudWxsID0gbnVsbDtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENsaWVudCgpIHtcbiAgaWYgKF9jbGllbnQpIHtcbiAgICByZXR1cm4gX2NsaWVudDtcbiAgfVxuICBjb25zdCBjdXJyZW50c0NvbmZpZyA9IGF3YWl0IGdldEN1cnJlbnRzQ29uZmlnKCk7XG4gIF9jbGllbnQgPSBheGlvcy5jcmVhdGUoe1xuICAgIGJhc2VVUkw6IGdldEFQSUJhc2VVcmwoKSxcbiAgICB0aW1lb3V0OiBUSU1FT1VUX01TLFxuICB9KTtcblxuICBfY2xpZW50LmludGVyY2VwdG9ycy5yZXF1ZXN0LnVzZSgoY29uZmlnKSA9PiB7XG4gICAgY29uc3QgY2N5VmVyc29uID0gX2N1cnJlbnRzVmVyc2lvbiA/PyBcIjAuMC4wXCI7XG4gICAgY29uc3QgaGVhZGVyczogUmF3QXhpb3NSZXF1ZXN0SGVhZGVycyA9IHtcbiAgICAgIC4uLmNvbmZpZy5oZWFkZXJzLFxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgXCJ4LWN5cHJlc3MtcmVxdWVzdC1hdHRlbXB0XCI6IGNvbmZpZ1tcImF4aW9zLXJldHJ5XCJdPy5yZXRyeUNvdW50ID8/IDAsXG4gICAgICBcIngtY3lwcmVzcy12ZXJzaW9uXCI6IF9jeXByZXNzVmVyc2lvbiA/PyBcIjAuMC4wXCIsXG4gICAgICBcIngtY2N5LXZlcnNpb25cIjogY2N5VmVyc29uLFxuICAgICAgXCJVc2VyLUFnZW50XCI6IGBjeXByZXNzLWNsb3VkLyR7Y2N5VmVyc29ufWAsXG4gICAgfTtcbiAgICBpZiAoX3J1bklkKSB7XG4gICAgICBoZWFkZXJzW1wieC1jeXByZXNzLXJ1bi1pZFwiXSA9IF9ydW5JZDtcbiAgICB9XG4gICAgaWYgKCFoZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdKSB7XG4gICAgICBoZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdID0gXCJhcHBsaWNhdGlvbi9qc29uXCI7XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnRzQ29uZmlnLm5ldHdvcmtIZWFkZXJzKSB7XG4gICAgICBjb25zdCBmaWx0ZXJlZEhlYWRlcnMgPSBfLm9taXQoY3VycmVudHNDb25maWcubmV0d29ya0hlYWRlcnMsIFtcbiAgICAgICAgXCJ4LWN5cHJlc3MtcmVxdWVzdC1hdHRlbXB0XCIsXG4gICAgICAgIFwieC1jeXByZXNzLXZlcnNpb25cIixcbiAgICAgICAgXCJ4LWNjeS12ZXJzaW9uXCIsXG4gICAgICAgIFwieC1jeXByZXNzLXJ1bi1pZFwiLFxuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiLFxuICAgICAgXSk7XG4gICAgICBkZWJ1ZyhcInVzaW5nIGN1c3RvbSBuZXR3b3JrIGhlYWRlcnM6ICVvXCIsIGZpbHRlcmVkSGVhZGVycyk7XG4gICAgICBPYmplY3QuYXNzaWduKGhlYWRlcnMsIGZpbHRlcmVkSGVhZGVycyk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVxID0ge1xuICAgICAgLi4uY29uZmlnLFxuICAgICAgaGVhZGVycyxcbiAgICB9O1xuXG4gICAgZGVidWcoXCJuZXR3b3JrIHJlcXVlc3Q6ICVvXCIsIHtcbiAgICAgIC4uLl8ucGljayhyZXEsIFwibWV0aG9kXCIsIFwidXJsXCIsIFwiaGVhZGVyc1wiKSxcbiAgICAgIGRhdGE6IEJ1ZmZlci5pc0J1ZmZlcihyZXEuZGF0YSkgPyBcImJ1ZmZlclwiIDogcmVxLmRhdGEsXG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVxO1xuICB9KTtcblxuICBheGlvc1JldHJ5KF9jbGllbnQsIHtcbiAgICByZXRyaWVzOiBNQVhfUkVUUklFUyxcbiAgICByZXRyeUNvbmRpdGlvbjogaXNSZXRyaWFibGVFcnJvcixcbiAgICByZXRyeURlbGF5OiBnZXREZWxheSxcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgb25SZXRyeSxcbiAgICBzaG91bGRSZXNldFRpbWVvdXQ6IHRydWUsXG4gIH0pO1xuICByZXR1cm4gX2NsaWVudDtcbn1cblxubGV0IF9ydW5JZDogc3RyaW5nIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuZXhwb3J0IGNvbnN0IHNldFJ1bklkID0gKHJ1bklkOiBzdHJpbmcpID0+IHtcbiAgX3J1bklkID0gcnVuSWQ7XG59O1xuXG5sZXQgX2N5cHJlc3NWZXJzaW9uOiBzdHJpbmcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5leHBvcnQgY29uc3Qgc2V0Q3lwcmVzc1ZlcnNpb24gPSAoY3lwcmVzc1ZlcnNpb246IHN0cmluZykgPT4ge1xuICBfY3lwcmVzc1ZlcnNpb24gPSBjeXByZXNzVmVyc2lvbjtcbn07XG5cbmxldCBfY3VycmVudHNWZXJzaW9uOiBzdHJpbmcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5leHBvcnQgY29uc3Qgc2V0Q3VycmVudHNWZXJzaW9uID0gKHY6IHN0cmluZykgPT4ge1xuICBfY3VycmVudHNWZXJzaW9uID0gdjtcbn07XG5cbmZ1bmN0aW9uIG9uUmV0cnkoXG4gIHJldHJ5Q291bnQ6IG51bWJlcixcbiAgZXJyOiBBeGlvc0Vycm9yPHsgbWVzc2FnZTogc3RyaW5nOyBlcnJvcnM/OiBzdHJpbmdbXSB9PixcbiAgY29uZmlnOiBBeGlvc1JlcXVlc3RDb25maWdcbikge1xuICB3YXJuKFxuICAgIFwiTmV0d29yayByZXF1ZXN0ICclcycgZmFpbGVkOiAnJXMnLiBOZXh0IGF0dGVtcHQgaXMgaW4gJXMgKCVkLyVkKS5cIixcbiAgICBgJHtjb25maWcubWV0aG9kfSAke2NvbmZpZy51cmx9YCxcbiAgICBlcnIubWVzc2FnZSxcbiAgICBwcmV0dHlNaWxsaXNlY29uZHMoZ2V0RGVsYXkocmV0cnlDb3VudCkpLFxuICAgIHJldHJ5Q291bnQsXG4gICAgTUFYX1JFVFJJRVNcbiAgKTtcbn1cblxuZXhwb3J0IGNvbnN0IG1ha2VSZXF1ZXN0ID0gYXN5bmMgPFQgPSBhbnksIEQgPSBhbnk+KFxuICBjb25maWc6IEF4aW9zUmVxdWVzdENvbmZpZzxEPlxuKSA9PiB7XG4gIHJldHVybiAoYXdhaXQgZ2V0Q2xpZW50KCkpPEQsIEF4aW9zUmVzcG9uc2U8VD4+KGNvbmZpZylcbiAgICAudGhlbigocmVzKSA9PiB7XG4gICAgICBkZWJ1ZyhcIm5ldHdvcmsgcmVzcG9uc2U6ICVvXCIsIF8ub21pdChyZXMsIFwicmVxdWVzdFwiLCBcImNvbmZpZ1wiKSk7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0pXG4gICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgbWF5YmVQcmludEVycm9ycyhlcnJvcik7XG4gICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgIH0pO1xufTtcbiIsICJpbXBvcnQgRGVidWcgZnJvbSBcImRlYnVnXCI7XG5cbmltcG9ydCB7IFAsIG1hdGNoIH0gZnJvbSBcInRzLXBhdHRlcm5cIjtcbmltcG9ydCB7IERldGVjdGVkQnJvd3NlciwgVmFsaWRhdGVkQ3VycmVudHNQYXJhbWV0ZXJzIH0gZnJvbSBcIi4uLy4uL3R5cGVzXCI7XG5pbXBvcnQgeyBib290Q3lwcmVzcyB9IGZyb20gXCIuLi9ib290c3RyYXBcIjtcbmltcG9ydCB7IGluZm8sIHdhcm4gfSBmcm9tIFwiLi4vbG9nXCI7XG5pbXBvcnQgeyBnZXRDb25maWdGaWxlUGF0aCB9IGZyb20gXCIuL3BhdGhcIjtcblxuY29uc3QgZGVidWcgPSBEZWJ1ZyhcImN1cnJlbnRzOmNvbmZpZ1wiKTtcblxuZXhwb3J0IHR5cGUgRTJFQ29uZmlnID0ge1xuICBiYXRjaFNpemU6IG51bWJlcjtcbn07XG5leHBvcnQgdHlwZSBDb21wb25lbnRDb25maWcgPSB7XG4gIGJhdGNoU2l6ZTogbnVtYmVyO1xufTtcbmV4cG9ydCB0eXBlIEN1cnJlbnRzQ29uZmlnID0ge1xuICBwcm9qZWN0SWQ/OiBzdHJpbmc7XG4gIHJlY29yZEtleT86IHN0cmluZztcbiAgY2xvdWRTZXJ2aWNlVXJsOiBzdHJpbmc7XG4gIGUyZTogRTJFQ29uZmlnO1xuICBjb21wb25lbnQ6IENvbXBvbmVudENvbmZpZztcbiAgbmV0d29ya0hlYWRlcnM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xufTtcblxubGV0IF9jb25maWc6IEN1cnJlbnRzQ29uZmlnIHwgbnVsbCA9IG51bGw7XG5cbmNvbnN0IGRlZmF1bHRDb25maWc6IEN1cnJlbnRzQ29uZmlnID0ge1xuICBlMmU6IHtcbiAgICBiYXRjaFNpemU6IDMsXG4gIH0sXG4gIGNvbXBvbmVudDoge1xuICAgIGJhdGNoU2l6ZTogNSxcbiAgfSxcbiAgY2xvdWRTZXJ2aWNlVXJsOiBcImh0dHBzOi8vY3kuY3VycmVudHMuZGV2XCIsXG4gIG5ldHdvcmtIZWFkZXJzOiB1bmRlZmluZWQsXG59O1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q3VycmVudHNDb25maWcoXG4gIHByb2plY3RSb290Pzogc3RyaW5nLFxuICBleHBsaWNpdENvbmZpZ0ZpbGVQYXRoPzogc3RyaW5nXG4pOiBQcm9taXNlPEN1cnJlbnRzQ29uZmlnPiB7XG4gIGlmIChfY29uZmlnKSB7XG4gICAgcmV0dXJuIF9jb25maWc7XG4gIH1cblxuICBjb25zdCBjb25maWdGaWxlUGF0aCA9IGdldENvbmZpZ0ZpbGVQYXRoKHByb2plY3RSb290LCBleHBsaWNpdENvbmZpZ0ZpbGVQYXRoKTtcbiAgLy8gdHJ5IGxvYWRpbmcgcG9zc2libGUgY29uZmlnIGZpbGVzXG4gIGZvciAoY29uc3QgZmlsZXBhdGggb2YgY29uZmlnRmlsZVBhdGgpIHtcbiAgICBjb25zdCBjb25maWcgPSBtYXRjaChhd2FpdCBsb2FkQ29uZmlnRmlsZShmaWxlcGF0aCkpXG4gICAgICAud2l0aCh7IGRlZmF1bHQ6IFAubm90KFAubnVsbGlzaCkgfSwgKGMpID0+IGMuZGVmYXVsdClcbiAgICAgIC53aXRoKFAubm90KFAubnVsbGlzaCksIChjKSA9PiBjKVxuICAgICAgLm90aGVyd2lzZSgoKSA9PiBudWxsKTtcblxuICAgIGlmIChjb25maWcpIHtcbiAgICAgIGRlYnVnKFwibG9hZGVkIGN1cnJlbnRzIGNvbmZpZyBmcm9tICclcydcXG4lT1wiLCBmaWxlcGF0aCwgY29uZmlnKTtcbiAgICAgIGluZm8oXCJVc2luZyBjb25maWcgZmlsZTogJyVzJ1wiLCBmaWxlcGF0aCk7XG4gICAgICBfY29uZmlnID0ge1xuICAgICAgICAuLi5kZWZhdWx0Q29uZmlnLFxuICAgICAgICAuLi5jb25maWcsXG4gICAgICB9O1xuICAgICAgcmV0dXJuIF9jb25maWc7XG4gICAgfVxuICB9XG5cbiAgd2FybihcbiAgICBcIkZhaWxlZCB0byBsb2FkIGNvbmZpZyBmaWxlLCBmYWxsaW5nIGJhY2sgdG8gdGhlIGRlZmF1bHQgY29uZmlnLiBBdHRlbXB0ZWQgbG9jYXRpb25zOiAlc1wiLFxuICAgIGNvbmZpZ0ZpbGVQYXRoXG4gICk7XG4gIF9jb25maWcgPSBkZWZhdWx0Q29uZmlnO1xuICByZXR1cm4gX2NvbmZpZztcbn1cblxuYXN5bmMgZnVuY3Rpb24gbG9hZENvbmZpZ0ZpbGUoZmlsZXBhdGg6IHN0cmluZykge1xuICB0cnkge1xuICAgIGRlYnVnKFwibG9hZGluZyBjdXJyZW50cyBjb25maWcgZmlsZSBmcm9tICclcydcIiwgZmlsZXBhdGgpO1xuICAgIHJldHVybiBhd2FpdCBpbXBvcnQoZmlsZXBhdGgpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgZGVidWcoXCJmYWlsZWQgbG9hZGluZyBjb25maWcgZmlsZSBmcm9tOiAlc1wiLCBlKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgdHlwZSBNZXJnZWRDb25maWcgPSBBd2FpdGVkPFJldHVyblR5cGU8dHlwZW9mIGdldE1lcmdlZENvbmZpZz4+O1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldE1lcmdlZENvbmZpZyhwYXJhbXM6IFZhbGlkYXRlZEN1cnJlbnRzUGFyYW1ldGVycykge1xuICBkZWJ1ZyhcInJlc29sdmluZyBjeXByZXNzIGNvbmZpZ1wiKTtcbiAgY29uc3QgY3lwcmVzc1Jlc29sdmVkQ29uZmlnOlxuICAgIHwgKEN5cHJlc3MuUmVzb2x2ZWRDb25maWdPcHRpb25zICYge1xuICAgICAgICBwcm9qZWN0Um9vdDogc3RyaW5nO1xuICAgICAgICByYXdKc29uOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcbiAgICAgICAgYnJvd3NlcnM6IERldGVjdGVkQnJvd3NlcltdO1xuICAgICAgfSlcbiAgICB8IHVuZGVmaW5lZCA9IGF3YWl0IGJvb3RDeXByZXNzKHBhcmFtcyk7XG5cbiAgZGVidWcoXCJjeXByZXNzIHJlc29sdmVkQ29uZmlnOiAlT1wiLCBjeXByZXNzUmVzb2x2ZWRDb25maWcpO1xuXG4gIC8vIEB0cy1pZ25vcmVcbiAgY29uc3QgcmF3RTJFUGF0dGVybiA9IGN5cHJlc3NSZXNvbHZlZENvbmZpZy5yYXdKc29uPy5lMmU/LnNwZWNQYXR0ZXJuO1xuICBsZXQgYWRkaXRpb25hbElnbm9yZVBhdHRlcm46IHN0cmluZ1tdID0gW107XG4gIGlmIChwYXJhbXMudGVzdGluZ1R5cGUgPT09IFwiY29tcG9uZW50XCIgJiYgcmF3RTJFUGF0dGVybikge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBhZGRpdGlvbmFsSWdub3JlUGF0dGVybiA9IHJhd0UyRVBhdHRlcm47XG4gIH1cblxuICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2N5cHJlc3MtaW8vY3lwcmVzcy9ibG9iL2VkMDY2OGUyNGMyZWU2NzUzYmJkMjVhZTQ2N2NlOTRhZTU4NTc3NDEvcGFja2FnZXMvY29uZmlnL3NyYy9vcHRpb25zLnRzI0w0NTdcbiAgLy8gYW5kIGh0dHBzOi8vZ2l0aHViLmNvbS9jeXByZXNzLWlvL2N5cHJlc3MvYmxvYi9kZXZlbG9wL3BhY2thZ2VzL2NvbmZpZy9zcmMvcHJvamVjdC91dGlscy50cyNMNDEyXG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICBwcm9qZWN0Um9vdDogY3lwcmVzc1Jlc29sdmVkQ29uZmlnPy5wcm9qZWN0Um9vdCB8fCBwcm9jZXNzLmN3ZCgpLFxuICAgIHByb2plY3RJZDogcGFyYW1zLnByb2plY3RJZCxcbiAgICBzcGVjUGF0dGVybjogY3lwcmVzc1Jlc29sdmVkQ29uZmlnPy5zcGVjUGF0dGVybiB8fCBcIioqLyouKlwiLFxuICAgIGV4Y2x1ZGVTcGVjUGF0dGVybjpcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGN5cHJlc3NSZXNvbHZlZENvbmZpZz8ucmVzb2x2ZWQuZXhjbHVkZVNwZWNQYXR0ZXJuLnZhbHVlID8/IFtdLFxuICAgIGFkZGl0aW9uYWxJZ25vcmVQYXR0ZXJuLFxuICAgIHJlc29sdmVkOiBjeXByZXNzUmVzb2x2ZWRDb25maWcsXG4gIH07XG4gIGRlYnVnKFwibWVyZ2VkIGNvbmZpZzogJU9cIiwgcmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbiIsICJpbXBvcnQgeyBnZXRCaW5QYXRoIH0gZnJvbSBcImN5MlwiO1xuaW1wb3J0IHsgVmFsaWRhdGVkQ3VycmVudHNQYXJhbWV0ZXJzIH0gZnJvbSBcImN5cHJlc3MtY2xvdWQvdHlwZXNcIjtcbmltcG9ydCBEZWJ1ZyBmcm9tIFwiZGVidWdcIjtcbmltcG9ydCBleGVjYSwgeyBFeGVjYUVycm9yIH0gZnJvbSBcImV4ZWNhXCI7XG5pbXBvcnQgZnMgZnJvbSBcImZzXCI7XG5pbXBvcnQgeyBWYWxpZGF0aW9uRXJyb3IgfSBmcm9tIFwiLi4vZXJyb3JzXCI7XG5pbXBvcnQgeyBjcmVhdGVUZW1wRmlsZSB9IGZyb20gXCIuLi9mc1wiO1xuaW1wb3J0IHsgYm9sZCwgaW5mbyB9IGZyb20gXCIuLi9sb2dcIjtcbmltcG9ydCB7IHJlcXVpcmUgfSBmcm9tIFwiLi4vcmVxdWlyZVwiO1xuaW1wb3J0IHsgZ2V0Qm9vdHN0cmFwQXJncyB9IGZyb20gXCIuL3NlcmlhbGl6ZXJcIjtcblxuY29uc3QgZGVidWcgPSBEZWJ1ZyhcImN1cnJlbnRzOmJvb3RcIik7XG5cbmV4cG9ydCBjb25zdCBib290Q3lwcmVzcyA9IGFzeW5jIChwYXJhbXM6IFZhbGlkYXRlZEN1cnJlbnRzUGFyYW1ldGVycykgPT4ge1xuICBkZWJ1ZyhcImJvb3RpbmcgY3lwcmVzcy4uLlwiKTtcbiAgY29uc3QgdGVtcEZpbGVQYXRoID0gYXdhaXQgY3JlYXRlVGVtcEZpbGUoKTtcblxuICBjb25zdCBjeXByZXNzQmluID0gYXdhaXQgZ2V0QmluUGF0aChyZXF1aXJlLnJlc29sdmUoXCJjeXByZXNzXCIpKTtcbiAgZGVidWcoXCJjeXByZXNzIGV4ZWN1dGFibGUgbG9jYXRpb246ICVzXCIsIGN5cHJlc3NCaW4pO1xuXG4gIC8vIGl0IGlzIGltcG9ydGFudCB0byBwYXNzIHRoZSBzYW1lIGFyZ3MgaW4gb3JkZXIgdG8gZ2V0IHRoZSBzYW1lIGNvbmZpZyBhcyBmb3IgdGhlIGFjdHVhbCBydW5cbiAgY29uc3QgYXJncyA9IGdldEJvb3RzdHJhcEFyZ3MoeyB0ZW1wRmlsZVBhdGgsIHBhcmFtcyB9KTtcbiAgZGVidWcoXCJib290aW5nIGN5cHJlc3Mgd2l0aCBhcmdzOiAlb1wiLCBhcmdzKTtcbiAgY29uc3QgeyBzdGRvdXQsIHN0ZGVyciB9ID0gYXdhaXQgZXhlY0N5cHJlc3MoY3lwcmVzc0JpbiwgYXJncyk7XG5cbiAgaWYgKCFmcy5leGlzdHNTeW5jKHRlbXBGaWxlUGF0aCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgQ2Fubm90IHJlc29sdmUgY3lwcmVzcyBjb25maWd1cmF0aW9uIGZyb20gJHt0ZW1wRmlsZVBhdGh9LiBQbGVhc2UgcmVwb3J0IHRoZSBpc3N1ZS5gXG4gICAgKTtcbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IGYgPSBmcy5yZWFkRmlsZVN5bmModGVtcEZpbGVQYXRoLCBcInV0Zi04XCIpO1xuICAgIGlmICghZikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSXMgY3lwcmVzcy1jbG91ZC9wbHVnaW4gaW5zdGFsbGVkP1wiKTtcbiAgICB9XG4gICAgZGVidWcoXCJjeXByZXNzIGNvbmZpZyAnJXMnOiAnJXMnXCIsIHRlbXBGaWxlUGF0aCwgZik7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoZik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGRlYnVnKFwicmVhZCBjb25maWcgdGVtcCBmaWxlIGZhaWxlZDogJW9cIiwgZXJyKTtcbiAgICBpbmZvKGJvbGQoXCJDeXByZXNzIHN0ZG91dDpcXG5cIiksIHN0ZG91dCk7XG4gICAgaW5mbyhib2xkKFwiQ3lwcmVzcyBzdGRlcnI6XFxuXCIpLCBzdGRlcnIpO1xuXG4gICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihgVW5hYmxlIHRvIHJlc29sdmUgY3lwcmVzcyBjb25maWd1cmF0aW9uXG4tIG1ha2Ugc3VyZSB0aGF0ICdjeXByZXNzLWNsb3VkL3BsdWdpbicgaXMgaW5zdGFsbGVkXG4tIHJlcG9ydCB0aGUgaXNzdWUgdG9nZXRoZXIgd2l0aCBjeXByZXNzIHN0ZG91dCBhbmQgc3RkZXJyXG5gKTtcbiAgfVxufTtcblxuYXN5bmMgZnVuY3Rpb24gZXhlY0N5cHJlc3MoY3lwcmVzc0Jpbjogc3RyaW5nLCBhcmdzOiByZWFkb25seSBzdHJpbmdbXSkge1xuICBsZXQgc3Rkb3V0ID0gXCJcIjtcbiAgbGV0IHN0ZGVyciA9IFwiXCI7XG4gIHRyeSB7XG4gICAgYXdhaXQgZXhlY2EoY3lwcmVzc0JpbiwgW1wicnVuXCIsIC4uLmFyZ3NdLCB7XG4gICAgICBzdGRpbzogXCJwaXBlXCIsXG4gICAgICBlbnY6IHtcbiAgICAgICAgLi4ucHJvY2Vzcy5lbnYsXG4gICAgICAgIC8vIHByZXZlbnQgd2FybmluZ3MgYWJvdXQgcmVjb3JkaW5nIG1vZGVcbiAgICAgICAgQ1lQUkVTU19SRUNPUkRfS0VZOiB1bmRlZmluZWQsXG4gICAgICAgIENZUFJFU1NfUFJPSkVDVF9JRDogdW5kZWZpbmVkLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZGVidWcoXCJleGVjIGN5cHJlc3MgZmFpbGVkIChjZXJ0YWluIGZhaWx1cmVzIGFyZSBleHBlY3RlZCk6ICVvXCIsIGVycik7XG4gICAgc3Rkb3V0ID0gKGVyciBhcyBFeGVjYUVycm9yKS5zdGRvdXQ7XG4gICAgc3RkZXJyID0gKGVyciBhcyBFeGVjYUVycm9yKS5zdGRlcnI7XG4gIH1cbiAgcmV0dXJuIHsgc3Rkb3V0LCBzdGRlcnIgfTtcbn1cbiIsICJleHBvcnQgY2xhc3MgVmFsaWRhdGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSBcIlwiO1xuICB9XG59XG4iLCAiaW1wb3J0IHsgZmlsZSB9IGZyb20gXCJ0bXAtcHJvbWlzZVwiO1xuXG5leHBvcnQgY29uc3QgY3JlYXRlVGVtcEZpbGUgPSBhc3luYyAoKSA9PiB7XG4gIGNvbnN0IHsgcGF0aCB9ID0gYXdhaXQgZmlsZSgpO1xuICByZXR1cm4gcGF0aDtcbn07XG4iLCAiaW1wb3J0IGNoYWxrIGZyb20gXCJjaGFsa1wiO1xuaW1wb3J0IHV0aWwgZnJvbSBcInV0aWxcIjtcblxuY29uc3QgbG9nID0gKC4uLmFyZ3M6IHVua25vd25bXSkgPT4gY29uc29sZS5sb2codXRpbC5mb3JtYXQoLi4uYXJncykpO1xuXG5leHBvcnQgY29uc3QgaW5mbyA9IGxvZztcblxuZXhwb3J0IGNvbnN0IHdpdGhFcnJvciA9IChtc2c6IHN0cmluZykgPT5cbiAgY2hhbGsuYmdSZWQud2hpdGUoXCIgRVJST1IgXCIpICsgXCIgXCIgKyBtc2c7XG5leHBvcnQgY29uc3Qgd2l0aFdhcm5pbmcgPSAobXNnOiBzdHJpbmcpID0+XG4gIGNoYWxrLmJnWWVsbG93LmJsYWNrKFwiIFdBUk5JTkcgXCIpICsgXCIgXCIgKyBtc2c7XG5cbmV4cG9ydCBjb25zdCB3YXJuID0gKC4uLmFyZ3M6IHVua25vd25bXSkgPT5cbiAgbG9nKHdpdGhXYXJuaW5nKHV0aWwuZm9ybWF0KC4uLmFyZ3MpKSk7XG5cbmV4cG9ydCBjb25zdCBzdWNjZXNzID0gKC4uLmFyZ3M6IHVua25vd25bXSkgPT5cbiAgbG9nKGNoYWxrLmdyZWVuKHV0aWwuZm9ybWF0KC4uLmFyZ3MpKSk7XG5cbmV4cG9ydCBjb25zdCBlcnJvciA9ICguLi5hcmdzOiB1bmtub3duW10pID0+XG4gIGxvZyh3aXRoRXJyb3IodXRpbC5mb3JtYXQoLi4uYXJncykpICsgXCJcXG5cIik7XG5cbnR5cGUgQ29sb3IgPSBcInJlZFwiIHwgXCJncmVlblwiIHwgXCJ5ZWxsb3dcIiB8IFwiYmx1ZVwiIHwgXCJtYWdlbnRhXCIgfCBcImN5YW5cIiB8IFwid2hpdGVcIjtcbmV4cG9ydCBjb25zdCB0aXRsZSA9IChjb2xvcjogQ29sb3IsIC4uLmFyZ3M6IHVua25vd25bXSkgPT5cbiAgaW5mbyhcIlxcblwiICsgXCIgIFwiICsgY2hhbGtbY29sb3JdLmJvbGQodXRpbC5mb3JtYXQoLi4uYXJncykpICsgXCIgIFwiICsgXCJcXG5cIik7XG5cbmV4cG9ydCBjb25zdCBkaXZpZGVyID0gKCkgPT5cbiAgY29uc29sZS5sb2coXCJcXG5cIiArIGNoYWxrLmdyYXkoQXJyYXkoMTAwKS5maWxsKFwiPVwiKS5qb2luKFwiXCIpKSArIFwiXFxuXCIpO1xuXG5leHBvcnQgY29uc3Qgc3BhY2VyID0gKG46IG51bWJlciA9IDApID0+XG4gIGNvbnNvbGUubG9nKEFycmF5KG4pLmZpbGwoXCJcIikuam9pbihcIlxcblwiKSk7XG5cbmV4cG9ydCBjb25zdCBjeWFuID0gY2hhbGsuY3lhbjtcbmV4cG9ydCBjb25zdCBibHVlID0gY2hhbGsuYmx1ZUJyaWdodDtcbmV4cG9ydCBjb25zdCByZWQgPSBjaGFsay5yZWQ7XG5leHBvcnQgY29uc3QgZ3JlZW4gPSBjaGFsay5ncmVlbkJyaWdodDtcbmV4cG9ydCBjb25zdCBncmF5ID0gY2hhbGsuZ3JheTtcbmV4cG9ydCBjb25zdCB3aGl0ZSA9IGNoYWxrLndoaXRlO1xuZXhwb3J0IGNvbnN0IG1hZ2VudGEgPSBjaGFsay5tYWdlbnRhO1xuZXhwb3J0IGNvbnN0IGJvbGQgPSBjaGFsay5ib2xkO1xuIiwgImltcG9ydCB7XG4gIEN1cnJlbnRzUnVuUGFyYW1ldGVycyxcbiAgQ3lwcmVzc1J1blBhcmFtZXRlcnMsXG59IGZyb20gXCJjeXByZXNzLWNsb3VkL3R5cGVzXCI7XG5pbXBvcnQgRGVidWcgZnJvbSBcImRlYnVnXCI7XG5pbXBvcnQgXyBmcm9tIFwibG9kYXNoXCI7XG5pbXBvcnQgeyBjdXN0b21BbHBoYWJldCB9IGZyb20gXCJuYW5vaWRcIjtcbmltcG9ydCB7IGdldEN5cHJlc3NSdW5BUElQYXJhbXMgfSBmcm9tIFwiLi4vY29uZmlnXCI7XG5jb25zdCBkZWJ1ZyA9IERlYnVnKFwiY3VycmVudHM6Ym9vdFwiKTtcblxuY29uc3QgZ2V0RHVtbXlTcGVjID0gY3VzdG9tQWxwaGFiZXQoXCJhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elwiLCAxMCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRCb290c3RyYXBBcmdzKHtcbiAgcGFyYW1zLFxuICB0ZW1wRmlsZVBhdGgsXG59OiB7XG4gIHBhcmFtczogQ3VycmVudHNSdW5QYXJhbWV0ZXJzO1xuICB0ZW1wRmlsZVBhdGg6IHN0cmluZztcbn0pIHtcbiAgcmV0dXJuIF8uY2hhaW4oZ2V0Q3lwcmVzc0NMSVBhcmFtcyhwYXJhbXMpKVxuICAgIC50aHJ1KChvcHRzKSA9PiAoe1xuICAgICAgLi4ub3B0cyxcbiAgICAgIC8vIG1lcmdlIHRoZSBlbnYgd2l0aCB0aGUgY3VycmVudHMgc3BlY2lmaWMgZW52IHZhcmlhYmxlc1xuICAgICAgZW52OiB7XG4gICAgICAgIC4uLihvcHRzLmVudiA/PyB7fSksXG4gICAgICAgIGN1cnJlbnRzX3RlbXBfZmlsZTogdGVtcEZpbGVQYXRoLFxuICAgICAgICBjdXJyZW50c19kZWJ1Z19lbmFibGVkOiBwcm9jZXNzLmVudi5ERUJVRz8uaW5jbHVkZXMoXCJjdXJyZW50czpcIilcbiAgICAgICAgICA/IHRydWVcbiAgICAgICAgICA6IGZhbHNlLFxuICAgICAgfSxcbiAgICB9KSlcbiAgICAudGFwKChvcHRzKSA9PiB7XG4gICAgICBkZWJ1ZyhcImN5cHJlc3MgYm9vdHN0cmFwIHBhcmFtczogJW9cIiwgb3B0cyk7XG4gICAgfSlcbiAgICAudGhydShzZXJpYWxpemVPcHRpb25zKVxuICAgIC50YXAoKG9wdHMpID0+IHtcbiAgICAgIGRlYnVnKFwiY3lwcmVzcyBib290c3RyYXAgc2VyaWFsaXplZCBwYXJhbXM6ICVvXCIsIG9wdHMpO1xuICAgIH0pXG4gICAgLnRocnUoKGFyZ3MpID0+IHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIC4uLmFyZ3MsXG4gICAgICAgIFwiLS1zcGVjXCIsXG4gICAgICAgIGdldER1bW15U3BlYygpLFxuICAgICAgICBwYXJhbXMudGVzdGluZ1R5cGUgPT09IFwiY29tcG9uZW50XCIgPyBcIi0tY29tcG9uZW50XCIgOiBcIi0tZTJlXCIsXG4gICAgICBdO1xuICAgIH0pXG4gICAgLnZhbHVlKCk7XG59XG5cbi8qKlxuICogQ29udmVydHMgQ3VycmVudHMgb3B0aW9ucyB0byBDeXByZXNzIENMSSBwYXJhbXMuXG4gKiBDeXByZXNzIENMSSBvcHRpb25zIGFyZSBkaWZmZXJlbnQgZnJvbSBDeXByZXNzIG1vZHVsZSBBUEkgb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0gcGFyYW1zIEN1cnJlbnRzIHBhcmFtXG4gKiBAcmV0dXJucyBDeXByZXNzIENMSSBwYXJhbXNcbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLmN5cHJlc3MuaW8vZ3VpZGVzL2d1aWRlcy9jb21tYW5kLWxpbmUjY3lwcmVzcy1ydW5cbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLmN5cHJlc3MuaW8vYXBpL21vZHVsZS1hcGlcbiAqL1xuZnVuY3Rpb24gZ2V0Q3lwcmVzc0NMSVBhcmFtcyhcbiAgcGFyYW1zOiBDdXJyZW50c1J1blBhcmFtZXRlcnNcbik6IEN5cHJlc3NSdW5QYXJhbWV0ZXJzIHtcbiAgY29uc3QgcmVzdWx0ID0gZ2V0Q3lwcmVzc1J1bkFQSVBhcmFtcyhwYXJhbXMpO1xuICBjb25zdCB0ZXN0aW5nVHlwZSA9XG4gICAgcmVzdWx0LnRlc3RpbmdUeXBlID09PSBcImNvbXBvbmVudFwiXG4gICAgICA/IHtcbiAgICAgICAgICBjb21wb25lbnQ6IHRydWUsXG4gICAgICAgIH1cbiAgICAgIDoge307XG4gIHJldHVybiB7XG4gICAgLi4uXy5vbWl0KHJlc3VsdCwgXCJ0ZXN0aW5nVHlwZVwiKSxcbiAgICAuLi50ZXN0aW5nVHlwZSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplT3B0aW9ucyhvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IHN0cmluZ1tdIHtcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKG9wdGlvbnMpLmZsYXRNYXAoKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGNvbnN0IF9rZXkgPSBkYXNoZWQoa2V5KTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSB0cnVlID8gW2AtLSR7X2tleX1gXSA6IFtgLS0ke19rZXl9YCwgZmFsc2VdO1xuICAgIH1cblxuICAgIGlmIChfLmlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIFtgLS0ke19rZXl9YCwgc2VyaWFsaXplQ29tcGxleFBhcmFtKHZhbHVlKV07XG4gICAgfVxuXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJldHVybiBbYC0tJHtfa2V5fWAsIHZhbHVlLnRvU3RyaW5nKCldO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplQ29tcGxleFBhcmFtKHBhcmFtOiB7fSkge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocGFyYW0pO1xufVxuXG5jb25zdCBkYXNoZWQgPSAodjogc3RyaW5nKSA9PiB2LnJlcGxhY2UoL1tBLVpdL2csIChtKSA9PiBcIi1cIiArIG0udG9Mb3dlckNhc2UoKSk7XG4iLCAiaW1wb3J0IGlzQWJzb2x1dGUgZnJvbSBcImlzLWFic29sdXRlXCI7XG5pbXBvcnQgXyBmcm9tIFwibG9kYXNoXCI7XG5pbXBvcnQgcGF0aCBmcm9tIFwicGF0aFwiO1xuXG5leHBvcnQgY29uc3QgZGVmYXVsdEZpbGVuYW1lcyA9IFtcbiAgXCJjdXJyZW50cy5jb25maWcuanNcIixcbiAgXCJjdXJyZW50cy5jb25maWcuY2pzXCIsXG4gIFwiY3VycmVudHMuY29uZmlnLm1qc1wiLFxuXTtcbmV4cG9ydCBmdW5jdGlvbiBnZXRDb25maWdGaWxlUGF0aChcbiAgcHJvamVjdFJvb3Q6IHN0cmluZyB8IG51bGwgPSBudWxsLFxuICBleHBsaWNpdENvbmZpZ0ZpbGVQYXRoPzogc3RyaW5nXG4pOiBzdHJpbmdbXSB7XG4gIGNvbnN0IHByZWZpeCA9IHByb2plY3RSb290ID8/IHByb2Nlc3MuY3dkKCk7XG4gIGlmIChcbiAgICBfLmlzU3RyaW5nKGV4cGxpY2l0Q29uZmlnRmlsZVBhdGgpICYmXG4gICAgaXNBYnNvbHV0ZShleHBsaWNpdENvbmZpZ0ZpbGVQYXRoKVxuICApIHtcbiAgICByZXR1cm4gW2V4cGxpY2l0Q29uZmlnRmlsZVBhdGhdO1xuICB9XG4gIGlmIChfLmlzU3RyaW5nKGV4cGxpY2l0Q29uZmlnRmlsZVBhdGgpKSB7XG4gICAgcmV0dXJuIFtub3JtYWxpemVQYXRoKHByZWZpeCwgZXhwbGljaXRDb25maWdGaWxlUGF0aCldO1xuICB9XG5cbiAgcmV0dXJuIGRlZmF1bHRGaWxlbmFtZXMubWFwKChwKSA9PiBub3JtYWxpemVQYXRoKHByZWZpeCwgcCkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplUGF0aChwcmVmaXg6IHN0cmluZywgZmlsZW5hbWU6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBgZmlsZTovLyR7cGF0aC5yZXNvbHZlKHByZWZpeCwgZmlsZW5hbWUpfWA7XG59XG4iLCAiaW1wb3J0IHtcbiAgQ3VycmVudHNSdW5QYXJhbWV0ZXJzLFxuICBDeXByZXNzUnVuUGFyYW1ldGVycyxcbiAgVmFsaWRhdGVkQ3VycmVudHNQYXJhbWV0ZXJzLFxufSBmcm9tIFwiY3lwcmVzcy1jbG91ZC90eXBlc1wiO1xuaW1wb3J0IERlYnVnIGZyb20gXCJkZWJ1Z1wiO1xuaW1wb3J0IF8gZnJvbSBcImxvZGFzaFwiO1xuaW1wb3J0IHsgVmFsaWRhdGlvbkVycm9yIH0gZnJvbSBcIi4uL2Vycm9yc1wiO1xuaW1wb3J0IHsgZXJyb3IgfSBmcm9tIFwiLi4vbG9nXCI7XG5pbXBvcnQgeyBnZXRDdXJyZW50c0NvbmZpZyB9IGZyb20gXCIuL2NvbmZpZ1wiO1xuY29uc3QgZGVidWcgPSBEZWJ1ZyhcImN1cnJlbnRzOnZhbGlkYXRlUGFyYW1zXCIpO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZUN1cnJlbnRzUGFyYW1zKFxuICBwYXJhbXM6IEN1cnJlbnRzUnVuUGFyYW1ldGVyc1xuKTogUHJvbWlzZTxDdXJyZW50c1J1blBhcmFtZXRlcnM+IHtcbiAgY29uc3QgY29uZmlnRnJvbUZpbGUgPSBhd2FpdCBnZXRDdXJyZW50c0NvbmZpZyhcbiAgICBwYXJhbXMucHJvamVjdCxcbiAgICBwYXJhbXMuY2xvdWRDb25maWdGaWxlXG4gICk7XG5cbiAgZGVidWcoXCJyZXNvbHZpbmcgY3VycmVudHMgcGFyYW1zOiAlb1wiLCBwYXJhbXMpO1xuICBkZWJ1ZyhcInJlc29sdmluZyBjdXJyZW50cyBjb25maWcgZmlsZTogJW9cIiwgY29uZmlnRnJvbUZpbGUpO1xuICBjb25zdCBjbG91ZFNlcnZpY2VVcmwgPVxuICAgIHBhcmFtcy5jbG91ZFNlcnZpY2VVcmwgPz9cbiAgICBwcm9jZXNzLmVudi5DVVJSRU5UU19BUElfVVJMID8/XG4gICAgY29uZmlnRnJvbUZpbGUuY2xvdWRTZXJ2aWNlVXJsO1xuXG4gIGNvbnN0IHJlY29yZEtleSA9XG4gICAgcGFyYW1zLnJlY29yZEtleSA/P1xuICAgIHByb2Nlc3MuZW52LkNVUlJFTlRTX1JFQ09SRF9LRVkgPz9cbiAgICBjb25maWdGcm9tRmlsZS5yZWNvcmRLZXk7XG5cbiAgY29uc3QgcHJvamVjdElkID1cbiAgICBwYXJhbXMucHJvamVjdElkID8/XG4gICAgcHJvY2Vzcy5lbnYuQ1VSUkVOVFNfUFJPSkVDVF9JRCA/P1xuICAgIGNvbmZpZ0Zyb21GaWxlLnByb2plY3RJZDtcblxuICBjb25zdCB0ZXN0aW5nVHlwZSA9IHBhcmFtcy50ZXN0aW5nVHlwZSA/PyBcImUyZVwiO1xuXG4gIGNvbnN0IGJhdGNoU2l6ZSA9XG4gICAgdGVzdGluZ1R5cGUgPT09IFwiZTJlXCJcbiAgICAgID8gY29uZmlnRnJvbUZpbGUuZTJlLmJhdGNoU2l6ZVxuICAgICAgOiBjb25maWdGcm9tRmlsZS5jb21wb25lbnQuYmF0Y2hTaXplO1xuXG4gIC8vIGJhdGNoU2l6ZSBhbmQgY2xvdWRTZXJ2aWNlVXJsIGRlZmF1bHRzIGFyZSBpbiBnZXRDdXJyZW50c0NvbmZpZygpXG4gIHJldHVybiB7XG4gICAgLi4ucGFyYW1zLFxuICAgIGNsb3VkU2VydmljZVVybCxcbiAgICByZWNvcmRLZXksXG4gICAgcHJvamVjdElkLFxuICAgIGJhdGNoU2l6ZSxcbiAgICB0ZXN0aW5nVHlwZSxcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IHByb2plY3RJZEVycm9yID0gYENhbm5vdCByZXNvbHZlIHByb2plY3RJZC4gUGxlYXNlIHVzZSBvbmUgb2YgdGhlIGZvbGxvd2luZzpcbi0gcHJvdmlkZSBpdCBhcyBhIFwicHJvamVjdElkXCIgcHJvcGVydHkgZm9yIFwicnVuXCIgQVBJIG1ldGhvZFxuLSBzZXQgQ1VSUkVOVFNfUFJPSkVDVF9JRCBlbnZpcm9ubWVudCB2YXJpYWJsZVxuLSBzZXQgXCJwcm9qZWN0SWRcIiBpbiBcImN1cnJlbnRzLmNvbmZpZy57Y31qc1wiIGZpbGVgO1xuXG5leHBvcnQgY29uc3QgY2xvdWRTZXJ2aWNlVXJsRXJyb3IgPSBgQ2Fubm90IHJlc29sdmUgY2xvdWQgc2VydmljZSBVUkwuIFBsZWFzZSB1c2Ugb25lIG9mIHRoZSBmb2xsb3dpbmc6XG4tIHByb3ZpZGUgaXQgYXMgYSBcImNsb3VkU2VydmljZVVybFwiIHByb3BlcnR5IGZvciBcInJ1blwiIEFQSSBtZXRob2Rcbi0gc2V0IENVUlJFTlRTX0FQSV9VUkwgZW52aXJvbm1lbnQgdmFyaWFibGVcbi0gc2V0IFwiY2xvdWRTZXJ2aWNlVXJsXCIgaW4gXCJjdXJyZW50cy5jb25maWcue2N9anNcIiBmaWxlYDtcblxuZXhwb3J0IGNvbnN0IGNsb3VkU2VydmljZUludmFsaWRVcmxFcnJvciA9IGBJbnZhbGlkIGNsb3VkIHNlcnZpY2UgVVJMIHByb3ZpZGVkYDtcblxuZXhwb3J0IGNvbnN0IHJlY29yZEtleUVycm9yID0gYENhbm5vdCByZXNvbHZlIHJlY29yZCBrZXkuIFBsZWFzZSB1c2Ugb25lIG9mIHRoZSBmb2xsb3dpbmc6XG5cbi0gcGFzcyBpdCBhcyBhIENMSSBmbGFnICctaywgLS1rZXkgPHJlY29yZC1rZXk+J1xuLSBwcm92aWRlIGl0IGFzIGEgXCJyZWNvcmRLZXlcIiBwcm9wZXJ0eSBmb3IgXCJydW5cIiBBUEkgbWV0aG9kXG4tIHNldCBDVVJSRU5UU19SRUNPUkRfS0VZIGVudmlyb25tZW50IHZhcmlhYmxlXG4tIHNldCBcInJlY29yZEtleVwiIGluIFwiY3VycmVudHMuY29uZmlnLntjfWpzXCIgZmlsZVxuYDtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHZhbGlkYXRlUGFyYW1zKFxuICBfcGFyYW1zOiBDdXJyZW50c1J1blBhcmFtZXRlcnNcbik6IFByb21pc2U8VmFsaWRhdGVkQ3VycmVudHNQYXJhbWV0ZXJzPiB7XG4gIGNvbnN0IHBhcmFtcyA9IGF3YWl0IHJlc29sdmVDdXJyZW50c1BhcmFtcyhfcGFyYW1zKTtcblxuICBkZWJ1ZyhcInZhbGlkYXRpbmcgY3VycmVudHMgcGFyYW1zOiAlb1wiLCBwYXJhbXMpO1xuICBpZiAoIXBhcmFtcy5jbG91ZFNlcnZpY2VVcmwpIHtcbiAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKGNsb3VkU2VydmljZVVybEVycm9yKTtcbiAgfVxuICBpZiAoIXBhcmFtcy5wcm9qZWN0SWQpIHtcbiAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKHByb2plY3RJZEVycm9yKTtcbiAgfVxuICBpZiAoIXBhcmFtcy5yZWNvcmRLZXkpIHtcbiAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKHJlY29yZEtleUVycm9yKTtcbiAgfVxuXG4gIHZhbGlkYXRlVVJMKHBhcmFtcy5jbG91ZFNlcnZpY2VVcmwpO1xuXG4gIGNvbnN0IHJlcXVpcmVkUGFyYW1ldGVyczogQXJyYXk8a2V5b2YgQ3VycmVudHNSdW5QYXJhbWV0ZXJzPiA9IFtcbiAgICBcInRlc3RpbmdUeXBlXCIsXG4gICAgXCJiYXRjaFNpemVcIixcbiAgICBcInByb2plY3RJZFwiLFxuICBdO1xuICByZXF1aXJlZFBhcmFtZXRlcnMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgaWYgKHR5cGVvZiBwYXJhbXNba2V5XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgZXJyb3IoJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyIFwiJXNcIicsIGtleSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlclwiKTtcbiAgICB9XG4gIH0pO1xuXG4gIHBhcmFtcy50YWcgPSBwYXJzZVRhZ3MocGFyYW1zLnRhZyk7XG4gIHBhcmFtcy5hdXRvQ2FuY2VsQWZ0ZXJGYWlsdXJlcyA9IGdldEF1dG9DYW5jZWxWYWx1ZShcbiAgICBwYXJhbXMuYXV0b0NhbmNlbEFmdGVyRmFpbHVyZXNcbiAgKTtcblxuICBkZWJ1ZyhcInZhbGlkYXRlZCBjdXJyZW50cyBwYXJhbXM6ICVvXCIsIHBhcmFtcyk7XG5cbiAgLy8gVE9ETzogcmVtb3ZlIHRoaXMgY2FzdCBhZnRlciBmaW5kaW5nIGEgd2F5IHRvIHByb3Blcmx5IHJlc29sdmUgcGFyYW1zIHR5cGUgYWZ0ZXIgdmFsaWRhdGlvbnNcbiAgcmV0dXJuIHBhcmFtcyBhcyBWYWxpZGF0ZWRDdXJyZW50c1BhcmFtZXRlcnM7XG59XG5cbmZ1bmN0aW9uIGdldEF1dG9DYW5jZWxWYWx1ZSh2YWx1ZTogdW5rbm93bik6IG51bWJlciB8IGZhbHNlIHwgdW5kZWZpbmVkIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICByZXR1cm4gdmFsdWUgPyAxIDogZmFsc2U7XG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiICYmIHZhbHVlID4gMCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoXG4gICAgYGF1dG9DYW5jZWxBZnRlckZhaWx1cmVzOiBzaG91bGQgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIG9yIFwiZmFsc2VcIi4gR290OiBcIiR7dmFsdWV9XCJgXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc09mZmxpbmUocGFyYW1zOiBDdXJyZW50c1J1blBhcmFtZXRlcnMpIHtcbiAgcmV0dXJuIHBhcmFtcy5yZWNvcmQgPT09IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBwYXJzZVRhZ3ModGFnU3RyaW5nOiBDdXJyZW50c1J1blBhcmFtZXRlcnNbXCJ0YWdcIl0pOiBzdHJpbmdbXSB7XG4gIGlmICghdGFnU3RyaW5nKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHRhZ1N0cmluZykpIHtcbiAgICByZXR1cm4gdGFnU3RyaW5nLmZpbHRlcihCb29sZWFuKTtcbiAgfVxuICByZXR1cm4gdGFnU3RyaW5nXG4gICAgLnNwbGl0KFwiLFwiKVxuICAgIC5tYXAoKHRhZykgPT4gdGFnLnRyaW0oKSlcbiAgICAuZmlsdGVyKEJvb2xlYW4pO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVVSTCh1cmw6IHN0cmluZyk6IHZvaWQge1xuICB0cnkge1xuICAgIG5ldyBVUkwodXJsKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihgJHtjbG91ZFNlcnZpY2VJbnZhbGlkVXJsRXJyb3J9OiBcIiR7dXJsfVwiYCk7XG4gIH1cbn1cblxuLyoqXG4gKlxuICogQHJldHVybnMgQ3lwcmVzcyBvcHRpb25zIHdpdGhvdXQgaXRlbXMgdGhhdCBhZmZlY3QgcmVjb3JkaW5nIG1vZGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEN5cHJlc3NSdW5BUElQYXJhbXMoXG4gIHBhcmFtczogQ3VycmVudHNSdW5QYXJhbWV0ZXJzXG4pOiBDeXByZXNzUnVuUGFyYW1ldGVycyB7XG4gIHJldHVybiB7XG4gICAgLi4uXy5waWNrQnkoXG4gICAgICBfLm9taXQocGFyYW1zLCBbXG4gICAgICAgIFwiY2xvdWREZWJ1Z1wiLFxuICAgICAgICBcImNsb3VkQ29uZmlnRmlsZVwiLFxuICAgICAgICBcImF1dG9DYW5jZWxBZnRlckZhaWx1cmVzXCIsXG4gICAgICAgIFwiY2xvdWRTZXJ2aWNlVXJsXCIsXG4gICAgICAgIFwiYmF0Y2hTaXplXCIsXG4gICAgICAgIFwicHJvamVjdElkXCIsXG4gICAgICAgIFwia2V5XCIsXG4gICAgICAgIFwicmVjb3JkS2V5XCIsXG4gICAgICAgIFwicmVjb3JkXCIsXG4gICAgICAgIFwiZ3JvdXBcIixcbiAgICAgICAgXCJwYXJhbGxlbFwiLFxuICAgICAgICBcInRhZ1wiLFxuICAgICAgICBcImNpQnVpbGRJZFwiLFxuICAgICAgICBcInNwZWNcIixcbiAgICAgICAgXCJleGl0XCIsXG4gICAgICAgIFwiaGVhZGxlc3NcIixcbiAgICAgIF0pLFxuICAgICAgQm9vbGVhblxuICAgICksXG4gICAgcmVjb3JkOiBmYWxzZSxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByZXByb2Nlc3NQYXJhbXMoXG4gIHBhcmFtczogQ3VycmVudHNSdW5QYXJhbWV0ZXJzXG4pOiBDdXJyZW50c1J1blBhcmFtZXRlcnMge1xuICByZXR1cm4ge1xuICAgIC4uLnBhcmFtcyxcbiAgICBzcGVjOiBwcm9jZXNzU3BlY1BhcmFtKHBhcmFtcy5zcGVjKSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1NwZWNQYXJhbShcbiAgc3BlYzogQ3VycmVudHNSdW5QYXJhbWV0ZXJzW1wic3BlY1wiXVxuKTogc3RyaW5nW10gfCB1bmRlZmluZWQge1xuICBpZiAoIXNwZWMpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoc3BlYykpIHtcbiAgICByZXR1cm4gXy5mbGF0dGVuKHNwZWMubWFwKChpKSA9PiBpLnNwbGl0KFwiLFwiKSkpO1xuICB9XG5cbiAgcmV0dXJuIHNwZWMuc3BsaXQoXCIsXCIpO1xufVxuIiwgImltcG9ydCB7IEF4aW9zRXJyb3IgfSBmcm9tIFwiYXhpb3NcIjtcbmltcG9ydCBfIGZyb20gXCJsb2Rhc2hcIjtcbmltcG9ydCB7IHNwYWNlciwgd2FybiB9IGZyb20gXCIuLi9sb2dcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIG1heWJlUHJpbnRFcnJvcnMoXG4gIGVycjogQXhpb3NFcnJvcjx7IG1lc3NhZ2U6IHN0cmluZzsgZXJyb3JzPzogc3RyaW5nW10gfT5cbikge1xuICBpZiAoIWVyci5yZXNwb25zZT8uZGF0YSB8fCAhZXJyLnJlc3BvbnNlPy5zdGF0dXMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCB7IG1lc3NhZ2UsIGVycm9ycyB9ID0gZXJyLnJlc3BvbnNlLmRhdGE7XG5cbiAgc3dpdGNoIChlcnIucmVzcG9uc2Uuc3RhdHVzKSB7XG4gICAgY2FzZSA0MDE6XG4gICAgICB3YXJuKFwiUmVjZWl2ZWQgNDAxIFVuYXV0aG9yaXplZFwiKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNDIyOlxuICAgICAgc3BhY2VyKDEpO1xuICAgICAgd2FybiguLi5mb3JtYXRHZW5lcmljRXJyb3IobWVzc2FnZSwgZXJyb3JzKSk7XG4gICAgICBzcGFjZXIoMSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWs7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdEdlbmVyaWNFcnJvcihcbiAgbWVzc2FnZT86IHN0cmluZyxcbiAgZXJyb3JzPzogc3RyaW5nW11cbik6IHN0cmluZ1tdIHtcbiAgaWYgKCFfLmlzU3RyaW5nKG1lc3NhZ2UpKSB7XG4gICAgcmV0dXJuIFtcIlVuZXhwZWN0ZWQgZXJyb3IgZnJvbSB0aGUgY2xvdWQgc2VydmljZVwiXTtcbiAgfVxuXG4gIGlmIChlcnJvcnM/Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBbbWVzc2FnZSBhcyBzdHJpbmddO1xuICB9XG4gIHJldHVybiBbXG4gICAgbWVzc2FnZSBhcyBzdHJpbmcsXG4gICAgYFxuJHsoZXJyb3JzID8/IFtdKS5tYXAoKGUpID0+IGAgIC0gJHtlfWApLmpvaW4oXCJcXG5cIil9XG5gLFxuICBdO1xufVxuIiwgImltcG9ydCB7IHJlcXVpcmUgfSBmcm9tIFwiLi4vbGliL3JlcXVpcmVcIjtcbmltcG9ydCBcIi4vc3Rkb3V0XCI7XG5pbXBvcnQgXCIuL3dzXCI7XG5cbmNvbnN0IGN5cHJlc3NQa2cgPSByZXF1aXJlKFwiY3lwcmVzcy9wYWNrYWdlLmpzb25cIik7XG5jb25zdCBwa2cgPSByZXF1aXJlKFwiY3lwcmVzcy1jbG91ZC9wYWNrYWdlLmpzb25cIik7XG5cbmltcG9ydCB7IGluaXRDYXB0dXJlIH0gZnJvbSBcIi4vY2FwdHVyZVwiO1xuaW1wb3J0IHsgc2V0Q3VycmVudHNWZXJzaW9uLCBzZXRDeXByZXNzVmVyc2lvbiB9IGZyb20gXCIuL2h0dHBDbGllbnRcIjtcblxuaW5pdENhcHR1cmUoKTtcbnNldEN5cHJlc3NWZXJzaW9uKGN5cHJlc3NQa2cudmVyc2lvbik7XG5zZXRDdXJyZW50c1ZlcnNpb24ocGtnLnZlcnNpb24pO1xuIiwgImltcG9ydCBcIi4vaW5pdFwiO1xuXG5pbXBvcnQgRGVidWcgZnJvbSBcImRlYnVnXCI7XG5pbXBvcnQgeyBnZXRMZWdhbE5vdGljZSB9IGZyb20gXCIuLi9sZWdhbFwiO1xuaW1wb3J0IHsgQ3VycmVudHNSdW5QYXJhbWV0ZXJzIH0gZnJvbSBcIi4uL3R5cGVzXCI7XG5pbXBvcnQgeyBjcmVhdGVSdW4gfSBmcm9tIFwiLi9hcGlcIjtcbmltcG9ydCB7IGN1dEluaXRpYWxPdXRwdXQsIGdldENhcHR1cmVkT3V0cHV0IH0gZnJvbSBcIi4vY2FwdHVyZVwiO1xuaW1wb3J0IHsgZ2V0Q0kgfSBmcm9tIFwiLi9jaVByb3ZpZGVyXCI7XG5pbXBvcnQge1xuICBnZXRNZXJnZWRDb25maWcsXG4gIGlzT2ZmbGluZSxcbiAgcHJlcHJvY2Vzc1BhcmFtcyxcbiAgdmFsaWRhdGVQYXJhbXMsXG59IGZyb20gXCIuL2NvbmZpZ1wiO1xuaW1wb3J0IHsgcnVuQmFyZUN5cHJlc3MgfSBmcm9tIFwiLi9jeXByZXNzXCI7XG5pbXBvcnQgeyBhY3RpdmF0ZURlYnVnIH0gZnJvbSBcIi4vZGVidWdcIjtcbmltcG9ydCB7IGlzQ3VycmVudHMgfSBmcm9tIFwiLi9lbnZcIjtcbmltcG9ydCB7IGdldEdpdEluZm8gfSBmcm9tIFwiLi9naXRcIjtcbmltcG9ydCB7IHNldEFQSUJhc2VVcmwsIHNldFJ1bklkIH0gZnJvbSBcIi4vaHR0cENsaWVudFwiO1xuaW1wb3J0IHsgYm9sZCwgZGl2aWRlciwgaW5mbywgc3BhY2VyLCB0aXRsZSB9IGZyb20gXCIuL2xvZ1wiO1xuaW1wb3J0IHsgZ2V0UGxhdGZvcm0gfSBmcm9tIFwiLi9wbGF0Zm9ybVwiO1xuaW1wb3J0IHsgcHVic3ViIH0gZnJvbSBcIi4vcHVic3ViXCI7XG5pbXBvcnQgeyBzdW1tYXJpemVUZXN0UmVzdWx0cywgc3VtbWFyeVRhYmxlIH0gZnJvbSBcIi4vcmVzdWx0c1wiO1xuaW1wb3J0IHtcbiAgY3JlYXRlUmVwb3J0VGFza1NwZWMsXG4gIHJlcG9ydFRhc2tzLFxuICBydW5UaWxsRG9uZU9yQ2FuY2VsbGVkLFxufSBmcm9tIFwiLi9ydW5uZXJcIjtcbmltcG9ydCB7IHNodXRkb3duIH0gZnJvbSBcIi4vc2h1dGRvd25cIjtcbmltcG9ydCB7IGdldFNwZWNGaWxlcyB9IGZyb20gXCIuL3NwZWNNYXRjaGVyXCI7XG5pbXBvcnQgeyBDb25maWdTdGF0ZSwgRXhlY3V0aW9uU3RhdGUgfSBmcm9tIFwiLi9zdGF0ZVwiO1xuaW1wb3J0IHsgc3RhcnRXU1MgfSBmcm9tIFwiLi93c1wiO1xuXG5jb25zdCBkZWJ1ZyA9IERlYnVnKFwiY3VycmVudHM6cnVuXCIpO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcnVuKHBhcmFtczogQ3VycmVudHNSdW5QYXJhbWV0ZXJzID0ge30pIHtcbiAgY29uc3QgZXhlY3V0aW9uU3RhdGUgPSBuZXcgRXhlY3V0aW9uU3RhdGUoKTtcbiAgY29uc3QgY29uZmlnU3RhdGUgPSBuZXcgQ29uZmlnU3RhdGUoKTtcbiAgYWN0aXZhdGVEZWJ1ZyhwYXJhbXMuY2xvdWREZWJ1Zyk7XG4gIGRlYnVnKFwicnVuIHBhcmFtcyAlb1wiLCBwYXJhbXMpO1xuICBwYXJhbXMgPSBwcmVwcm9jZXNzUGFyYW1zKHBhcmFtcyk7XG4gIGRlYnVnKFwicGFyYW1zIGFmdGVyIHByZXByb2Nlc3MgJW9cIiwgcGFyYW1zKTtcblxuICBpZiAoaXNPZmZsaW5lKHBhcmFtcykpIHtcbiAgICBpbmZvKGBTa2lwcGluZyBjbG91ZCBvcmNoZXN0cmF0aW9uIGJlY2F1c2UgLS1yZWNvcmQgaXMgc2V0IHRvIGZhbHNlYCk7XG4gICAgcmV0dXJuIHJ1bkJhcmVDeXByZXNzKHBhcmFtcyk7XG4gIH1cblxuICBjb25zdCB2YWxpZGF0ZWRQYXJhbXMgPSBhd2FpdCB2YWxpZGF0ZVBhcmFtcyhwYXJhbXMpO1xuICBzZXRBUElCYXNlVXJsKHZhbGlkYXRlZFBhcmFtcy5jbG91ZFNlcnZpY2VVcmwpO1xuXG4gIGlmICghaXNDdXJyZW50cygpKSB7XG4gICAgY29uc29sZS5sb2coZ2V0TGVnYWxOb3RpY2UoKSk7XG4gIH1cblxuICBjb25zdCB7XG4gICAgcmVjb3JkS2V5LFxuICAgIHByb2plY3RJZCxcbiAgICBncm91cCxcbiAgICBwYXJhbGxlbCxcbiAgICBjaUJ1aWxkSWQsXG4gICAgdGFnLFxuICAgIHRlc3RpbmdUeXBlLFxuICAgIGJhdGNoU2l6ZSxcbiAgICBhdXRvQ2FuY2VsQWZ0ZXJGYWlsdXJlcyxcbiAgfSA9IHZhbGlkYXRlZFBhcmFtcztcblxuICBjb25zdCBjb25maWcgPSBhd2FpdCBnZXRNZXJnZWRDb25maWcodmFsaWRhdGVkUGFyYW1zKTtcbiAgY29uZmlnU3RhdGUuc2V0Q29uZmlnKGNvbmZpZz8ucmVzb2x2ZWQpO1xuXG4gIGNvbnN0IHsgc3BlY3MsIHNwZWNQYXR0ZXJuIH0gPSBhd2FpdCBnZXRTcGVjRmlsZXMoe1xuICAgIGNvbmZpZyxcbiAgICBwYXJhbXM6IHZhbGlkYXRlZFBhcmFtcyxcbiAgfSk7XG5cbiAgaWYgKHNwZWNzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHBsYXRmb3JtID0gYXdhaXQgZ2V0UGxhdGZvcm0oe1xuICAgIGNvbmZpZyxcbiAgICBicm93c2VyOiB2YWxpZGF0ZWRQYXJhbXMuYnJvd3NlcixcbiAgfSk7XG5cbiAgaW5mbyhcIkRpc2NvdmVyZWQgJWQgc3BlYyBmaWxlc1wiLCBzcGVjcy5sZW5ndGgpO1xuICBpbmZvKFxuICAgIGBUYWdzOiAke3RhZy5sZW5ndGggPiAwID8gdGFnLmpvaW4oXCIsXCIpIDogZmFsc2V9OyBHcm91cDogJHtcbiAgICAgIGdyb3VwID8/IGZhbHNlXG4gICAgfTsgUGFyYWxsZWw6ICR7cGFyYWxsZWwgPz8gZmFsc2V9OyBCYXRjaCBTaXplOiAke2JhdGNoU2l6ZX1gXG4gICk7XG4gIGluZm8oXCJDb25uZWN0aW5nIHRvIGNsb3VkIG9yY2hlc3RyYXRpb24gc2VydmljZS4uLlwiKTtcblxuICBjb25zdCBydW4gPSBhd2FpdCBjcmVhdGVSdW4oe1xuICAgIGNpOiBnZXRDSShjaUJ1aWxkSWQpLFxuICAgIHNwZWNzOiBzcGVjcy5tYXAoKHNwZWMpID0+IHNwZWMucmVsYXRpdmUpLFxuICAgIGNvbW1pdDogYXdhaXQgZ2V0R2l0SW5mbyhjb25maWcucHJvamVjdFJvb3QpLFxuICAgIGdyb3VwLFxuICAgIHBsYXRmb3JtLFxuICAgIHBhcmFsbGVsOiBwYXJhbGxlbCA/PyBmYWxzZSxcbiAgICBjaUJ1aWxkSWQsXG4gICAgcHJvamVjdElkLFxuICAgIHJlY29yZEtleSxcbiAgICBzcGVjUGF0dGVybjogW3NwZWNQYXR0ZXJuXS5mbGF0KDIpLFxuICAgIHRhZ3M6IHRhZyxcbiAgICB0ZXN0aW5nVHlwZSxcbiAgICBiYXRjaFNpemUsXG4gICAgYXV0b0NhbmNlbEFmdGVyRmFpbHVyZXMsXG4gIH0pO1xuXG4gIHNldFJ1bklkKHJ1bi5ydW5JZCk7XG4gIGluZm8oXCJcdUQ4M0NcdURGQTUgUnVuIFVSTDpcIiwgYm9sZChydW4ucnVuVXJsKSk7XG4gIGN1dEluaXRpYWxPdXRwdXQoKTtcblxuICBhd2FpdCBzdGFydFdTUygpO1xuICBsaXN0ZW5Ub1NwZWNFdmVudHMoY29uZmlnU3RhdGUsIGV4ZWN1dGlvblN0YXRlKTtcblxuICBhd2FpdCBydW5UaWxsRG9uZU9yQ2FuY2VsbGVkKFxuICAgIGV4ZWN1dGlvblN0YXRlLFxuICAgIGNvbmZpZ1N0YXRlLFxuICAgIHtcbiAgICAgIHJ1bklkOiBydW4ucnVuSWQsXG4gICAgICBncm91cElkOiBydW4uZ3JvdXBJZCxcbiAgICAgIG1hY2hpbmVJZDogcnVuLm1hY2hpbmVJZCxcbiAgICAgIHBsYXRmb3JtLFxuICAgICAgc3BlY3MsXG4gICAgfSxcbiAgICB2YWxpZGF0ZWRQYXJhbXNcbiAgKTtcblxuICBkaXZpZGVyKCk7XG5cbiAgYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKHJlcG9ydFRhc2tzKTtcbiAgY29uc3QgX3N1bW1hcnkgPSBzdW1tYXJpemVUZXN0UmVzdWx0cyhcbiAgICBleGVjdXRpb25TdGF0ZS5nZXRSZXN1bHRzKGNvbmZpZ1N0YXRlKSxcbiAgICBjb25maWdcbiAgKTtcblxuICB0aXRsZShcIndoaXRlXCIsIFwiQ2xvdWQgUnVuIEZpbmlzaGVkXCIpO1xuICBjb25zb2xlLmxvZyhzdW1tYXJ5VGFibGUoX3N1bW1hcnkpKTtcbiAgaW5mbyhcIlx1RDgzQ1x1REZDMSBSZWNvcmRlZCBSdW46XCIsIGJvbGQocnVuLnJ1blVybCkpO1xuXG4gIGF3YWl0IHNodXRkb3duKCk7XG5cbiAgc3BhY2VyKCk7XG4gIGlmIChfc3VtbWFyeS5zdGF0dXMgPT09IFwiZmluaXNoZWRcIikge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5fc3VtbWFyeSxcbiAgICAgIHJ1blVybDogcnVuLnJ1blVybCxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF9zdW1tYXJ5O1xufVxuXG5mdW5jdGlvbiBsaXN0ZW5Ub1NwZWNFdmVudHMoXG4gIGNvbmZpZ1N0YXRlOiBDb25maWdTdGF0ZSxcbiAgZXhlY3V0aW9uU3RhdGU6IEV4ZWN1dGlvblN0YXRlXG4pIHtcbiAgcHVic3ViLm9uKFwiYmVmb3JlOnNwZWNcIiwgYXN5bmMgKHsgc3BlYyB9OiB7IHNwZWM6IEN5cHJlc3MuU3BlYyB9KSA9PiB7XG4gICAgZGVidWcoXCJiZWZvcmU6c3BlYyAlb1wiLCBzcGVjKTtcbiAgICBleGVjdXRpb25TdGF0ZS5zZXRTcGVjQmVmb3JlKHNwZWMucmVsYXRpdmUpO1xuICB9KTtcblxuICBwdWJzdWIub24oXG4gICAgXCJhZnRlcjpzcGVjXCIsXG4gICAgYXN5bmMgKHsgc3BlYywgcmVzdWx0cyB9OiB7IHNwZWM6IEN5cHJlc3MuU3BlYzsgcmVzdWx0czogYW55IH0pID0+IHtcbiAgICAgIGRlYnVnKFwiYWZ0ZXI6c3BlYyAlbyAlb1wiLCBzcGVjLCByZXN1bHRzKTtcbiAgICAgIGV4ZWN1dGlvblN0YXRlLnNldFNwZWNBZnRlcihzcGVjLnJlbGF0aXZlLCByZXN1bHRzKTtcbiAgICAgIGV4ZWN1dGlvblN0YXRlLnNldFNwZWNPdXRwdXQoc3BlYy5yZWxhdGl2ZSwgZ2V0Q2FwdHVyZWRPdXRwdXQoKSk7XG4gICAgICBjcmVhdGVSZXBvcnRUYXNrU3BlYyhjb25maWdTdGF0ZSwgZXhlY3V0aW9uU3RhdGUsIHNwZWMucmVsYXRpdmUpO1xuICAgIH1cbiAgKTtcbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gZ2V0TGVnYWxOb3RpY2UoKSB7XG4gIHJldHVybiBgXG5Db3B5cmlnaHQgKEMpICR7bmV3IERhdGUoKS5nZXRGdWxsWWVhcigpfSBDdXJyZW50cyBTb2Z0d2FyZSBJbmMgaHR0cHM6Ly9jdXJyZW50cy5kZXZcblRoaXMgaXMgZnJlZSBzb2Z0d2FyZSwgYW5kIHlvdSBhcmUgd2VsY29tZSB0byByZWRpc3RyaWJ1dGUgaXQgdW5kZXIgY2VydGFpblxuY29uZGl0aW9ucy4gVGhpcyBwcm9ncmFtIGNvbWVzIHdpdGggbm8gd2FycmFudHkuIFBhcnRzIG9mIHRoaXMgcHJvZ3JhbSBhcmUgTUlUXG5saWNlbnNlZC4gUmVmZXIgdG8gdGhlIGxpY2Vuc2UgZm9yIGRldGFpbHNcbmh0dHBzOi8vZ2l0aHViLmNvbS9jdXJyZW50cy1kZXYvY3lwcmVzcy1jbG91ZC9ibG9iL21haW4vTElDRU5TRS5tZFxuYDtcbn1cbiIsICJpbXBvcnQgXyBmcm9tIFwibG9kYXNoXCI7XG5pbXBvcnQgeyBtYWdlbnRhIH0gZnJvbSBcIi4uL2xvZ1wiO1xuXG5pbXBvcnQgeyBpbmZvLCBzcGFjZXIsIHdhcm4gfSBmcm9tIFwiLi4vbG9nXCI7XG5pbXBvcnQgeyBDbG91ZFdhcm5pbmcgfSBmcm9tIFwiLi90eXBlc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gcHJpbnRXYXJuaW5ncyh3YXJuaW5nczogQ2xvdWRXYXJuaW5nW10pIHtcbiAgd2FybihcIk5vdGljZSBmcm9tIGNsb3VkIHNlcnZpY2U6XCIpO1xuICB3YXJuaW5ncy5tYXAoKHcpID0+IHtcbiAgICBzcGFjZXIoMSk7XG4gICAgaW5mbyhtYWdlbnRhLmJvbGQody5tZXNzYWdlKSk7XG4gICAgT2JqZWN0LmVudHJpZXMoXy5vbWl0KHcsIFwibWVzc2FnZVwiKSkubWFwKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgIGluZm8oXCItICVzOiAlc1wiLCBrZXksIHZhbHVlKTtcbiAgICB9KTtcbiAgICBzcGFjZXIoMSk7XG4gIH0pO1xufVxuIiwgImltcG9ydCB7IG1ha2VSZXF1ZXN0IH0gZnJvbSBcIi4uL2h0dHBDbGllbnRcIjtcbmltcG9ydCB7XG4gIENyZWF0ZUluc3RhbmNlQ3lQYXlsb2FkLFxuICBDcmVhdGVJbnN0YW5jZVBheWxvYWQsXG4gIENyZWF0ZUluc3RhbmNlUmVzcG9uc2UsXG4gIENyZWF0ZUluc3RhbmNlc1Jlc3BvbnNlLFxuICBDcmVhdGVSdW5QYXlsb2FkLFxuICBDcmVhdGVSdW5SZXNwb25zZSxcbiAgU2V0SW5zdGFuY2VUZXN0c1BheWxvYWQsXG4gIFVwZGF0ZUluc3RhbmNlUmVzdWx0c01lcmdlZFBheWxvYWQsXG4gIFVwZGF0ZUluc3RhbmNlUmVzdWx0c1BheWxvYWQsXG4gIFVwZGF0ZUluc3RhbmNlUmVzdWx0c1Jlc3BvbnNlLFxufSBmcm9tIFwiLi90eXBlc1wiO1xuaW1wb3J0IHsgcHJpbnRXYXJuaW5ncyB9IGZyb20gXCIuL3dhcm5pbmdzXCI7XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVSdW4gPSBhc3luYyAocGF5bG9hZDogQ3JlYXRlUnVuUGF5bG9hZCkgPT4ge1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IG1ha2VSZXF1ZXN0PENyZWF0ZVJ1blJlc3BvbnNlLCBDcmVhdGVSdW5QYXlsb2FkPih7XG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICB1cmw6IFwiL3J1bnNcIixcbiAgICBkYXRhOiBwYXlsb2FkLFxuICB9KTtcblxuICBpZiAoKHJlc3BvbnNlLmRhdGEud2FybmluZ3M/Lmxlbmd0aCA/PyAwKSA+IDApIHtcbiAgICBwcmludFdhcm5pbmdzKHJlc3BvbnNlLmRhdGEud2FybmluZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG59O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlSW5zdGFuY2UgPSBhc3luYyAoe1xuICBydW5JZCxcbiAgZ3JvdXBJZCxcbiAgbWFjaGluZUlkLFxuICBwbGF0Zm9ybSxcbn06IENyZWF0ZUluc3RhbmNlUGF5bG9hZCkgPT4ge1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IG1ha2VSZXF1ZXN0PFxuICAgIENyZWF0ZUluc3RhbmNlUmVzcG9uc2UsXG4gICAgQ3JlYXRlSW5zdGFuY2VQYXlsb2FkXG4gID4oe1xuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgdXJsOiBgcnVucy8ke3J1bklkfS9pbnN0YW5jZXNgLFxuICAgIGRhdGE6IHtcbiAgICAgIHJ1bklkLFxuICAgICAgZ3JvdXBJZCxcbiAgICAgIG1hY2hpbmVJZCxcbiAgICAgIHBsYXRmb3JtLFxuICAgIH0sXG4gIH0pO1xuXG4gIHJldHVybiByZXNwb25zZS5kYXRhO1xufTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZUJhdGNoZWRJbnN0YW5jZXMgPSBhc3luYyAoZGF0YTogQ3JlYXRlSW5zdGFuY2VDeVBheWxvYWQpID0+IHtcbiAgY29uc3QgcmVzcG9uZSA9IGF3YWl0IG1ha2VSZXF1ZXN0PFxuICAgIENyZWF0ZUluc3RhbmNlc1Jlc3BvbnNlLFxuICAgIENyZWF0ZUluc3RhbmNlQ3lQYXlsb2FkXG4gID4oe1xuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgdXJsOiBgcnVucy8ke2RhdGEucnVuSWR9L2N5L2luc3RhbmNlc2AsXG4gICAgZGF0YSxcbiAgfSk7XG5cbiAgcmV0dXJuIHJlc3BvbmUuZGF0YTtcbn07XG5cbmV4cG9ydCBjb25zdCBzZXRJbnN0YW5jZVRlc3RzID0gKFxuICBpbnN0YW5jZUlkOiBzdHJpbmcsXG4gIHBheWxvYWQ6IFNldEluc3RhbmNlVGVzdHNQYXlsb2FkXG4pID0+XG4gIG1ha2VSZXF1ZXN0PHt9LCBTZXRJbnN0YW5jZVRlc3RzUGF5bG9hZD4oe1xuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgdXJsOiBgaW5zdGFuY2VzLyR7aW5zdGFuY2VJZH0vdGVzdHNgLFxuICAgIGRhdGE6IHBheWxvYWQsXG4gIH0pLnRoZW4oKHJlc3VsdCkgPT4gcmVzdWx0LmRhdGEpO1xuXG5leHBvcnQgY29uc3QgdXBkYXRlSW5zdGFuY2VSZXN1bHRzID0gKFxuICBpbnN0YW5jZUlkOiBzdHJpbmcsXG4gIHBheWxvYWQ6IFVwZGF0ZUluc3RhbmNlUmVzdWx0c1BheWxvYWRcbikgPT5cbiAgbWFrZVJlcXVlc3Q8VXBkYXRlSW5zdGFuY2VSZXN1bHRzUmVzcG9uc2UsIFVwZGF0ZUluc3RhbmNlUmVzdWx0c1BheWxvYWQ+KHtcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIHVybDogYGluc3RhbmNlcy8ke2luc3RhbmNlSWR9L3Jlc3VsdHNgLFxuICAgIGRhdGE6IHBheWxvYWQsXG4gIH0pLnRoZW4oKHJlc3VsdCkgPT4gcmVzdWx0LmRhdGEpO1xuXG5leHBvcnQgY29uc3QgcmVwb3J0SW5zdGFuY2VSZXN1bHRzTWVyZ2VkID0gKFxuICBpbnN0YW5jZUlkOiBzdHJpbmcsXG4gIHBheWxvYWQ6IFVwZGF0ZUluc3RhbmNlUmVzdWx0c01lcmdlZFBheWxvYWRcbikgPT5cbiAgbWFrZVJlcXVlc3Q8XG4gICAgVXBkYXRlSW5zdGFuY2VSZXN1bHRzUmVzcG9uc2UsXG4gICAgVXBkYXRlSW5zdGFuY2VSZXN1bHRzTWVyZ2VkUGF5bG9hZFxuICA+KHtcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIHVybDogYGluc3RhbmNlcy8ke2luc3RhbmNlSWR9L2N5L3Jlc3VsdHNgLFxuICAgIGRhdGE6IHBheWxvYWQsXG4gIH0pLnRoZW4oKHJlc3VsdCkgPT4gcmVzdWx0LmRhdGEpO1xuXG5leHBvcnQgY29uc3QgdXBkYXRlSW5zdGFuY2VTdGRvdXQgPSAoaW5zdGFuY2VJZDogc3RyaW5nLCBzdGRvdXQ6IHN0cmluZykgPT5cbiAgbWFrZVJlcXVlc3Q8YW55LCB7IHN0ZG91dDogc3RyaW5nIH0+KHtcbiAgICBtZXRob2Q6IFwiUFVUXCIsXG4gICAgdXJsOiBgaW5zdGFuY2VzLyR7aW5zdGFuY2VJZH0vc3Rkb3V0YCxcbiAgICBkYXRhOiB7XG4gICAgICBzdGRvdXQsXG4gICAgfSxcbiAgfSk7XG4iLCAiLyohIEBwcmVzZXJ2ZVxuXG4jIyMgTUlUXG5cblBhcnRzIG9mIHRoaXMgY29kZSB3YXMgY29waWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2N5cHJlc3MtaW8vY3lwcmVzcyBhbmQgaXMgc3ViamVjdCB0byBNSVQgbGljZW5zZS5cblxuTUlUIExpY2Vuc2VcblxuQ29weXJpZ2h0IChjKSAyMDIyIEN5cHJlc3MuaW9cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbmNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcblNPRlRXQVJFLlxuKi9cblxuaW1wb3J0IGRlYnVnRm4gZnJvbSBcImRlYnVnXCI7XG5cbmltcG9ydCBfIGZyb20gXCJsb2Rhc2hcIjtcbmltcG9ydCB7IFZhbGlkYXRpb25FcnJvciB9IGZyb20gXCIuL2Vycm9yc1wiO1xuXG5jb25zdCBkZWJ1ZyA9IGRlYnVnRm4oXCJjdXJyZW50czpjaVwiKTtcblxuY29uc3Qgam9pbiA9IChjaGFyOiBzdHJpbmcsIC4uLnBpZWNlczogKHN0cmluZyB8IHVuZGVmaW5lZClbXSkgPT4ge1xuICByZXR1cm4gXy5jaGFpbihwaWVjZXMpLmNvbXBhY3QoKS5qb2luKGNoYXIpLnZhbHVlKCk7XG59O1xuXG5jb25zdCB0b0NhbWVsT2JqZWN0ID0gKG9iajogYW55LCBrZXk6IHN0cmluZykgPT4ge1xuICByZXR1cm4gXy5zZXQob2JqLCBfLmNhbWVsQ2FzZShrZXkpLCBwcm9jZXNzLmVudltrZXldKTtcbn07XG5cbmNvbnN0IGV4dHJhY3QgPSAoZW52S2V5czogc3RyaW5nW10pID0+IHtcbiAgcmV0dXJuIF8udHJhbnNmb3JtKGVudktleXMsIHRvQ2FtZWxPYmplY3QsIHt9KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHJ1bm5pbmcgb24gVGVhbUZvdW5kYXRpb24gc2VydmVyLlxuICogQHNlZSBodHRwczovL3RlY2huZXQubWljcm9zb2Z0LmNvbS9lbi11cy9oaDg1MDQ0OCh2PXZzLjkyKVxuICovXG5jb25zdCBpc1RlYW1Gb3VuZGF0aW9uID0gKCkgPT4ge1xuICByZXR1cm4gcHJvY2Vzcy5lbnYuVEZfQlVJTEQgJiYgcHJvY2Vzcy5lbnYuVEZfQlVJTERfQlVJTEROVU1CRVI7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBydW5uaW5nIG9uIEF6dXJlIENJIHBpcGVsaW5lLlxuICogU2VlIGVudmlyb25tZW50IHZhcmlhYmxlcyBpbiB0aGUgaXNzdWUgIzM2NTdcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2N5cHJlc3MtaW8vY3lwcmVzcy9pc3N1ZXMvMzY1N1xuICovXG5jb25zdCBpc0F6dXJlQ2kgPSAoKSA9PiB7XG4gIHJldHVybiBwcm9jZXNzLmVudi5URl9CVUlMRCAmJiBwcm9jZXNzLmVudi5BWlVSRV9IVFRQX1VTRVJfQUdFTlQ7XG59O1xuXG5jb25zdCBpc0FXU0NvZGVCdWlsZCA9ICgpID0+IHtcbiAgcmV0dXJuIF8uc29tZShwcm9jZXNzLmVudiwgKHZhbCwga2V5KSA9PiB7XG4gICAgcmV0dXJuIC9eQ09ERUJVSUxEXy8udGVzdChrZXkpO1xuICB9KTtcbn07XG5cbmNvbnN0IGlzQmFtYm9vID0gKCkgPT4ge1xuICByZXR1cm4gcHJvY2Vzcy5lbnYuYmFtYm9vX2J1aWxkTnVtYmVyO1xufTtcblxuY29uc3QgaXNDb2Rlc2hpcEJhc2ljID0gKCkgPT4ge1xuICByZXR1cm4gKFxuICAgIHByb2Nlc3MuZW52LkNJX05BTUUgJiZcbiAgICBwcm9jZXNzLmVudi5DSV9OQU1FID09PSBcImNvZGVzaGlwXCIgJiZcbiAgICBwcm9jZXNzLmVudi5DT0RFU0hJUFxuICApO1xufTtcblxuY29uc3QgaXNDb2Rlc2hpcFBybyA9ICgpID0+IHtcbiAgcmV0dXJuIChcbiAgICBwcm9jZXNzLmVudi5DSV9OQU1FICYmXG4gICAgcHJvY2Vzcy5lbnYuQ0lfTkFNRSA9PT0gXCJjb2Rlc2hpcFwiICYmXG4gICAgIXByb2Nlc3MuZW52LkNPREVTSElQXG4gICk7XG59O1xuXG5jb25zdCBpc0NvbmNvdXJzZSA9ICgpID0+IHtcbiAgcmV0dXJuIF8uc29tZShwcm9jZXNzLmVudiwgKHZhbCwga2V5KSA9PiB7XG4gICAgcmV0dXJuIC9eQ09OQ09VUlNFXy8udGVzdChrZXkpO1xuICB9KTtcbn07XG5cbmNvbnN0IGlzR2l0bGFiID0gKCkgPT4ge1xuICByZXR1cm4gKFxuICAgIHByb2Nlc3MuZW52LkdJVExBQl9DSSB8fFxuICAgIChwcm9jZXNzLmVudi5DSV9TRVJWRVJfTkFNRSAmJiAvXkdpdExhYi8udGVzdChwcm9jZXNzLmVudi5DSV9TRVJWRVJfTkFNRSkpXG4gICk7XG59O1xuXG5jb25zdCBpc0dvb2dsZUNsb3VkID0gKCkgPT4ge1xuICAvLyBzZXQgYXV0b21hdGljYWxseSBmb3IgdGhlIE5vZGUuanMgNiwgTm9kZS5qcyA4IHJ1bnRpbWVzIChub3QgaW4gTm9kZSAxMClcbiAgLy8gVE9ETzogbWF5IGFsc28gcG90ZW50aWFsbHkgaGF2ZSBYX0dPT0dMRV8qIGVudiB2YXIgc2V0XG4gIC8vIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9mdW5jdGlvbnMvZG9jcy9lbnYtdmFyI2Vudmlyb25tZW50X3ZhcmlhYmxlc19zZXRfYXV0b21hdGljYWxseVxuICByZXR1cm4gKFxuICAgIHByb2Nlc3MuZW52LkdDUF9QUk9KRUNUIHx8XG4gICAgcHJvY2Vzcy5lbnYuR0NMT1VEX1BST0pFQ1QgfHxcbiAgICBwcm9jZXNzLmVudi5HT09HTEVfQ0xPVURfUFJPSkVDVFxuICApO1xufTtcblxuY29uc3QgaXNKZW5raW5zID0gKCkgPT4ge1xuICByZXR1cm4gKFxuICAgIHByb2Nlc3MuZW52LkpFTktJTlNfVVJMIHx8XG4gICAgcHJvY2Vzcy5lbnYuSkVOS0lOU19IT01FIHx8XG4gICAgcHJvY2Vzcy5lbnYuSkVOS0lOU19WRVJTSU9OIHx8XG4gICAgcHJvY2Vzcy5lbnYuSFVEU09OX1VSTCB8fFxuICAgIHByb2Nlc3MuZW52LkhVRFNPTl9IT01FXG4gICk7XG59O1xuXG5jb25zdCBpc1dlcmNrZXIgPSAoKSA9PiB7XG4gIHJldHVybiBwcm9jZXNzLmVudi5XRVJDS0VSIHx8IHByb2Nlc3MuZW52LldFUkNLRVJfTUFJTl9QSVBFTElORV9TVEFSVEVEO1xufTtcblxuLyoqXG4gKiBXZSBkZXRlY3QgQ0kgcHJvdmlkZXJzIGJ5IGRldGVjdGluZyBhbiBlbnZpcm9ubWVudCB2YXJpYWJsZVxuICogdW5pcXVlIHRvIHRoZSBwcm92aWRlciwgb3IgYnkgY2FsbGluZyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0cnVlXG4gKiBmb3IgdGhhdCBwcm92aWRlci5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgQXBwVmV5b3IgQ0kgaGFzIGVudmlyb25tZW50IHRoZVxuICogdmFyaWFibGUgXCJBUFBWRVlPUlwiIHNldCBkdXJpbmcgcnVuXG4gKi9cbmNvbnN0IENJX1BST1ZJREVSUyA9IHtcbiAgYXBwdmV5b3I6IFwiQVBQVkVZT1JcIixcbiAgYXp1cmU6IGlzQXp1cmVDaSxcbiAgYXdzQ29kZUJ1aWxkOiBpc0FXU0NvZGVCdWlsZCxcbiAgYmFtYm9vOiBpc0JhbWJvbyxcbiAgYml0YnVja2V0OiBcIkJJVEJVQ0tFVF9CVUlMRF9OVU1CRVJcIixcbiAgYnVpbGRraXRlOiBcIkJVSUxES0lURVwiLFxuICBjaXJjbGU6IFwiQ0lSQ0xFQ0lcIixcbiAgY29kZXNoaXBCYXNpYzogaXNDb2Rlc2hpcEJhc2ljLFxuICBjb2Rlc2hpcFBybzogaXNDb2Rlc2hpcFBybyxcbiAgY29uY291cnNlOiBpc0NvbmNvdXJzZSxcbiAgY29kZUZyZXNoOiBcIkNGX0JVSUxEX0lEXCIsXG4gIGRyb25lOiBcIkRST05FXCIsXG4gIGdpdGh1YkFjdGlvbnM6IFwiR0lUSFVCX0FDVElPTlNcIixcbiAgZ2l0bGFiOiBpc0dpdGxhYixcbiAgZ29DRDogXCJHT19KT0JfTkFNRVwiLFxuICBnb29nbGVDbG91ZDogaXNHb29nbGVDbG91ZCxcbiAgamVua2luczogaXNKZW5raW5zLFxuICBzZW1hcGhvcmU6IFwiU0VNQVBIT1JFXCIsXG4gIHNoaXBwYWJsZTogXCJTSElQUEFCTEVcIixcbiAgdGVhbWNpdHk6IFwiVEVBTUNJVFlfVkVSU0lPTlwiLFxuICB0ZWFtZm91bmRhdGlvbjogaXNUZWFtRm91bmRhdGlvbixcbiAgdHJhdmlzOiBcIlRSQVZJU1wiLFxuICB3ZXJja2VyOiBpc1dlcmNrZXIsXG4gIG5ldGxpZnk6IFwiTkVUTElGWVwiLFxuICBsYXllcmNpOiBcIkxBWUVSQ0lcIixcbn07XG5cbmZ1bmN0aW9uIF9kZXRlY3RQcm92aWRlck5hbWUoKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgY29uc3QgeyBlbnYgfSA9IHByb2Nlc3M7XG4gIC8vIHJldHVybiB0aGUga2V5IG9mIHRoZSBmaXJzdCBwcm92aWRlclxuICAvLyB3aGljaCBpcyB0cnV0aHlcblxuICByZXR1cm4gXy5maW5kS2V5KENJX1BST1ZJREVSUywgKHZhbHVlKSA9PiB7XG4gICAgaWYgKF8uaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZW52W3ZhbHVlXTtcbiAgICB9XG5cbiAgICBpZiAoXy5pc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlKCk7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gVE9ETzogZG9uJ3QgZm9yIGFib3V0IGJ1aWxkTnVtYmVyIVxuLy8gbG9vayBhdCB0aGUgb2xkIGNvbW1pdCB0aGF0IHdhcyByZW1vdmVkIHRvIHNlZSBob3cgd2UgZGlkIGl0XG5jb25zdCBfcHJvdmlkZXJDaVBhcmFtcyA9ICgpOiBQcm92aWRlckNpUGFyYW1zUmVzID0+IHtcbiAgcmV0dXJuIHtcbiAgICBhcHB2ZXlvcjogZXh0cmFjdChbXG4gICAgICBcIkFQUFZFWU9SX0pPQl9JRFwiLFxuICAgICAgXCJBUFBWRVlPUl9BQ0NPVU5UX05BTUVcIixcbiAgICAgIFwiQVBQVkVZT1JfUFJPSkVDVF9TTFVHXCIsXG4gICAgICBcIkFQUFZFWU9SX0JVSUxEX05VTUJFUlwiLFxuICAgICAgXCJBUFBWRVlPUl9CVUlMRF9WRVJTSU9OXCIsXG4gICAgICBcIkFQUFZFWU9SX1BVTExfUkVRVUVTVF9OVU1CRVJcIixcbiAgICAgIFwiQVBQVkVZT1JfUFVMTF9SRVFVRVNUX0hFQURfUkVQT19CUkFOQ0hcIixcbiAgICBdKSxcbiAgICBhenVyZTogZXh0cmFjdChbXG4gICAgICBcIkJVSUxEX0JVSUxESURcIixcbiAgICAgIFwiQlVJTERfQlVJTEROVU1CRVJcIixcbiAgICAgIFwiQlVJTERfQ09OVEFJTkVSSURcIixcbiAgICAgIFwiQlVJTERfUkVQT1NJVE9SWV9VUklcIixcbiAgICBdKSxcbiAgICBhd3NDb2RlQnVpbGQ6IGV4dHJhY3QoW1xuICAgICAgXCJDT0RFQlVJTERfQlVJTERfSURcIixcbiAgICAgIFwiQ09ERUJVSUxEX0JVSUxEX05VTUJFUlwiLFxuICAgICAgXCJDT0RFQlVJTERfUkVTT0xWRURfU09VUkNFX1ZFUlNJT05cIixcbiAgICAgIFwiQ09ERUJVSUxEX1NPVVJDRV9SRVBPX1VSTFwiLFxuICAgICAgXCJDT0RFQlVJTERfU09VUkNFX1ZFUlNJT05cIixcbiAgICBdKSxcbiAgICBiYW1ib286IGV4dHJhY3QoW1xuICAgICAgXCJiYW1ib29fYnVpbGROdW1iZXJcIixcbiAgICAgIFwiYmFtYm9vX2J1aWxkUmVzdWx0c1VybFwiLFxuICAgICAgXCJiYW1ib29fcGxhblJlcG9zaXRvcnlfcmVwb3NpdG9yeVVybFwiLFxuICAgICAgXCJiYW1ib29fYnVpbGRLZXlcIixcbiAgICBdKSxcbiAgICBiaXRidWNrZXQ6IGV4dHJhY3QoW1xuICAgICAgXCJCSVRCVUNLRVRfUkVQT19TTFVHXCIsXG4gICAgICBcIkJJVEJVQ0tFVF9SRVBPX09XTkVSXCIsXG4gICAgICBcIkJJVEJVQ0tFVF9CVUlMRF9OVU1CRVJcIixcbiAgICAgIFwiQklUQlVDS0VUX1BBUkFMTEVMX1NURVBcIixcbiAgICAgIFwiQklUQlVDS0VUX1NURVBfUlVOX05VTUJFUlwiLFxuICAgICAgLy8gdGhlIFBSIHZhcmlhYmxlcyBhcmUgb25seSBzZXQgb24gcHVsbCByZXF1ZXN0IGJ1aWxkc1xuICAgICAgXCJCSVRCVUNLRVRfUFJfSURcIixcbiAgICAgIFwiQklUQlVDS0VUX1BSX0RFU1RJTkFUSU9OX0JSQU5DSFwiLFxuICAgICAgXCJCSVRCVUNLRVRfUFJfREVTVElOQVRJT05fQ09NTUlUXCIsXG4gICAgXSksXG4gICAgYnVpbGRraXRlOiBleHRyYWN0KFtcbiAgICAgIFwiQlVJTERLSVRFX1JFUE9cIixcbiAgICAgIFwiQlVJTERLSVRFX1NPVVJDRVwiLFxuICAgICAgXCJCVUlMREtJVEVfSk9CX0lEXCIsXG4gICAgICBcIkJVSUxES0lURV9CVUlMRF9JRFwiLFxuICAgICAgXCJCVUlMREtJVEVfQlVJTERfVVJMXCIsXG4gICAgICBcIkJVSUxES0lURV9CVUlMRF9OVU1CRVJcIixcbiAgICAgIFwiQlVJTERLSVRFX1BVTExfUkVRVUVTVFwiLFxuICAgICAgXCJCVUlMREtJVEVfUFVMTF9SRVFVRVNUX1JFUE9cIixcbiAgICAgIFwiQlVJTERLSVRFX1BVTExfUkVRVUVTVF9CQVNFX0JSQU5DSFwiLFxuICAgIF0pLFxuICAgIGNpcmNsZTogZXh0cmFjdChbXG4gICAgICBcIkNJUkNMRV9KT0JcIixcbiAgICAgIFwiQ0lSQ0xFX0JVSUxEX05VTVwiLFxuICAgICAgXCJDSVJDTEVfQlVJTERfVVJMXCIsXG4gICAgICBcIkNJUkNMRV9QUl9OVU1CRVJcIixcbiAgICAgIFwiQ0lSQ0xFX1BSX1JFUE9OQU1FXCIsXG4gICAgICBcIkNJUkNMRV9QUl9VU0VSTkFNRVwiLFxuICAgICAgXCJDSVJDTEVfQ09NUEFSRV9VUkxcIixcbiAgICAgIFwiQ0lSQ0xFX1dPUktGTE9XX0lEXCIsXG4gICAgICBcIkNJUkNMRV9QVUxMX1JFUVVFU1RcIixcbiAgICAgIFwiQ0lSQ0xFX1JFUE9TSVRPUllfVVJMXCIsXG4gICAgICBcIkNJX1BVTExfUkVRVUVTVFwiLFxuICAgIF0pLFxuICAgIGNvZGVzaGlwQmFzaWM6IGV4dHJhY3QoW1xuICAgICAgXCJDSV9CVUlMRF9JRFwiLFxuICAgICAgXCJDSV9SRVBPX05BTUVcIixcbiAgICAgIFwiQ0lfQlVJTERfVVJMXCIsXG4gICAgICBcIkNJX1BST0pFQ1RfSURcIixcbiAgICAgIFwiQ0lfQlVJTERfTlVNQkVSXCIsXG4gICAgICBcIkNJX1BVTExfUkVRVUVTVFwiLFxuICAgIF0pLFxuICAgIC8vIENvZGVzaGlwUHJvIHByb3ZpZGVzIHZlcnkgZmV3IENJIHZhcmlhYmxlc1xuICAgIC8vIGh0dHBzOi8vZG9jdW1lbnRhdGlvbi5jb2Rlc2hpcC5jb20vcHJvL2J1aWxkcy1hbmQtY29uZmlndXJhdGlvbi9lbnZpcm9ubWVudC12YXJpYWJsZXMvXG4gICAgY29kZXNoaXBQcm86IGV4dHJhY3QoW1wiQ0lfQlVJTERfSURcIiwgXCJDSV9SRVBPX05BTUVcIiwgXCJDSV9QUk9KRUNUX0lEXCJdKSxcbiAgICAvLyBodHRwczovL2NvbmNvdXJzZS1jaS5vcmcvaW1wbGVtZW50aW5nLXJlc291cmNlLXR5cGVzLmh0bWwjcmVzb3VyY2UtbWV0YWRhdGFcbiAgICBjb25jb3Vyc2U6IGV4dHJhY3QoW1xuICAgICAgXCJCVUlMRF9JRFwiLFxuICAgICAgXCJCVUlMRF9OQU1FXCIsXG4gICAgICBcIkJVSUxEX0pPQl9OQU1FXCIsXG4gICAgICBcIkJVSUxEX1BJUEVMSU5FX05BTUVcIixcbiAgICAgIFwiQlVJTERfVEVBTV9OQU1FXCIsXG4gICAgICBcIkFUQ19FWFRFUk5BTF9VUkxcIixcbiAgICBdKSxcbiAgICAvLyBodHRwczovL2NvZGVmcmVzaC5pby9kb2NzL2RvY3MvY29kZWZyZXNoLXlhbWwvdmFyaWFibGVzL1xuICAgIGNvZGVGcmVzaDogZXh0cmFjdChbXG4gICAgICBcIkNGX0JVSUxEX0lEXCIsXG4gICAgICBcIkNGX0JVSUxEX1VSTFwiLFxuICAgICAgXCJDRl9DVVJSRU5UX0FUVEVNUFRcIixcbiAgICAgIFwiQ0ZfU1RFUF9OQU1FXCIsXG4gICAgICBcIkNGX1BJUEVMSU5FX05BTUVcIixcbiAgICAgIFwiQ0ZfUElQRUxJTkVfVFJJR0dFUl9JRFwiLFxuICAgICAgLy8gdmFyaWFibGVzIGFkZGVkIGZvciBwdWxsIHJlcXVlc3RzXG4gICAgICBcIkNGX1BVTExfUkVRVUVTVF9JRFwiLFxuICAgICAgXCJDRl9QVUxMX1JFUVVFU1RfSVNfRk9SS1wiLFxuICAgICAgXCJDRl9QVUxMX1JFUVVFU1RfTlVNQkVSXCIsXG4gICAgICBcIkNGX1BVTExfUkVRVUVTVF9UQVJHRVRcIixcbiAgICBdKSxcbiAgICBkcm9uZTogZXh0cmFjdChbXG4gICAgICBcIkRST05FX0pPQl9OVU1CRVJcIixcbiAgICAgIFwiRFJPTkVfQlVJTERfTElOS1wiLFxuICAgICAgXCJEUk9ORV9CVUlMRF9OVU1CRVJcIixcbiAgICAgIFwiRFJPTkVfUFVMTF9SRVFVRVNUXCIsXG4gICAgXSksXG4gICAgLy8gaHR0cHM6Ly9oZWxwLmdpdGh1Yi5jb20vZW4vYWN0aW9ucy9hdXRvbWF0aW5nLXlvdXItd29ya2Zsb3ctd2l0aC1naXRodWItYWN0aW9ucy91c2luZy1lbnZpcm9ubWVudC12YXJpYWJsZXMjZGVmYXVsdC1lbnZpcm9ubWVudC12YXJpYWJsZXNcbiAgICBnaXRodWJBY3Rpb25zOiBleHRyYWN0KFtcbiAgICAgIFwiR0lUSFVCX1dPUktGTE9XXCIsXG4gICAgICBcIkdJVEhVQl9BQ1RJT05cIixcbiAgICAgIFwiR0lUSFVCX0VWRU5UX05BTUVcIixcbiAgICAgIFwiR0lUSFVCX1JVTl9JRFwiLFxuICAgICAgXCJHSVRIVUJfUlVOX0FUVEVNUFRcIixcbiAgICAgIFwiR0lUSFVCX1JFUE9TSVRPUllcIixcbiAgICBdKSxcbiAgICAvLyBzZWUgaHR0cHM6Ly9kb2NzLmdpdGxhYi5jb20vZWUvY2kvdmFyaWFibGVzL1xuICAgIGdpdGxhYjogZXh0cmFjdChbXG4gICAgICAvLyBwaXBlbGluZSBpcyBjb21tb24gYW1vbmcgYWxsIGpvYnNcbiAgICAgIFwiQ0lfUElQRUxJTkVfSURcIixcbiAgICAgIFwiQ0lfUElQRUxJTkVfVVJMXCIsXG4gICAgICAvLyBpbmRpdmlkdWFsIGpvYnNcbiAgICAgIFwiQ0lfQlVJTERfSURcIiwgLy8gYnVpbGQgaWQgYW5kIGpvYiBpZCBhcmUgYWxpYXNlc1xuICAgICAgXCJDSV9KT0JfSURcIixcbiAgICAgIFwiQ0lfSk9CX1VSTFwiLFxuICAgICAgXCJDSV9KT0JfTkFNRVwiLFxuICAgICAgLy8gb3RoZXIgaW5mb3JtYXRpb25cbiAgICAgIFwiR0lUTEFCX0hPU1RcIixcbiAgICAgIFwiQ0lfUFJPSkVDVF9JRFwiLFxuICAgICAgXCJDSV9QUk9KRUNUX1VSTFwiLFxuICAgICAgXCJDSV9SRVBPU0lUT1JZX1VSTFwiLFxuICAgICAgXCJDSV9FTlZJUk9OTUVOVF9VUkxcIixcbiAgICAgIFwiQ0lfREVGQVVMVF9CUkFOQ0hcIixcbiAgICAgIC8vIGZvciBQUnM6IGh0dHBzOi8vZ2l0bGFiLmNvbS9naXRsYWItb3JnL2dpdGxhYi1jZS9pc3N1ZXMvMjM5MDJcbiAgICBdKSxcbiAgICAvLyBodHRwczovL2RvY3MuZ29jZC5vcmcvY3VycmVudC9mYXEvZGV2X3VzZV9jdXJyZW50X3JldmlzaW9uX2luX2J1aWxkLmh0bWwjc3RhbmRhcmQtZ29jZC1lbnZpcm9ubWVudC12YXJpYWJsZXNcbiAgICBnb0NEOiBleHRyYWN0KFtcbiAgICAgIFwiR09fU0VSVkVSX1VSTFwiLFxuICAgICAgXCJHT19FTlZJUk9OTUVOVF9OQU1FXCIsXG4gICAgICBcIkdPX1BJUEVMSU5FX05BTUVcIixcbiAgICAgIFwiR09fUElQRUxJTkVfQ09VTlRFUlwiLFxuICAgICAgXCJHT19QSVBFTElORV9MQUJFTFwiLFxuICAgICAgXCJHT19TVEFHRV9OQU1FXCIsXG4gICAgICBcIkdPX1NUQUdFX0NPVU5URVJcIixcbiAgICAgIFwiR09fSk9CX05BTUVcIixcbiAgICAgIFwiR09fVFJJR0dFUl9VU0VSXCIsXG4gICAgICBcIkdPX1JFVklTSU9OXCIsXG4gICAgICBcIkdPX1RPX1JFVklTSU9OXCIsXG4gICAgICBcIkdPX0ZST01fUkVWSVNJT05cIixcbiAgICAgIFwiR09fTUFURVJJQUxfSEFTX0NIQU5HRURcIixcbiAgICBdKSxcbiAgICBnb29nbGVDbG91ZDogZXh0cmFjdChbXG4gICAgICAvLyBpbmRpdmlkdWFsIGpvYnNcbiAgICAgIFwiQlVJTERfSURcIixcbiAgICAgIFwiUFJPSkVDVF9JRFwiLFxuICAgICAgLy8gb3RoZXIgaW5mb3JtYXRpb25cbiAgICAgIFwiUkVQT19OQU1FXCIsXG4gICAgICBcIkJSQU5DSF9OQU1FXCIsXG4gICAgICBcIlRBR19OQU1FXCIsXG4gICAgICBcIkNPTU1JVF9TSEFcIixcbiAgICAgIFwiU0hPUlRfU0hBXCIsXG4gICAgICAvLyBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vY2xvdWQtYnVpbGQvZG9jcy9hcGkvcmVmZXJlbmNlL3Jlc3QvU2hhcmVkLlR5cGVzL0J1aWxkXG4gICAgXSksXG4gICAgamVua2luczogZXh0cmFjdChbXCJCVUlMRF9JRFwiLCBcIkJVSUxEX1VSTFwiLCBcIkJVSUxEX05VTUJFUlwiLCBcImdocHJiUHVsbElkXCJdKSxcbiAgICAvLyBodHRwczovL3NlbWFwaG9yZWNpLmNvbS9kb2NzL2F2YWlsYWJsZS1lbnZpcm9ubWVudC12YXJpYWJsZXMuaHRtbFxuICAgIC8vIHNvbWUgY29tZSBmcm9tIHYxLCBzb21lIGZyb20gdjIgb2Ygc2VtYXBob3JlXG4gICAgc2VtYXBob3JlOiBleHRyYWN0KFtcbiAgICAgIFwiU0VNQVBIT1JFX0JSQU5DSF9JRFwiLFxuICAgICAgXCJTRU1BUEhPUkVfQlVJTERfTlVNQkVSXCIsXG4gICAgICBcIlNFTUFQSE9SRV9DVVJSRU5UX0pPQlwiLFxuICAgICAgXCJTRU1BUEhPUkVfQ1VSUkVOVF9USFJFQURcIixcbiAgICAgIFwiU0VNQVBIT1JFX0VYRUNVVEFCTEVfVVVJRFwiLFxuICAgICAgXCJTRU1BUEhPUkVfR0lUX0JSQU5DSFwiLFxuICAgICAgXCJTRU1BUEhPUkVfR0lUX0RJUlwiLFxuICAgICAgXCJTRU1BUEhPUkVfR0lUX1JFRlwiLFxuICAgICAgXCJTRU1BUEhPUkVfR0lUX1JFRl9UWVBFXCIsXG4gICAgICBcIlNFTUFQSE9SRV9HSVRfUkVQT19TTFVHXCIsXG4gICAgICBcIlNFTUFQSE9SRV9HSVRfU0hBXCIsXG4gICAgICBcIlNFTUFQSE9SRV9HSVRfVVJMXCIsXG4gICAgICBcIlNFTUFQSE9SRV9KT0JfQ09VTlRcIixcbiAgICAgIFwiU0VNQVBIT1JFX0pPQl9JRFwiLCAvLyB2MlxuICAgICAgXCJTRU1BUEhPUkVfSk9CX05BTUVcIixcbiAgICAgIFwiU0VNQVBIT1JFX0pPQl9VVUlEXCIsIC8vIHYxXG4gICAgICBcIlNFTUFQSE9SRV9QSVBFTElORV9JRFwiLFxuICAgICAgXCJTRU1BUEhPUkVfUExBVEZPUk1cIixcbiAgICAgIFwiU0VNQVBIT1JFX1BST0pFQ1RfRElSXCIsXG4gICAgICBcIlNFTUFQSE9SRV9QUk9KRUNUX0hBU0hfSURcIixcbiAgICAgIFwiU0VNQVBIT1JFX1BST0pFQ1RfSURcIiwgLy8gdjJcbiAgICAgIFwiU0VNQVBIT1JFX1BST0pFQ1RfTkFNRVwiLFxuICAgICAgXCJTRU1BUEhPUkVfUFJPSkVDVF9VVUlEXCIsIC8vIHYxXG4gICAgICBcIlNFTUFQSE9SRV9SRVBPX1NMVUdcIixcbiAgICAgIFwiU0VNQVBIT1JFX1RSSUdHRVJfU09VUkNFXCIsXG4gICAgICBcIlNFTUFQSE9SRV9XT1JLRkxPV19JRFwiLFxuICAgICAgXCJQVUxMX1JFUVVFU1RfTlVNQkVSXCIsIC8vIHB1bGwgcmVxdWVzdHMgZnJvbSBmb3JrcyBPTkxZXG4gICAgXSksXG4gICAgLy8gc2VlIGh0dHA6Ly9kb2NzLnNoaXBwYWJsZS5jb20vY2kvZW52LXZhcnMvXG4gICAgc2hpcHBhYmxlOiBleHRyYWN0KFtcbiAgICAgIC8vIGJ1aWxkIHZhcmlhYmxlc1xuICAgICAgXCJTSElQUEFCTEVfQlVJTERfSURcIiwgLy8gXCI1YjkzMzU0Y2FiZmFiYjA3MDA3ZjAxZmRcIlxuICAgICAgXCJTSElQUEFCTEVfQlVJTERfTlVNQkVSXCIsIC8vIFwiNFwiXG4gICAgICBcIlNISVBQQUJMRV9DT01NSVRfUkFOR0VcIiwgLy8gXCJzaGExLi4uc2hhMlwiXG4gICAgICBcIlNISVBQQUJMRV9DT05UQUlORVJfTkFNRVwiLCAvLyBcImMuZXhlYy5jeXByZXNzLWV4YW1wbGUta2l0Y2hlbnNpbmsuNC4xXCJcbiAgICAgIFwiU0hJUFBBQkxFX0pPQl9JRFwiLCAvLyBcIjFcIlxuICAgICAgXCJTSElQUEFCTEVfSk9CX05VTUJFUlwiLCAvLyBcIjFcIlxuICAgICAgXCJTSElQUEFCTEVfUkVQT19TTFVHXCIsIC8vIFwiPHVzZXJuYW1lPi88cmVwbz5cIlxuICAgICAgLy8gYWRkaXRpb25hbCBpbmZvcm1hdGlvbiB0aGF0IFNoaXBwYWJsZSBwcm92aWRlc1xuICAgICAgXCJJU19GT1JLXCIsIC8vIFwidHJ1ZVwiXG4gICAgICBcIklTX0dJVF9UQUdcIiwgLy8gXCJmYWxzZVwiXG4gICAgICBcIklTX1BSRVJFTEVBU0VcIiwgLy8gXCJmYWxzZVwiXG4gICAgICBcIklTX1JFTEVBU0VcIiwgLy8gXCJmYWxzZVwiXG4gICAgICBcIlJFUE9TSVRPUllfVVJMXCIsIC8vIFwiaHR0cHM6Ly9naXRodWIuY29tLy4uLi5naXRcIlxuICAgICAgXCJSRVBPX0ZVTExfTkFNRVwiLCAvLyBcIjx1c2VybmFtZT4vPHJlcG8+XCJcbiAgICAgIFwiUkVQT19OQU1FXCIsIC8vIFwiY3lwcmVzcy1leGFtcGxlLWtpdGNoZW5zaW5rXCJcbiAgICAgIFwiQlVJTERfVVJMXCIsIC8vIFwiaHR0cHM6Ly9hcHAuc2hpcHBhYmxlLmNvbS9naXRodWIvPHVzZXJuYW1lPi88cmVwbz4vcnVucy8xXCJcbiAgICAgIC8vIFB1bGwgcmVxdWVzdCBpbmZvcm1hdGlvblxuICAgICAgXCJCQVNFX0JSQU5DSFwiLCAvLyBOYW1lIG9mIHRoZSB0YXJnZXQgYnJhbmNoIGludG8gd2hpY2ggdGhlIHB1bGwgcmVxdWVzdCBjaGFuZ2VzIHdpbGwgYmUgbWVyZ2VkLlxuICAgICAgXCJIRUFEX0JSQU5DSFwiLCAvLyBUaGlzIGlzIG9ubHkgc2V0IGZvciBwdWxsIHJlcXVlc3RzIGFuZCBpcyB0aGUgbmFtZSBvZiB0aGUgYnJhbmNoIHRoZSBwdWxsIHJlcXVlc3Qgd2FzIG9wZW5lZCBmcm9tLlxuICAgICAgXCJJU19QVUxMX1JFUVVFU1RcIiwgLy8gXCJmYWxzZVwiIG9yIFwidHJ1ZVwiXG4gICAgICBcIlBVTExfUkVRVUVTVFwiLCAvLyBQdWxsIHJlcXVlc3QgbnVtYmVyIGlmIHRoZSBqb2IgaXMgYSBwdWxsIHJlcXVlc3QuIElmIG5vdCwgdGhpcyB3aWxsIGJlIHNldCB0byBmYWxzZS5cbiAgICAgIFwiUFVMTF9SRVFVRVNUX0JBU0VfQlJBTkNIXCIsIC8vIE5hbWUgb2YgdGhlIGJyYW5jaCB0aGF0IHRoZSBwdWxsIHJlcXVlc3Qgd2lsbCBiZSBtZXJnZWQgaW50by4gSXQgc2hvdWxkIGJlIHRoZSBzYW1lIGFzIEJBU0VfQlJBTkNILlxuICAgICAgXCJQVUxMX1JFUVVFU1RfUkVQT19GVUxMX05BTUVcIiwgLy8gRnVsbCBuYW1lIG9mIHRoZSByZXBvc2l0b3J5IGZyb20gd2hlcmUgdGhlIHB1bGwgcmVxdWVzdCBvcmlnaW5hdGVkLlxuICAgIF0pLFxuICAgIHRlYW1jaXR5OiBudWxsLFxuICAgIHRlYW1mb3VuZGF0aW9uOiBleHRyYWN0KFtcbiAgICAgIFwiQlVJTERfQlVJTERJRFwiLFxuICAgICAgXCJCVUlMRF9CVUlMRE5VTUJFUlwiLFxuICAgICAgXCJCVUlMRF9DT05UQUlORVJJRFwiLFxuICAgIF0pLFxuICAgIHRyYXZpczogZXh0cmFjdChbXG4gICAgICBcIlRSQVZJU19KT0JfSURcIixcbiAgICAgIFwiVFJBVklTX0JVSUxEX0lEXCIsXG4gICAgICBcIlRSQVZJU19CVUlMRF9XRUJfVVJMXCIsXG4gICAgICBcIlRSQVZJU19SRVBPX1NMVUdcIixcbiAgICAgIFwiVFJBVklTX0pPQl9OVU1CRVJcIixcbiAgICAgIFwiVFJBVklTX0VWRU5UX1RZUEVcIixcbiAgICAgIFwiVFJBVklTX0NPTU1JVF9SQU5HRVwiLFxuICAgICAgXCJUUkFWSVNfQlVJTERfTlVNQkVSXCIsXG4gICAgICBcIlRSQVZJU19QVUxMX1JFUVVFU1RcIixcbiAgICAgIFwiVFJBVklTX1BVTExfUkVRVUVTVF9CUkFOQ0hcIixcbiAgICAgIFwiVFJBVklTX1BVTExfUkVRVUVTVF9TSEFcIixcbiAgICBdKSxcbiAgICB3ZXJja2VyOiBudWxsLFxuICAgIC8vIGh0dHBzOi8vZG9jcy5uZXRsaWZ5LmNvbS9jb25maWd1cmUtYnVpbGRzL2Vudmlyb25tZW50LXZhcmlhYmxlcy8jZGVwbG95LXVybHMtYW5kLW1ldGFkYXRhXG4gICAgbmV0bGlmeTogZXh0cmFjdChbXG4gICAgICBcIkJVSUxEX0lEXCIsXG4gICAgICBcIkNPTlRFWFRcIixcbiAgICAgIFwiVVJMXCIsXG4gICAgICBcIkRFUExPWV9VUkxcIixcbiAgICAgIFwiREVQTE9ZX1BSSU1FX1VSTFwiLFxuICAgICAgXCJERVBMT1lfSURcIixcbiAgICBdKSxcbiAgICAvLyBodHRwczovL2xheWVyY2kuY29tL2RvY3MvbGF5ZXJmaWxlLXJlZmVyZW5jZS9idWlsZC1lbnZcbiAgICBsYXllcmNpOiBleHRyYWN0KFtcbiAgICAgIFwiTEFZRVJDSV9KT0JfSURcIixcbiAgICAgIFwiTEFZRVJDSV9SVU5ORVJfSURcIixcbiAgICAgIFwiUkVUUllfSU5ERVhcIixcbiAgICAgIFwiTEFZRVJDSV9QVUxMX1JFUVVFU1RcIixcbiAgICAgIFwiTEFZRVJDSV9SRVBPX05BTUVcIixcbiAgICAgIFwiTEFZRVJDSV9SRVBPX09XTkVSXCIsXG4gICAgICBcIkxBWUVSQ0lfQlJBTkNIXCIsXG4gICAgICBcIkdJVF9UQUdcIiwgLy8gc2hvcnQgaGV4IGZvciBjb21taXRzXG4gICAgXSksXG4gIH07XG59O1xuXG4vLyB0cmllcyB0byBncmFiIGNvbW1pdCBpbmZvcm1hdGlvbiBmcm9tIENJIGVudmlyb25tZW50IHZhcmlhYmxlc1xuLy8gdmVyeSB1c2VmdWwgdG8gZmlsbCBtaXNzaW5nIGluZm9ybWF0aW9uIHdoZW4gR2l0IGNhbm5vdCBncmFiIGNvcnJlY3QgdmFsdWVzXG5jb25zdCBfcHJvdmlkZXJDb21taXRQYXJhbXMgPSAoKTogUHJvdmlkZXJDb21taXRQYXJhbXNSZXMgPT4ge1xuICBjb25zdCB7IGVudiB9ID0gcHJvY2VzcztcblxuICByZXR1cm4ge1xuICAgIGFwcHZleW9yOiB7XG4gICAgICBzaGE6IGVudi5BUFBWRVlPUl9SRVBPX0NPTU1JVCxcbiAgICAgIC8vIHNpbmNlIEFQUFZFWU9SX1JFUE9fQlJBTkNIIHdpbGwgYmUgdGhlIHRhcmdldCBicmFuY2ggb24gYSBQUlxuICAgICAgLy8gd2UgbmVlZCB0byB1c2UgUFVMTF9SRVFVRVNUX0hFQURfUkVQT19CUkFOQ0ggaWYgaXQgZXhpc3RzLlxuICAgICAgLy8gZS5nLiBpZiB5b3UgaGF2ZSBhIFBSOiBkZXZlbG9wIDwtIG15LWZlYXR1cmUtYnJhbmNoXG4gICAgICAvLyBteS1mZWF0dXJlLWJyYW5jaCBpcyBBUFBWRVlPUl9QVUxMX1JFUVVFU1RfSEVBRF9SRVBPX0JSQU5DSFxuICAgICAgLy8gZGV2ZWxvcCAgICAgICAgICAgaXMgQVBQVkVZT1JfUkVQT19CUkFOQ0hcbiAgICAgIGJyYW5jaDpcbiAgICAgICAgZW52LkFQUFZFWU9SX1BVTExfUkVRVUVTVF9IRUFEX1JFUE9fQlJBTkNIIHx8IGVudi5BUFBWRVlPUl9SRVBPX0JSQU5DSCxcbiAgICAgIG1lc3NhZ2U6IGpvaW4oXG4gICAgICAgIFwiXFxuXCIsXG4gICAgICAgIGVudi5BUFBWRVlPUl9SRVBPX0NPTU1JVF9NRVNTQUdFLFxuICAgICAgICBlbnYuQVBQVkVZT1JfUkVQT19DT01NSVRfTUVTU0FHRV9FWFRFTkRFRFxuICAgICAgKSxcbiAgICAgIGF1dGhvck5hbWU6IGVudi5BUFBWRVlPUl9SRVBPX0NPTU1JVF9BVVRIT1IsXG4gICAgICBhdXRob3JFbWFpbDogZW52LkFQUFZFWU9SX1JFUE9fQ09NTUlUX0FVVEhPUl9FTUFJTCxcbiAgICAgIC8vIHJlbW90ZU9yaWdpbjogPz8/XG4gICAgICAvLyBkZWZhdWx0QnJhbmNoOiA/Pz9cbiAgICB9LFxuICAgIGF3c0NvZGVCdWlsZDoge1xuICAgICAgc2hhOiBlbnYuQ09ERUJVSUxEX1JFU09MVkVEX1NPVVJDRV9WRVJTSU9OLFxuICAgICAgLy8gYnJhbmNoOiA/Pz8sXG4gICAgICAvLyBtZXNzYWdlOiA/Pz9cbiAgICAgIC8vIGF1dGhvck5hbWU6ID8/P1xuICAgICAgLy8gYXV0aG9yRW1haWw6ID8/P1xuICAgICAgcmVtb3RlT3JpZ2luOiBlbnYuQ09ERUJVSUxEX1NPVVJDRV9SRVBPX1VSTCxcbiAgICAgIC8vIGRlZmF1bHRCcmFuY2g6ID8/P1xuICAgIH0sXG4gICAgYXp1cmU6IHtcbiAgICAgIHNoYTogZW52LkJVSUxEX1NPVVJDRVZFUlNJT04sXG4gICAgICBicmFuY2g6IGVudi5CVUlMRF9TT1VSQ0VCUkFOQ0hOQU1FLFxuICAgICAgbWVzc2FnZTogZW52LkJVSUxEX1NPVVJDRVZFUlNJT05NRVNTQUdFLFxuICAgICAgYXV0aG9yTmFtZTogZW52LkJVSUxEX1NPVVJDRVZFUlNJT05BVVRIT1IsXG4gICAgICBhdXRob3JFbWFpbDogZW52LkJVSUxEX1JFUVVFU1RFREZPUkVNQUlMLFxuICAgIH0sXG4gICAgYmFtYm9vOiB7XG4gICAgICBzaGE6IGVudi5iYW1ib29fcGxhblJlcG9zaXRvcnlfcmV2aXNpb24sXG4gICAgICBicmFuY2g6IGVudi5iYW1ib29fcGxhblJlcG9zaXRvcnlfYnJhbmNoLFxuICAgICAgLy8gbWVzc2FnZTogPz8/XG4gICAgICBhdXRob3JOYW1lOiBlbnYuYmFtYm9vX3BsYW5SZXBvc2l0b3J5X3VzZXJuYW1lLFxuICAgICAgLy8gYXV0aG9yRW1haWw6ID8/P1xuICAgICAgcmVtb3RlT3JpZ2luOiBlbnYuYmFtYm9vX3BsYW5SZXBvc2l0b3J5X3JlcG9zaXRvcnlVUkwsXG4gICAgICAvLyBkZWZhdWx0QnJhbmNoOiA/Pz9cbiAgICB9LFxuICAgIGJpdGJ1Y2tldDoge1xuICAgICAgc2hhOiBlbnYuQklUQlVDS0VUX0NPTU1JVCxcbiAgICAgIGJyYW5jaDogZW52LkJJVEJVQ0tFVF9CUkFOQ0gsXG4gICAgICAvLyBtZXNzYWdlOiA/Pz9cbiAgICAgIC8vIGF1dGhvck5hbWU6ID8/P1xuICAgICAgLy8gYXV0aG9yRW1haWw6ID8/P1xuICAgICAgLy8gcmVtb3RlT3JpZ2luOiA/Pz9cbiAgICAgIC8vIGRlZmF1bHRCcmFuY2g6ID8/P1xuICAgIH0sXG4gICAgYnVpbGRraXRlOiB7XG4gICAgICBzaGE6IGVudi5CVUlMREtJVEVfQ09NTUlULFxuICAgICAgYnJhbmNoOiBlbnYuQlVJTERLSVRFX0JSQU5DSCxcbiAgICAgIG1lc3NhZ2U6IGVudi5CVUlMREtJVEVfTUVTU0FHRSxcbiAgICAgIGF1dGhvck5hbWU6IGVudi5CVUlMREtJVEVfQlVJTERfQ1JFQVRPUixcbiAgICAgIGF1dGhvckVtYWlsOiBlbnYuQlVJTERLSVRFX0JVSUxEX0NSRUFUT1JfRU1BSUwsXG4gICAgICByZW1vdGVPcmlnaW46IGVudi5CVUlMREtJVEVfUkVQTyxcbiAgICAgIGRlZmF1bHRCcmFuY2g6IGVudi5CVUlMREtJVEVfUElQRUxJTkVfREVGQVVMVF9CUkFOQ0gsXG4gICAgfSxcbiAgICBjaXJjbGU6IHtcbiAgICAgIHNoYTogZW52LkNJUkNMRV9TSEExLFxuICAgICAgYnJhbmNoOiBlbnYuQ0lSQ0xFX0JSQU5DSCxcbiAgICAgIC8vIG1lc3NhZ2U6ID8/P1xuICAgICAgYXV0aG9yTmFtZTogZW52LkNJUkNMRV9VU0VSTkFNRSxcbiAgICAgIC8vIGF1dGhvckVtYWlsOiA/Pz9cbiAgICAgIHJlbW90ZU9yaWdpbjogZW52LkNJUkNMRV9SRVBPU0lUT1JZX1VSTCxcbiAgICAgIC8vIGRlZmF1bHRCcmFuY2g6ID8/P1xuICAgIH0sXG4gICAgY29kZXNoaXBCYXNpYzoge1xuICAgICAgc2hhOiBlbnYuQ0lfQ09NTUlUX0lELFxuICAgICAgYnJhbmNoOiBlbnYuQ0lfQlJBTkNILFxuICAgICAgbWVzc2FnZTogZW52LkNJX0NPTU1JVF9NRVNTQUdFLFxuICAgICAgYXV0aG9yTmFtZTogZW52LkNJX0NPTU1JVFRFUl9OQU1FLFxuICAgICAgYXV0aG9yRW1haWw6IGVudi5DSV9DT01NSVRURVJfRU1BSUwsXG4gICAgICAvLyByZW1vdGVPcmlnaW46ID8/P1xuICAgICAgLy8gZGVmYXVsdEJyYW5jaDogPz8/XG4gICAgfSxcbiAgICBjb2Rlc2hpcFBybzoge1xuICAgICAgc2hhOiBlbnYuQ0lfQ09NTUlUX0lELFxuICAgICAgYnJhbmNoOiBlbnYuQ0lfQlJBTkNILFxuICAgICAgbWVzc2FnZTogZW52LkNJX0NPTU1JVF9NRVNTQUdFLFxuICAgICAgYXV0aG9yTmFtZTogZW52LkNJX0NPTU1JVFRFUl9OQU1FLFxuICAgICAgYXV0aG9yRW1haWw6IGVudi5DSV9DT01NSVRURVJfRU1BSUwsXG4gICAgICAvLyByZW1vdGVPcmlnaW46ID8/P1xuICAgICAgLy8gZGVmYXVsdEJyYW5jaDogPz8/XG4gICAgfSxcbiAgICBjb2RlRnJlc2g6IHtcbiAgICAgIHNoYTogZW52LkNGX1JFVklTSU9OLFxuICAgICAgYnJhbmNoOiBlbnYuQ0ZfQlJBTkNILFxuICAgICAgbWVzc2FnZTogZW52LkNGX0NPTU1JVF9NRVNTQUdFLFxuICAgICAgYXV0aG9yTmFtZTogZW52LkNGX0NPTU1JVF9BVVRIT1IsXG4gICAgfSxcbiAgICBkcm9uZToge1xuICAgICAgc2hhOiBlbnYuRFJPTkVfQ09NTUlUX1NIQSxcbiAgICAgIC8vIGh0dHBzOi8vZG9jcy5kcm9uZS5pby9waXBlbGluZS9lbnZpcm9ubWVudC9yZWZlcmVuY2UvZHJvbmUtc291cmNlLWJyYW5jaC9cbiAgICAgIGJyYW5jaDogZW52LkRST05FX1NPVVJDRV9CUkFOQ0gsXG4gICAgICBtZXNzYWdlOiBlbnYuRFJPTkVfQ09NTUlUX01FU1NBR0UsXG4gICAgICBhdXRob3JOYW1lOiBlbnYuRFJPTkVfQ09NTUlUX0FVVEhPUixcbiAgICAgIGF1dGhvckVtYWlsOiBlbnYuRFJPTkVfQ09NTUlUX0FVVEhPUl9FTUFJTCxcbiAgICAgIHJlbW90ZU9yaWdpbjogZW52LkRST05FX0dJVF9IVFRQX1VSTCxcbiAgICAgIGRlZmF1bHRCcmFuY2g6IGVudi5EUk9ORV9SRVBPX0JSQU5DSCxcbiAgICB9LFxuICAgIGdpdGh1YkFjdGlvbnM6IHtcbiAgICAgIHNoYTogZW52LkdJVEhVQl9TSEEsXG4gICAgICBicmFuY2g6IGVudi5HSF9CUkFOQ0ggfHwgZW52LkdJVEhVQl9SRUYsXG4gICAgICBkZWZhdWx0QnJhbmNoOiBlbnYuR0lUSFVCX0JBU0VfUkVGLFxuICAgICAgcmVtb3RlQnJhbmNoOiBlbnYuR0lUSFVCX0hFQURfUkVGLFxuICAgICAgcnVuQXR0ZW1wdDogZW52LkdJVEhVQl9SVU5fQVRURU1QVCxcbiAgICB9LFxuICAgIGdpdGxhYjoge1xuICAgICAgc2hhOiBlbnYuQ0lfQ09NTUlUX1NIQSxcbiAgICAgIGJyYW5jaDogZW52LkNJX0NPTU1JVF9SRUZfTkFNRSxcbiAgICAgIG1lc3NhZ2U6IGVudi5DSV9DT01NSVRfTUVTU0FHRSxcbiAgICAgIGF1dGhvck5hbWU6IGVudi5HSVRMQUJfVVNFUl9OQU1FLFxuICAgICAgYXV0aG9yRW1haWw6IGVudi5HSVRMQUJfVVNFUl9FTUFJTCxcbiAgICAgIHJlbW90ZU9yaWdpbjogZW52LkNJX1JFUE9TSVRPUllfVVJMLFxuICAgICAgZGVmYXVsdEJyYW5jaDogZW52LkNJX0RFRkFVTFRfQlJBTkNILFxuICAgIH0sXG4gICAgZ29vZ2xlQ2xvdWQ6IHtcbiAgICAgIHNoYTogZW52LkNPTU1JVF9TSEEsXG4gICAgICBicmFuY2g6IGVudi5CUkFOQ0hfTkFNRSxcbiAgICAgIC8vIG1lc3NhZ2U6ID8/XG4gICAgICAvLyBhdXRob3JOYW1lOiA/P1xuICAgICAgLy8gYXV0aG9yRW1haWw6ID8/XG4gICAgICAvLyByZW1vdGVPcmlnaW46ID8/P1xuICAgICAgLy8gZGVmYXVsdEJyYW5jaDogPz9cbiAgICB9LFxuICAgIGplbmtpbnM6IHtcbiAgICAgIHNoYTogZW52LkdJVF9DT01NSVQsXG4gICAgICBicmFuY2g6IGVudi5HSVRfQlJBTkNILFxuICAgICAgLy8gbWVzc2FnZTogPz8/XG4gICAgICAvLyBhdXRob3JOYW1lOiA/Pz9cbiAgICAgIC8vIGF1dGhvckVtYWlsOiA/Pz9cbiAgICAgIC8vIHJlbW90ZU9yaWdpbjogPz8/XG4gICAgICAvLyBkZWZhdWx0QnJhbmNoOiA/Pz9cbiAgICB9LFxuICAgIC8vIE9ubHkgZnJvbSBmb3Jrcz8gaHR0cHM6Ly9zZW1hcGhvcmVjaS5jb20vZG9jcy9hdmFpbGFibGUtZW52aXJvbm1lbnQtdmFyaWFibGVzLmh0bWxcbiAgICBzZW1hcGhvcmU6IHtcbiAgICAgIHNoYTogZW52LlNFTUFQSE9SRV9HSVRfU0hBLFxuICAgICAgYnJhbmNoOiBlbnYuU0VNQVBIT1JFX0dJVF9CUkFOQ0gsXG4gICAgICAvLyBtZXNzYWdlOiA/Pz9cbiAgICAgIC8vIGF1dGhvck5hbWU6ID8/P1xuICAgICAgLy8gYXV0aG9yRW1haWw6ID8/P1xuICAgICAgcmVtb3RlT3JpZ2luOiBlbnYuU0VNQVBIT1JFX0dJVF9SRVBPX1NMVUcsXG4gICAgICAvLyBkZWZhdWx0QnJhbmNoOiA/Pz9cbiAgICB9LFxuICAgIHNoaXBwYWJsZToge1xuICAgICAgc2hhOiBlbnYuQ09NTUlULFxuICAgICAgYnJhbmNoOiBlbnYuQlJBTkNILFxuICAgICAgbWVzc2FnZTogZW52LkNPTU1JVF9NRVNTQUdFLFxuICAgICAgYXV0aG9yTmFtZTogZW52LkNPTU1JVFRFUixcbiAgICAgIC8vIGF1dGhvckVtYWlsOiA/Pz9cbiAgICAgIC8vIHJlbW90ZU9yaWdpbjogPz8/XG4gICAgICAvLyBkZWZhdWx0QnJhbmNoOiA/Pz9cbiAgICB9LFxuICAgIHNuYXA6IG51bGwsXG4gICAgdGVhbWNpdHk6IG51bGwsXG4gICAgdGVhbWZvdW5kYXRpb246IHtcbiAgICAgIHNoYTogZW52LkJVSUxEX1NPVVJDRVZFUlNJT04sXG4gICAgICBicmFuY2g6IGVudi5CVUlMRF9TT1VSQ0VCUkFOQ0hOQU1FLFxuICAgICAgbWVzc2FnZTogZW52LkJVSUxEX1NPVVJDRVZFUlNJT05NRVNTQUdFLFxuICAgICAgYXV0aG9yTmFtZTogZW52LkJVSUxEX1NPVVJDRVZFUlNJT05BVVRIT1IsXG4gICAgfSxcbiAgICB0cmF2aXM6IHtcbiAgICAgIHNoYTogZW52LlRSQVZJU19QVUxMX1JFUVVFU1RfU0hBIHx8IGVudi5UUkFWSVNfQ09NTUlULFxuICAgICAgLy8gZm9yIFBScywgVFJBVklTX0JSQU5DSCBpcyB0aGUgYmFzZSBicmFuY2ggYmVpbmcgbWVyZ2VkIGludG9cbiAgICAgIGJyYW5jaDogZW52LlRSQVZJU19QVUxMX1JFUVVFU1RfQlJBTkNIIHx8IGVudi5UUkFWSVNfQlJBTkNILFxuICAgICAgLy8gYXV0aG9yTmFtZTogPz8/XG4gICAgICAvLyBhdXRob3JFbWFpbDogPz8/XG4gICAgICBtZXNzYWdlOiBlbnYuVFJBVklTX0NPTU1JVF9NRVNTQUdFLFxuICAgICAgLy8gcmVtb3RlT3JpZ2luOiA/Pz9cbiAgICAgIC8vIGRlZmF1bHRCcmFuY2g6ID8/P1xuICAgIH0sXG4gICAgd2VyY2tlcjogbnVsbCxcbiAgICBuZXRsaWZ5OiB7XG4gICAgICBzaGE6IGVudi5DT01NSVRfUkVGLFxuICAgICAgYnJhbmNoOiBlbnYuQlJBTkNILFxuICAgICAgcmVtb3RlT3JpZ2luOiBlbnYuUkVQT1NJVE9SWV9VUkwsXG4gICAgfSxcbiAgICBsYXllcmNpOiB7XG4gICAgICBzaGE6IGVudi5HSVRfQ09NTUlULFxuICAgICAgYnJhbmNoOiBlbnYuTEFZRVJDSV9CUkFOQ0gsXG4gICAgICBtZXNzYWdlOiBlbnYuR0lUX0NPTU1JVF9USVRMRSxcbiAgICB9LFxuICB9O1xufTtcblxudHlwZSBDaVByb3ZpZGVyRGF0YSA9IHtcbiAgc2hhPzogc3RyaW5nO1xuICBicmFuY2g/OiBzdHJpbmc7XG4gIG1lc3NhZ2U/OiBzdHJpbmc7XG4gIGF1dGhvck5hbWU/OiBzdHJpbmc7XG4gIGF1dGhvckVtYWlsPzogc3RyaW5nO1xuICByZW1vdGVPcmlnaW4/OiBzdHJpbmc7XG4gIGRlZmF1bHRCcmFuY2g/OiBzdHJpbmc7XG4gIHJlbW90ZUJyYW5jaD86IHN0cmluZztcbiAgcnVuQXR0ZW1wdD86IHN0cmluZztcbn07XG5cbmludGVyZmFjZSBQcm92aWRlckNvbW1pdFBhcmFtc1JlcyB7XG4gIFtrZXk6IHN0cmluZ106IENpUHJvdmlkZXJEYXRhIHwgbnVsbDtcbn1cblxuaW50ZXJmYWNlIFByb3ZpZGVyQ2lQYXJhbXNSZXMge1xuICBba2V5OiBzdHJpbmddOiB7XG4gICAgW2tleTogc3RyaW5nXTogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICB9IHwgbnVsbDtcbn1cblxuY29uc3QgX2dldCA9IChmbjogKCkgPT4gUHJvdmlkZXJDb21taXRQYXJhbXNSZXMgfCBQcm92aWRlckNpUGFyYW1zUmVzKSA9PiB7XG4gIGNvbnN0IHByb3ZpZGVyTmFtZSA9IGdldENpUHJvdmlkZXIoKTtcbiAgaWYgKCFwcm92aWRlck5hbWUpIHJldHVybiB7fTtcblxuICByZXR1cm4gXy5jaGFpbihmbigpKS5nZXQocHJvdmlkZXJOYW1lKS52YWx1ZSgpO1xufTtcblxuLyoqXG4gKiBJZiB0aGVyZSBpcyBubyBidWlsZCBJRCBzcGVjaWZpY2FsbHkgcHJvdmlkZWQgYnkgdXNlclxuICogQ2hlY2sgaWYgd2UgY2FuIGZldGNoIGl0IGF1dG9tYXRpY2FsbHkgZnJvbSBDSSB2YXJpYWJsZXMuXG4gKiBUaGUgcHJvY2VzcyB3aWxsIHN0b3AgaWYgd2UgY2Fubm90IGRvIGl0XG4gKiBodHRwczovL2RvY3MuY3lwcmVzcy5pby9ndWlkZXMvcmVmZXJlbmNlcy9lcnJvci1tZXNzYWdlcyNXZS1jb3VsZC1ub3QtZGV0ZXJtaW5lLWEtdW5pcXVlLUNJLWJ1aWxkLUlEXG4gKi9cbmZ1bmN0aW9uIGNoZWNrRm9yQ2lCdWlsZEZyb21DaShjaVByb3ZpZGVyOiBzdHJpbmcgfCBudWxsKSB7XG4gIGlmIChjaVByb3ZpZGVyICYmIGRldGVjdGFibGVDaUJ1aWxkSWRQcm92aWRlcnMoKS5pbmNsdWRlcyhjaVByb3ZpZGVyKSlcbiAgICByZXR1cm4gdHJ1ZTtcblxuICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFxuICAgIGBDb3VsZCBub3QgZGV0ZXJtaW5lIENJIGJ1aWxkIElEIGZyb20gdGhlIGVudmlyb25tZW50LiBQbGVhc2UgcHJvdmlkZSBhIHVuaXF1ZSBDSSBidWlsZCBJRCB1c2luZyB0aGUgLS1jaS1idWlsZC1pZCBDTEkgZmxhZyBvciAnY2lCdWlsZElkJyBwYXJhbWV0ZXIgZm9yICdydW4nIG1ldGhvZC5gXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsaXN0KCkge1xuICByZXR1cm4gXy5rZXlzKENJX1BST1ZJREVSUyk7XG59XG5cbi8vIGdyYWIgYWxsIGRldGVjdGFibGUgcHJvdmlkZXJzXG4vLyB0aGF0IHdlIGNhbiBleHRyYWN0IGNpQnVpbGRJZCBmcm9tXG5leHBvcnQgZnVuY3Rpb24gZGV0ZWN0YWJsZUNpQnVpbGRJZFByb3ZpZGVycygpIHtcbiAgcmV0dXJuIF8uY2hhaW4oX3Byb3ZpZGVyQ2lQYXJhbXMoKSkub21pdEJ5KF8uaXNOdWxsKS5rZXlzKCkudmFsdWUoKTtcbn1cblxuZXhwb3J0IHR5cGUgQ2lQcm92aWRlciA9IHN0cmluZyB8IG51bGw7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDaVByb3ZpZGVyKCk6IENpUHJvdmlkZXIge1xuICByZXR1cm4gX2RldGVjdFByb3ZpZGVyTmFtZSgpIHx8IG51bGw7XG59XG5cbmV4cG9ydCB0eXBlIENpUGFyYW1zID0ge1xuICBba2V5OiBzdHJpbmddOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2lQYXJhbXMoKSB7XG4gIHJldHVybiBfZ2V0KF9wcm92aWRlckNpUGFyYW1zKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldENvbW1pdFBhcmFtcygpIHtcbiAgcmV0dXJuIF9nZXQoX3Byb3ZpZGVyQ29tbWl0UGFyYW1zKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldENJKGNpQnVpbGRJZD86IHN0cmluZykge1xuICBjb25zdCBwYXJhbXMgPSBnZXRDaVBhcmFtcygpO1xuICBjb25zdCBwcm92aWRlciA9IGdldENpUHJvdmlkZXIoKTtcbiAgaWYgKCFjaUJ1aWxkSWQpIGNoZWNrRm9yQ2lCdWlsZEZyb21DaShwcm92aWRlcik7XG5cbiAgZGVidWcoXCJkZXRlY3RlZCBDSSBwcm92aWRlcjogJXNcIiwgcHJvdmlkZXIpO1xuICBkZWJ1ZyhcImRldGVjdGVkIENJIHBhcmFtczogJU9cIiwgcGFyYW1zKTtcbiAgcmV0dXJuIHtcbiAgICBwYXJhbXMsXG4gICAgcHJvdmlkZXIsXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb21taXREZWZhdWx0cyhleGlzdGluZ0luZm86IENpUHJvdmlkZXJEYXRhKSB7XG4gIGRlYnVnKFwiZ2l0IGNvbW1pdCBleGlzdGluZyBpbmZvXCIpO1xuICBkZWJ1ZyhleGlzdGluZ0luZm8pO1xuXG4gIGNvbnN0IGNvbW1pdFBhcmFtc09iaiA9IGdldENvbW1pdFBhcmFtcygpO1xuXG4gIGRlYnVnKFwiY29tbWl0IGluZm8gZnJvbSBwcm92aWRlciBlbnZpcm9ubWVudCB2YXJpYWJsZXM6ICVPXCIsIGNvbW1pdFBhcmFtc09iaik7XG5cbiAgLy8gYmFzZWQgb24gdGhlIGV4aXN0aW5nSW5mbyBwcm9wZXJ0aWVzXG4gIC8vIG1lcmdlIGluIHRoZSBjb21taXRQYXJhbXMgaWYgbnVsbCBvciB1bmRlZmluZWRcbiAgLy8gZGVmYXVsdGluZyBiYWNrIHRvIG51bGwgaWYgYWxsIGZhaWxzXG4gIC8vIE5PVEU6IG9ubHkgcHJvcGVydGllcyBkZWZpbmVkIGluIFwiZXhpc3RpbmdJbmZvXCIgd2lsbCBiZSByZXR1cm5lZFxuICBjb25zdCBjb21iaW5lZCA9IF8udHJhbnNmb3JtKFxuICAgIGV4aXN0aW5nSW5mbyxcbiAgICAoXG4gICAgICBtZW1vOiB7IFttZW1vS2V5OiBzdHJpbmddOiBzdHJpbmcgfCBudWxsIH0sXG4gICAgICB2YWx1ZTogc3RyaW5nLFxuICAgICAga2V5OiBzdHJpbmdcbiAgICApID0+IHtcbiAgICAgIHJldHVybiAobWVtb1trZXldID0gXy5kZWZhdWx0VG8odmFsdWUgfHwgY29tbWl0UGFyYW1zT2JqW2tleV0sIG51bGwpKTtcbiAgICB9XG4gICk7XG5cbiAgZGVidWcoXCJjb21iaW5lZCBnaXQgYW5kIGVudmlyb25tZW50IHZhcmlhYmxlcyBmcm9tIHByb3ZpZGVyXCIpO1xuICBkZWJ1Zyhjb21iaW5lZCk7XG5cbiAgcmV0dXJuIGNvbWJpbmVkO1xufVxuIiwgImltcG9ydCBjeXByZXNzIGZyb20gXCJjeXByZXNzXCI7XG5pbXBvcnQge1xuICBDdXJyZW50c1J1blBhcmFtZXRlcnMsXG4gIEN5cHJlc3NSZXN1bHQsXG4gIFZhbGlkYXRlZEN1cnJlbnRzUGFyYW1ldGVycyxcbn0gZnJvbSBcImN5cHJlc3MtY2xvdWQvdHlwZXNcIjtcbmltcG9ydCBEZWJ1ZyBmcm9tIFwiZGVidWdcIjtcbmltcG9ydCBfIGZyb20gXCJsb2Rhc2hcIjtcbmltcG9ydCB7IGdldEN5cHJlc3NSdW5BUElQYXJhbXMgfSBmcm9tIFwiLi4vY29uZmlnXCI7XG5pbXBvcnQgeyBzYWZlIH0gZnJvbSBcIi4uL2xhbmdcIjtcbmltcG9ydCB7IHdhcm4gfSBmcm9tIFwiLi4vbG9nXCI7XG5pbXBvcnQgeyBnZXRXU1NQb3J0IH0gZnJvbSBcIi4uL3dzXCI7XG5cbmNvbnN0IGRlYnVnID0gRGVidWcoXCJjdXJyZW50czpjeXByZXNzXCIpO1xuaW50ZXJmYWNlIFJ1bkN5cHJlc3NTcGVjRmlsZSB7XG4gIHNwZWM6IHN0cmluZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJ1bkJhcmVDeXByZXNzKHBhcmFtczogQ3VycmVudHNSdW5QYXJhbWV0ZXJzID0ge30pIHtcbiAgLy8gcmV2ZXJ0IGN1cnJlbnRzIHBhcmFtcyB0byBjeXByZXNzIHBhcmFtc1xuICAvLyBleGNsdWRlIHJlY29yZCBtb2RlIHBhcmFtc1xuICBjb25zdCBwID0ge1xuICAgIC4uLnBhcmFtcyxcbiAgICBjaUJ1aWxkSWQ6IHVuZGVmaW5lZCxcbiAgICB0YWc6IHVuZGVmaW5lZCxcbiAgICBwYXJhbGxlbDogdW5kZWZpbmVkLFxuICAgIHJlY29yZDogZmFsc2UsXG4gICAgZ3JvdXA6IHVuZGVmaW5lZCxcbiAgICBzcGVjOiBfLmZsYXR0ZW4ocGFyYW1zLnNwZWMpLmpvaW4oXCIsXCIpLFxuICB9O1xuICBkZWJ1ZyhcIlJ1bm5pbmcgYmFyZSBDeXByZXNzIHdpdGggcGFyYW1zICVvXCIsIHApO1xuICByZXR1cm4gY3lwcmVzcy5ydW4ocCk7XG59XG5cbi8qKlxuICogUnVuIEN5cHJlc3MgdGVzdHMsIHdlIG5lZWQgdG8gcGFzcyBkb3duIHRoZSBzdHJpcHBlZCBvcHRpb25zIGFzIGlmIHdlJ3ZlIHJlY2VpdmVkIHRoZW0gZnJvbSB0aGUgQ0xJXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBydW5TcGVjRmlsZShcbiAgeyBzcGVjIH06IFJ1bkN5cHJlc3NTcGVjRmlsZSxcbiAgY3lwcmVzc1J1bk9wdGlvbnM6IFZhbGlkYXRlZEN1cnJlbnRzUGFyYW1ldGVyc1xuKSB7XG4gIGNvbnN0IHJ1bkFQSU9wdGlvbnMgPSBnZXRDeXByZXNzUnVuQVBJUGFyYW1zKGN5cHJlc3NSdW5PcHRpb25zKTtcblxuICBjb25zdCBvcHRpb25zID0ge1xuICAgIC4uLnJ1bkFQSU9wdGlvbnMsXG4gICAgY29uZmlnOiB7XG4gICAgICAuLi5ydW5BUElPcHRpb25zLmNvbmZpZyxcbiAgICAgIHRyYXNoQXNzZXRzQmVmb3JlUnVuczogZmFsc2UsXG4gICAgfSxcbiAgICBlbnY6IHtcbiAgICAgIC4uLnJ1bkFQSU9wdGlvbnMuZW52LFxuICAgICAgY3VycmVudHNfd3M6IGdldFdTU1BvcnQoKSxcbiAgICB9LFxuICAgIHNwZWMsXG4gIH07XG4gIGRlYnVnKFwicnVubmluZyBjeXByZXNzIHdpdGggb3B0aW9ucyAlb1wiLCBvcHRpb25zKTtcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY3lwcmVzcy5ydW4ob3B0aW9ucyk7XG5cbiAgaWYgKHJlc3VsdC5zdGF0dXMgPT09IFwiZmFpbGVkXCIpIHtcbiAgICB3YXJuKCdDeXByZXNzIHJ1bm5lciBmYWlsZWQgd2l0aCBtZXNzYWdlOiBcIiVzXCInLCByZXN1bHQubWVzc2FnZSk7XG4gICAgd2FybihcbiAgICAgIFwiVGhlIGZvbGxvd2luZyBzcGVjIGZpbGVzIHdpbGwgYmUgbWFya2VkIGFzIGZhaWxlZDogJXNcIixcbiAgICAgIHNwZWNcbiAgICAgICAgLnNwbGl0KFwiLFwiKVxuICAgICAgICAubWFwKChpKSA9PiBgXFxuIC0gJHtpfWApXG4gICAgICAgIC5qb2luKFwiXCIpXG4gICAgKTtcbiAgfVxuICBkZWJ1ZyhcImN5cHJlc3MgcnVuIHJlc3VsdCAlb1wiLCByZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgY29uc3QgcnVuU3BlY0ZpbGVTYWZlID0gKFxuICBzcGVjOiBSdW5DeXByZXNzU3BlY0ZpbGUsXG4gIGN5cHJlc3NSdW5PcHRpb25zOiBWYWxpZGF0ZWRDdXJyZW50c1BhcmFtZXRlcnNcbik6IFByb21pc2U8Q3lwcmVzc1Jlc3VsdD4gPT5cbiAgc2FmZShcbiAgICBydW5TcGVjRmlsZSxcbiAgICAoZXJyb3IpID0+IHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgQ3lwcmVzcyBydW5ubmVyIGNyYXNoZWQgd2l0aCBhbiBlcnJvcjpcXG4ke1xuICAgICAgICAoZXJyb3IgYXMgRXJyb3IpLm1lc3NhZ2VcbiAgICAgIH1cXG4keyhlcnJvciBhcyBFcnJvcikuc3RhY2t9fWA7XG4gICAgICBkZWJ1ZyhcImN5cHJlc3MgcnVuIGV4Y2VwdGlvbiAlb1wiLCBlcnJvcik7XG4gICAgICB3YXJuKCdDeXByZXNzIHJ1bm5lciBjcmFzaGVkOiBcIiVzXCInLCBtZXNzYWdlKTtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwiVGhlIGZvbGxvd2luZyBzcGVjIGZpbGVzIHdpbGwgYmUgbWFya2VkIGFzIGZhaWxlZDogJXNcIixcbiAgICAgICAgc3BlYy5zcGVjXG4gICAgICAgICAgLnNwbGl0KFwiLFwiKVxuICAgICAgICAgIC5tYXAoKGkpID0+IGBcXG4gLSAke2l9YClcbiAgICAgICAgICAuam9pbihcIlwiKVxuICAgICAgKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXR1czogXCJmYWlsZWRcIiBhcyBjb25zdCxcbiAgICAgICAgZmFpbHVyZXM6IDEsXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICB9O1xuICAgIH0sXG4gICAgKCkgPT4ge31cbiAgKShzcGVjLCBjeXByZXNzUnVuT3B0aW9ucyk7XG4iLCAiaW1wb3J0IGJsdWViaXJkIGZyb20gXCJibHVlYmlyZFwiO1xuXG5ibHVlYmlyZC5Qcm9taXNlLmNvbmZpZyh7XG4gIGNhbmNlbGxhdGlvbjogdHJ1ZSxcbn0pO1xuZXhwb3J0IGNvbnN0IEJQcm9taXNlID0gYmx1ZWJpcmQuUHJvbWlzZTtcblxuZXhwb3J0IGNvbnN0IHNhZmUgPVxuICA8VCBleHRlbmRzIGFueVtdLCBSIGV4dGVuZHMgYW55LCBGIGV4dGVuZHMgYW55PihcbiAgICBmbjogKC4uLmFyZ3M6IFQpID0+IFByb21pc2U8Uj4sXG4gICAgaWZGYWxlZDogKGU6IHVua25vd24pID0+IEYsXG4gICAgaWZTdWNjZWVkOiAoKSA9PiBhbnlcbiAgKSA9PlxuICBhc3luYyAoLi4uYXJnczogVCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByID0gYXdhaXQgZm4oLi4uYXJncyk7XG4gICAgICBpZlN1Y2NlZWQoKTtcbiAgICAgIHJldHVybiByO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBpZkZhbGVkKGUpO1xuICAgIH1cbiAgfTtcbiIsICJpbXBvcnQgZGVidWcgZnJvbSBcImRlYnVnXCI7XG5pbXBvcnQgeyBtYXRjaCwgUCB9IGZyb20gXCJ0cy1wYXR0ZXJuXCI7XG5pbXBvcnQgeyBDdXJyZW50c1J1blBhcmFtZXRlcnMsIERlYnVnTW9kZSB9IGZyb20gXCIuLi8uLi90eXBlc1wiO1xuXG5lbnVtIERlYnVnVG9rZW5zIHtcbiAgQ3VycmVudHMgPSBcImN1cnJlbnRzOipcIixcbiAgQ3lwcmVzcyA9IFwiY3lwcmVzczoqXCIsXG4gIENvbW1pdEluZm8gPSBcImNvbW1pdC1pbmZvXCIsXG59XG5leHBvcnQgZnVuY3Rpb24gYWN0aXZhdGVEZWJ1Zyhtb2RlOiBDdXJyZW50c1J1blBhcmFtZXRlcnNbXCJjbG91ZERlYnVnXCJdKSB7XG4gIG1hdGNoKG1vZGUpXG4gICAgLndpdGgoUC5pbnN0YW5jZU9mKEFycmF5KSwgKGkpID0+IGkuZm9yRWFjaChzZXREZWJ1Z01vZGUpKVxuICAgIC53aXRoKHRydWUsICgpID0+IHNldERlYnVnTW9kZShEZWJ1Z01vZGUuQWxsKSlcbiAgICAud2l0aChcbiAgICAgIFAudW5pb24oXG4gICAgICAgIERlYnVnTW9kZS5BbGwsXG4gICAgICAgIERlYnVnTW9kZS5DdXJyZW50cyxcbiAgICAgICAgRGVidWdNb2RlLkN5cHJlc3MsXG4gICAgICAgIERlYnVnTW9kZS5Db21taXRJbmZvXG4gICAgICApLFxuICAgICAgKGkpID0+IHNldERlYnVnTW9kZShpKVxuICAgIClcbiAgICAub3RoZXJ3aXNlKCgpID0+IHNldERlYnVnTW9kZShEZWJ1Z01vZGUuTm9uZSkpO1xufVxuXG5mdW5jdGlvbiBzZXREZWJ1Z01vZGUobW9kZTogc3RyaW5nKSB7XG4gIGlmIChtb2RlID09PSBEZWJ1Z01vZGUuTm9uZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHRva2VucyA9IG5ldyBTZXQocHJvY2Vzcy5lbnYuREVCVUcgPyBwcm9jZXNzLmVudi5ERUJVRy5zcGxpdChcIixcIikgOiBbXSk7XG4gIG1hdGNoKG1vZGUpXG4gICAgLndpdGgoRGVidWdNb2RlLkFsbCwgKCkgPT4ge1xuICAgICAgdG9rZW5zLmFkZChEZWJ1Z1Rva2Vucy5Db21taXRJbmZvKTtcbiAgICAgIHRva2Vucy5hZGQoRGVidWdUb2tlbnMuQ3VycmVudHMpO1xuICAgICAgdG9rZW5zLmFkZChEZWJ1Z1Rva2Vucy5DeXByZXNzKTtcbiAgICB9KVxuICAgIC53aXRoKERlYnVnTW9kZS5DdXJyZW50cywgKCkgPT4gdG9rZW5zLmFkZChEZWJ1Z1Rva2Vucy5DdXJyZW50cykpXG4gICAgLndpdGgoRGVidWdNb2RlLkN5cHJlc3MsICgpID0+IHRva2Vucy5hZGQoRGVidWdUb2tlbnMuQ3lwcmVzcykpXG4gICAgLndpdGgoRGVidWdNb2RlLkNvbW1pdEluZm8sICgpID0+IHRva2Vucy5hZGQoRGVidWdUb2tlbnMuQ29tbWl0SW5mbykpXG4gICAgLm90aGVyd2lzZSgoKSA9PiB7fSk7XG5cbiAgZGVidWcuZW5hYmxlKEFycmF5LmZyb20odG9rZW5zKS5qb2luKFwiLFwiKSk7XG59XG4iLCAiaW1wb3J0IHsgZ2V0QVBJQmFzZVVybCB9IGZyb20gXCIuL2h0dHBDbGllbnQvY29uZmlnXCI7XG5cbmV4cG9ydCBjb25zdCBpc0N1cnJlbnRzID0gKCkgPT5cbiAgISFwcm9jZXNzLmVudi5DVVJSRU5UU19FTkZPUkNFX0lTX0NVUlJFTlRTIHx8XG4gIGdldEFQSUJhc2VVcmwoKSA9PT0gXCJodHRwczovL2N5LmN1cnJlbnRzLmRldlwiO1xuIiwgIi8vIEB0cy1pZ25vcmVcbmltcG9ydCBnaXQgZnJvbSBcIkBjeXByZXNzL2NvbW1pdC1pbmZvXCI7XG5pbXBvcnQgeyBnZXRDb21taXREZWZhdWx0cyB9IGZyb20gXCIuL2NpUHJvdmlkZXJcIjtcblxuZXhwb3J0IGNvbnN0IGdldEdpdEluZm8gPSBhc3luYyAocHJvamVjdFJvb3Q6IHN0cmluZykgPT4ge1xuICBjb25zdCBjb21taXRJbmZvID0gYXdhaXQgZ2l0LmNvbW1pdEluZm8ocHJvamVjdFJvb3QpO1xuICByZXR1cm4gZ2V0Q29tbWl0RGVmYXVsdHMoe1xuICAgIGJyYW5jaDogY29tbWl0SW5mby5icmFuY2gsXG4gICAgcmVtb3RlT3JpZ2luOiBjb21taXRJbmZvLnJlbW90ZSxcbiAgICBhdXRob3JFbWFpbDogY29tbWl0SW5mby5lbWFpbCxcbiAgICBhdXRob3JOYW1lOiBjb21taXRJbmZvLmF1dGhvcixcbiAgICBtZXNzYWdlOiBjb21taXRJbmZvLm1lc3NhZ2UsXG4gICAgc2hhOiBjb21taXRJbmZvLnNoYSxcbiAgfSk7XG59O1xuIiwgImltcG9ydCBEZWJ1ZyBmcm9tIFwiZGVidWdcIjtcbmltcG9ydCB7IERldGVjdGVkQnJvd3NlciwgUGxhdGZvcm0gfSBmcm9tIFwiLi4vLi4vdHlwZXNcIjtcbmltcG9ydCB7IHdhcm4gfSBmcm9tIFwiLi4vbG9nXCI7XG5cbmNvbnN0IGRlYnVnID0gRGVidWcoXCJjdXJyZW50czpicm93c2VyXCIpO1xuXG5leHBvcnQgZnVuY3Rpb24gZ3Vlc3NCcm93c2VyKFxuICBicm93c2VyOiBzdHJpbmcsXG4gIGF2YWlsYWJsZUJyb3dzZXJzOiBEZXRlY3RlZEJyb3dzZXJbXSA9IFtdXG4pOiBQaWNrPFBsYXRmb3JtLCBcImJyb3dzZXJOYW1lXCIgfCBcImJyb3dzZXJWZXJzaW9uXCI+IHtcbiAgZGVidWcoXG4gICAgXCJndWVzc2luZyBicm93c2VyIGZyb20gJyVzJywgYXZhaWxhYmxlIGJyb3dzZXJzOiAlb1wiLFxuICAgIGJyb3dzZXIsXG4gICAgYXZhaWxhYmxlQnJvd3NlcnNcbiAgKTtcbiAgLy8gdHJ5IGlkZW50aWZ5aW5nIHRoZSBicm93c2VyIGJ5IG5hbWUgZmlyc3RcbiAgbGV0IHJlc3VsdCA9IGF2YWlsYWJsZUJyb3dzZXJzLmZpbmQoKGIpID0+IGIubmFtZSA9PT0gYnJvd3Nlcik7XG5cbiAgaWYgKHJlc3VsdCkge1xuICAgIGRlYnVnKFwiaWRlbnRpZmllZCBicm93c2VyIGJ5IG5hbWU6ICVvXCIsIHJlc3VsdCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJyb3dzZXJOYW1lOiByZXN1bHQuZGlzcGxheU5hbWUsXG4gICAgICBicm93c2VyVmVyc2lvbjogcmVzdWx0LnZlcnNpb24sXG4gICAgfTtcbiAgfVxuXG4gIC8vIG90aGVyd2lzZSwgdHJ5IGlkZW50aWZ5aW5nIGJ5IHRoZSBwYXRoXG4gIHJlc3VsdCA9IGF2YWlsYWJsZUJyb3dzZXJzLmZpbmQoKGIpID0+IGIucGF0aCA9PT0gYnJvd3Nlcik7XG4gIGlmIChyZXN1bHQpIHtcbiAgICBkZWJ1ZyhcImlkZW50aWZpZWQgYnJvd3NlciBieSBwYXRoOiAlb1wiLCByZXN1bHQpO1xuICAgIHJldHVybiB7XG4gICAgICBicm93c2VyTmFtZTogcmVzdWx0LmRpc3BsYXlOYW1lID8/IHJlc3VsdC5uYW1lLFxuICAgICAgYnJvd3NlclZlcnNpb246IHJlc3VsdC52ZXJzaW9uLFxuICAgIH07XG4gIH1cblxuICB3YXJuKFwiVW5hYmxlIHRvIGlkZW50aWZ5IGJyb3dzZXIgbmFtZSBhbmQgdmVyc2lvblwiKTtcblxuICAvLyBvdGhlcndpc2UsIHJldHVybiBkdW1teSBicm93c2VyXG4gIHJldHVybiB7XG4gICAgYnJvd3Nlck5hbWU6IFwidW5rbm93blwiLFxuICAgIGJyb3dzZXJWZXJzaW9uOiBcInVua25vd25cIixcbiAgfTtcbn1cbiIsICJpbXBvcnQgRGVidWcgZnJvbSBcImRlYnVnXCI7XG5pbXBvcnQgZ2V0b3MgZnJvbSBcImdldG9zXCI7XG5pbXBvcnQgeyBjcHVzLCBmcmVlbWVtLCBwbGF0Zm9ybSwgcmVsZWFzZSwgdG90YWxtZW0gfSBmcm9tIFwib3NcIjtcbmltcG9ydCB7IHByb21pc2lmeSB9IGZyb20gXCJ1dGlsXCI7XG5cbmNvbnN0IGRlYnVnID0gRGVidWcoXCJjdXJyZW50czpwbGF0Zm9ybVwiKTtcblxuY29uc3QgZ2V0T3NWZXJzaW9uID0gYXN5bmMgKCkgPT4ge1xuICBpZiAocGxhdGZvcm0oKSA9PT0gXCJsaW51eFwiKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGxpbnV4T3MgPSBhd2FpdCBwcm9taXNpZnkoZ2V0b3MpKCk7XG4gICAgICBpZiAoXCJkaXN0XCIgaW4gbGludXhPcyAmJiBcInJlbGVhc2VcIiBpbiBsaW51eE9zKSB7XG4gICAgICAgIHJldHVybiBbbGludXhPcy5kaXN0LCBsaW51eE9zLnJlbGVhc2VdLmpvaW4oXCIgLSBcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVsZWFzZSgpO1xuICAgICAgfVxuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIHJlbGVhc2UoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlbGVhc2UoKTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRQbGF0Zm9ybUluZm8gPSBhc3luYyAoKSA9PiB7XG4gIGNvbnN0IG9zVmVyc2lvbiA9IGF3YWl0IGdldE9zVmVyc2lvbigpO1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgb3NOYW1lOiBwbGF0Zm9ybSgpLFxuICAgIG9zVmVyc2lvbixcbiAgICBvc0NwdXM6IGNwdXMoKSxcbiAgICBvc01lbW9yeToge1xuICAgICAgZnJlZTogZnJlZW1lbSgpLFxuICAgICAgdG90YWw6IHRvdGFsbWVtKCksXG4gICAgfSxcbiAgfTtcbiAgZGVidWcoXCJwbGF0Zm9ybSBpbmZvOiAlb1wiLCByZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsICJpbXBvcnQgeyBNZXJnZWRDb25maWcgfSBmcm9tIFwiLi4vY29uZmlnXCI7XG5pbXBvcnQgeyBndWVzc0Jyb3dzZXIgfSBmcm9tIFwiLi9icm93c2VyXCI7XG5pbXBvcnQgeyBnZXRQbGF0Zm9ybUluZm8gfSBmcm9tIFwiLi9wbGF0Zm9ybVwiO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UGxhdGZvcm0oe1xuICBicm93c2VyLFxuICBjb25maWcsXG59OiB7XG4gIGJyb3dzZXI/OiBzdHJpbmc7XG4gIGNvbmZpZzogTWVyZ2VkQ29uZmlnO1xufSkge1xuICByZXR1cm4ge1xuICAgIC4uLihhd2FpdCBnZXRQbGF0Zm9ybUluZm8oKSksXG4gICAgLi4uZ3Vlc3NCcm93c2VyKGJyb3dzZXIgPz8gXCJlbGVjdHJvblwiLCBjb25maWcucmVzb2x2ZWQ/LmJyb3dzZXJzKSxcbiAgfTtcbn1cbiIsICJpbXBvcnQgeyBDeXByZXNzUmVzdWx0LCBTY3JlZW5zaG90QXJ0aWZhY3QgfSBmcm9tIFwiY3lwcmVzcy1jbG91ZC90eXBlc1wiO1xuaW1wb3J0IERlYnVnIGZyb20gXCJkZWJ1Z1wiO1xuaW1wb3J0IF8gZnJvbSBcImxvZGFzaFwiO1xuaW1wb3J0IHsgbmFub2lkIH0gZnJvbSBcIm5hbm9pZFwiO1xuaW1wb3J0IHtcbiAgU2V0SW5zdGFuY2VUZXN0c1BheWxvYWQsXG4gIFRlc3RTdGF0ZSxcbiAgVXBkYXRlSW5zdGFuY2VSZXN1bHRzUGF5bG9hZCxcbn0gZnJvbSBcIi4uL2FwaVwiO1xuaW1wb3J0IHsgTWVyZ2VkQ29uZmlnIH0gZnJvbSBcIi4uL2NvbmZpZ1wiO1xuaW1wb3J0IHsgQ29uZmlnU3RhdGUgfSBmcm9tIFwiLi4vc3RhdGVcIjtcblxuY29uc3QgZGVidWcgPSBEZWJ1ZyhcImN1cnJlbnRzOnJlc3VsdHNcIik7XG5cbmV4cG9ydCBjb25zdCBpc1N1Y2Nlc3NSZXN1bHQgPSAoXG4gIHJlc3VsdDogQ3lwcmVzc1Jlc3VsdFxuKTogcmVzdWx0IGlzIEN5cHJlc3NDb21tYW5kTGluZS5DeXByZXNzUnVuUmVzdWx0ID0+IHtcbiAgcmV0dXJuIHJlc3VsdC5zdGF0dXMgPT09IFwiZmluaXNoZWRcIjtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRTY3JlZW5zaG90c1N1bW1hcnkgPSAoXG4gIHRlc3RzOiBDeXByZXNzQ29tbWFuZExpbmUuVGVzdFJlc3VsdFtdID0gW11cbik6IFNjcmVlbnNob3RBcnRpZmFjdFtdID0+IHtcbiAgcmV0dXJuIHRlc3RzLmZsYXRNYXAoKHRlc3QsIGkpID0+XG4gICAgdGVzdC5hdHRlbXB0cy5mbGF0TWFwKChhLCBhaSkgPT5cbiAgICAgIGEuc2NyZWVuc2hvdHMuZmxhdE1hcCgocykgPT4gKHtcbiAgICAgICAgLi4ucyxcbiAgICAgICAgdGVzdElkOiBgciR7aX1gLFxuICAgICAgICB0ZXN0QXR0ZW1wdEluZGV4OiBhaSxcbiAgICAgICAgc2NyZWVuc2hvdElkOiBuYW5vaWQoKSxcbiAgICAgIH0pKVxuICAgIClcbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRTdGF0cyA9IChzdGF0czogQ3lwcmVzc0NvbW1hbmRMaW5lLlJ1blJlc3VsdFtcInN0YXRzXCJdKSA9PiB7XG4gIHJldHVybiB7XG4gICAgLi4uc3RhdHMsXG4gICAgd2FsbENsb2NrRHVyYXRpb246IHN0YXRzLmR1cmF0aW9uLFxuICAgIHdhbGxDbG9ja1N0YXJ0ZWRBdDogc3RhdHMuc3RhcnRlZEF0LFxuICAgIHdhbGxDbG9ja0VuZGVkQXQ6IHN0YXRzLmVuZGVkQXQsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0VGVzdEF0dGVtcHQgPSAoYXR0ZW1wdDogQ3lwcmVzc0NvbW1hbmRMaW5lLkF0dGVtcHRSZXN1bHQpID0+IHtcbiAgcmV0dXJuIHtcbiAgICAuLi5hdHRlbXB0LFxuICAgIHN0YXRlOiBhdHRlbXB0LnN0YXRlIGFzIFRlc3RTdGF0ZSxcbiAgICB3YWxsQ2xvY2tEdXJhdGlvbjogYXR0ZW1wdC5kdXJhdGlvbixcbiAgICB3YWxsQ2xvY2tTdGFydGVkQXQ6IGF0dGVtcHQuc3RhcnRlZEF0LFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGdldEluc3RhbmNlUmVzdWx0UGF5bG9hZCA9IChcbiAgcnVuUmVzdWx0OiBDeXByZXNzQ29tbWFuZExpbmUuUnVuUmVzdWx0XG4pOiBVcGRhdGVJbnN0YW5jZVJlc3VsdHNQYXlsb2FkID0+IHtcbiAgcmV0dXJuIHtcbiAgICBzdGF0czogZ2V0U3RhdHMocnVuUmVzdWx0LnN0YXRzKSxcbiAgICByZXBvcnRlclN0YXRzOiBydW5SZXN1bHQucmVwb3J0ZXJTdGF0cyxcbiAgICBleGNlcHRpb246IHJ1blJlc3VsdC5lcnJvciA/PyBudWxsLFxuICAgIHZpZGVvOiAhIXJ1blJlc3VsdC52aWRlbywgLy8gRGlkIHRoZSBpbnN0YW5jZSBnZW5lcmF0ZSBhIHZpZGVvP1xuICAgIHNjcmVlbnNob3RzOiBnZXRTY3JlZW5zaG90c1N1bW1hcnkocnVuUmVzdWx0LnRlc3RzID8/IFtdKSxcbiAgICB0ZXN0czpcbiAgICAgIHJ1blJlc3VsdC50ZXN0cz8ubWFwKCh0ZXN0LCBpKSA9PiAoe1xuICAgICAgICBkaXNwbGF5RXJyb3I6IHRlc3QuZGlzcGxheUVycm9yLFxuICAgICAgICBzdGF0ZTogdGVzdC5zdGF0ZSBhcyBUZXN0U3RhdGUsXG4gICAgICAgIGhvb2tzOiBydW5SZXN1bHQuaG9va3MsXG4gICAgICAgIGF0dGVtcHRzOiB0ZXN0LmF0dGVtcHRzPy5tYXAoZ2V0VGVzdEF0dGVtcHQpID8/IFtdLFxuICAgICAgICBjbGllbnRJZDogYHIke2l9YCxcbiAgICAgIH0pKSA/PyBbXSxcbiAgfTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGYWtlVGVzdEZyb21FeGNlcHRpb24oXG4gIGVycm9yOiBzdHJpbmcsXG4gIHN0YXRzOiBDeXByZXNzQ29tbWFuZExpbmUuUnVuUmVzdWx0W1wic3RhdHNcIl1cbikge1xuICByZXR1cm4ge1xuICAgIHRpdGxlOiBbXCJVbmtub3duXCJdLFxuICAgIGJvZHk6IFwiXCIsXG4gICAgZGlzcGxheUVycm9yOiBlcnJvci5zcGxpdChcIlxcblwiKVswXSxcbiAgICBzdGF0ZTogXCJmYWlsZWRcIixcbiAgICBob29rczogW10sXG4gICAgYXR0ZW1wdHM6IFtcbiAgICAgIGdldFRlc3RBdHRlbXB0KHtcbiAgICAgICAgc3RhdGU6IFwiZmFpbGVkXCIsXG4gICAgICAgIGR1cmF0aW9uOiAwLFxuICAgICAgICBlcnJvcjoge1xuICAgICAgICAgIG5hbWU6IFwiRXJyb3JcIixcbiAgICAgICAgICBtZXNzYWdlOiBlcnJvci5zcGxpdChcIlxcblwiKVswXSxcbiAgICAgICAgICBzdGFjazogZXJyb3IsXG4gICAgICAgIH0sXG4gICAgICAgIHNjcmVlbnNob3RzOiBbXSxcbiAgICAgICAgc3RhcnRlZEF0OiBzdGF0cy5zdGFydGVkQXQsXG4gICAgICAgIHZpZGVvVGltZXN0YW1wOiAwLFxuICAgICAgfSksXG4gICAgXSxcbiAgICBjbGllbnRJZDogXCJyMFwiLFxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgZ2V0SW5zdGFuY2VUZXN0c1BheWxvYWQgPSAoXG4gIHJ1blJlc3VsdDogQ3lwcmVzc0NvbW1hbmRMaW5lLlJ1blJlc3VsdCxcbiAgY29uZmlnOiBDeXByZXNzLlJlc29sdmVkQ29uZmlnT3B0aW9uc1xuKTogU2V0SW5zdGFuY2VUZXN0c1BheWxvYWQgPT4ge1xuICByZXR1cm4ge1xuICAgIGNvbmZpZyxcbiAgICB0ZXN0czpcbiAgICAgIHJ1blJlc3VsdC50ZXN0cz8ubWFwKCh0ZXN0LCBpKSA9PiAoe1xuICAgICAgICB0aXRsZTogdGVzdC50aXRsZSxcbiAgICAgICAgY29uZmlnOiBudWxsLFxuICAgICAgICBib2R5OiB0ZXN0LmJvZHksXG4gICAgICAgIGNsaWVudElkOiBgciR7aX1gLFxuICAgICAgICBob29rSWRzOiBbXSxcbiAgICAgIH0pKSA/PyBbXSxcbiAgICBob29rczogcnVuUmVzdWx0Lmhvb2tzLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IHN1bW1hcml6ZVRlc3RSZXN1bHRzID0gKFxuICBpbnB1dDogQ3lwcmVzc0NvbW1hbmRMaW5lLkN5cHJlc3NSdW5SZXN1bHRbXSxcbiAgY29uZmlnOiBNZXJnZWRDb25maWdcbik6IEN5cHJlc3NDb21tYW5kTGluZS5DeXByZXNzUnVuUmVzdWx0ID0+IHtcbiAgaWYgKCFpbnB1dC5sZW5ndGgpIHtcbiAgICByZXR1cm4gZ2V0RW1wdHlDeXByZXNzUmVzdWx0cyhjb25maWcpO1xuICB9XG5cbiAgY29uc3Qgb3ZlcmFsbCA9IGlucHV0LnJlZHVjZShcbiAgICAoXG4gICAgICBhY2MsXG4gICAgICB7XG4gICAgICAgIHRvdGFsRHVyYXRpb24sXG4gICAgICAgIHRvdGFsRmFpbGVkLFxuICAgICAgICB0b3RhbFBhc3NlZCxcbiAgICAgICAgdG90YWxQZW5kaW5nLFxuICAgICAgICB0b3RhbFNraXBwZWQsXG4gICAgICAgIHRvdGFsVGVzdHMsXG4gICAgICAgIHRvdGFsU3VpdGVzLFxuICAgICAgfVxuICAgICkgPT4gKHtcbiAgICAgIHRvdGFsRHVyYXRpb246IGFjYy50b3RhbER1cmF0aW9uICsgdG90YWxEdXJhdGlvbixcbiAgICAgIHRvdGFsU3VpdGVzOiBhY2MudG90YWxTdWl0ZXMgKyB0b3RhbFN1aXRlcyxcbiAgICAgIHRvdGFsUGVuZGluZzogYWNjLnRvdGFsUGVuZGluZyArIHRvdGFsUGVuZGluZyxcbiAgICAgIHRvdGFsRmFpbGVkOiBhY2MudG90YWxGYWlsZWQgKyB0b3RhbEZhaWxlZCxcbiAgICAgIHRvdGFsU2tpcHBlZDogYWNjLnRvdGFsU2tpcHBlZCArIHRvdGFsU2tpcHBlZCxcbiAgICAgIHRvdGFsUGFzc2VkOiBhY2MudG90YWxQYXNzZWQgKyB0b3RhbFBhc3NlZCxcbiAgICAgIHRvdGFsVGVzdHM6IGFjYy50b3RhbFRlc3RzICsgdG90YWxUZXN0cyxcbiAgICB9KSxcbiAgICBlbXB0eVN0YXRzXG4gICk7XG4gIGNvbnN0IGZpcnN0UmVzdWx0ID0gaW5wdXRbMF07XG4gIGNvbnN0IHN0YXJ0SXRlbXMgPSBpbnB1dC5tYXAoKGkpID0+IGkuc3RhcnRlZFRlc3RzQXQpLnNvcnQoKTtcbiAgY29uc3QgZW5kSXRlbXMgPSBpbnB1dC5tYXAoKGkpID0+IGkuZW5kZWRUZXN0c0F0KS5zb3J0KCk7XG4gIGNvbnN0IHJ1bnMgPSBpbnB1dC5tYXAoKGkpID0+IGkucnVucykuZmxhdCgpO1xuICByZXR1cm4ge1xuICAgIC4uLm92ZXJhbGwsXG4gICAgcnVucyxcbiAgICBzdGFydGVkVGVzdHNBdDogXy5maXJzdChzdGFydEl0ZW1zKSBhcyBzdHJpbmcsXG4gICAgZW5kZWRUZXN0c0F0OiBfLmxhc3QoZW5kSXRlbXMpIGFzIHN0cmluZyxcbiAgICAuLi5fLnBpY2soXG4gICAgICBmaXJzdFJlc3VsdCxcbiAgICAgIFwiYnJvd3Nlck5hbWVcIixcbiAgICAgIFwiYnJvd3NlclZlcnNpb25cIixcbiAgICAgIFwiYnJvd3NlclBhdGhcIixcbiAgICAgIFwib3NOYW1lXCIsXG4gICAgICBcIm9zVmVyc2lvblwiLFxuICAgICAgXCJjeXByZXNzVmVyc2lvblwiLFxuICAgICAgXCJjb25maWdcIlxuICAgICksXG4gICAgc3RhdHVzOiBcImZpbmlzaGVkXCIsXG4gIH07XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RW1wdHlDeXByZXNzUmVzdWx0cyhcbiAgY29uZmlnOiBNZXJnZWRDb25maWdcbik6IEN5cHJlc3NDb21tYW5kTGluZS5DeXByZXNzUnVuUmVzdWx0IHtcbiAgcmV0dXJuIHtcbiAgICAuLi5lbXB0eVN0YXRzLFxuICAgIHN0YXR1czogXCJmaW5pc2hlZFwiLFxuICAgIHN0YXJ0ZWRUZXN0c0F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgZW5kZWRUZXN0c0F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgcnVuczogW10sXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbmZpZyxcbiAgfTtcbn1cbmNvbnN0IGVtcHR5U3RhdHMgPSB7XG4gIHRvdGFsRHVyYXRpb246IDAsXG4gIHRvdGFsU3VpdGVzOiAwLFxuICB0b3RhbFBlbmRpbmc6IDAsXG4gIHRvdGFsRmFpbGVkOiAwLFxuICB0b3RhbFNraXBwZWQ6IDAsXG4gIHRvdGFsUGFzc2VkOiAwLFxuICB0b3RhbFRlc3RzOiAwLFxufTtcblxuY29uc3QgZ2V0RHVtbXlGYWlsZWRUZXN0ID0gKHN0YXJ0OiBzdHJpbmcsIGVycm9yOiBzdHJpbmcpID0+ICh7XG4gIHRpdGxlOiBbXCJVbmtub3duXCJdLFxuICBzdGF0ZTogXCJmYWlsZWRcIixcbiAgYm9keTogXCIvLyBUaGlzIHRlc3QgaXMgYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgZHVlIHRvIGV4ZWN1dGlvbiBmYWlsdXJlXCIsXG4gIGRpc3BsYXlFcnJvcjogZXJyb3IsXG4gIGF0dGVtcHRzOiBbXG4gICAge1xuICAgICAgc3RhdGU6IFwiZmFpbGVkXCIsXG4gICAgICBzdGFydGVkQXQ6IHN0YXJ0LFxuICAgICAgZHVyYXRpb246IDAsXG4gICAgICB2aWRlb1RpbWVzdGFtcDogMCxcbiAgICAgIHNjcmVlbnNob3RzOiBbXSxcbiAgICAgIGVycm9yOiB7XG4gICAgICAgIG5hbWU6IFwiQ3lwcmVzc0V4ZWN1dGlvbkVycm9yXCIsXG4gICAgICAgIG1lc3NhZ2U6IGVycm9yLFxuICAgICAgICBzdGFjazogXCJcIixcbiAgICAgIH0sXG4gICAgfSxcbiAgXSxcbn0pO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmFpbGVkRHVtbXlSZXN1bHQoXG4gIGNvbmZpZ1N0YXRlOiBDb25maWdTdGF0ZSxcbiAge1xuICAgIHNwZWNzLFxuICAgIGVycm9yLFxuICB9OiB7XG4gICAgc3BlY3M6IHN0cmluZ1tdO1xuICAgIGVycm9yOiBzdHJpbmc7XG4gIH1cbik6IEN5cHJlc3NDb21tYW5kTGluZS5DeXByZXNzUnVuUmVzdWx0IHtcbiAgY29uc3Qgc3RhcnQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gIGNvbnN0IGVuZCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgcmV0dXJuIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uZmlnOiBjb25maWdTdGF0ZS5nZXRDb25maWcoKSA/PyB7fSxcbiAgICBzdGF0dXM6IFwiZmluaXNoZWRcIixcbiAgICBzdGFydGVkVGVzdHNBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIGVuZGVkVGVzdHNBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIHRvdGFsRHVyYXRpb246IDAsXG4gICAgdG90YWxTdWl0ZXM6IDEsXG4gICAgdG90YWxGYWlsZWQ6IDEsXG4gICAgdG90YWxQYXNzZWQ6IDAsXG4gICAgdG90YWxQZW5kaW5nOiAwLFxuICAgIHRvdGFsU2tpcHBlZDogMCxcbiAgICB0b3RhbFRlc3RzOiAxLFxuICAgIGJyb3dzZXJOYW1lOiBcInVua25vd25cIixcbiAgICBicm93c2VyVmVyc2lvbjogXCJ1bmtub3duXCIsXG4gICAgYnJvd3NlclBhdGg6IFwidW5rbm93blwiLFxuICAgIG9zTmFtZTogXCJ1bmtub3duXCIsXG4gICAgb3NWZXJzaW9uOiBcInVua25vd25cIixcbiAgICBjeXByZXNzVmVyc2lvbjogXCJ1bmtub3duXCIsXG4gICAgcnVuczogc3BlY3MubWFwKChzKSA9PiAoe1xuICAgICAgc3RhdHM6IHtcbiAgICAgICAgc3VpdGVzOiAxLFxuICAgICAgICB0ZXN0czogMSxcbiAgICAgICAgcGFzc2VzOiAwLFxuICAgICAgICBwZW5kaW5nOiAwLFxuICAgICAgICBza2lwcGVkOiAwLFxuICAgICAgICBmYWlsdXJlczogMSxcbiAgICAgICAgc3RhcnRlZEF0OiBzdGFydCxcbiAgICAgICAgZW5kZWRBdDogZW5kLFxuICAgICAgICBkdXJhdGlvbjogMCxcbiAgICAgIH0sXG4gICAgICByZXBvcnRlcjogXCJzcGVjXCIsXG4gICAgICByZXBvcnRlclN0YXRzOiB7fSxcbiAgICAgIGhvb2tzOiBbXSxcbiAgICAgIGVycm9yLFxuICAgICAgdmlkZW86IG51bGwsXG4gICAgICBzcGVjOiB7XG4gICAgICAgIG5hbWU6IHMsXG4gICAgICAgIHJlbGF0aXZlOiBzLFxuICAgICAgICBhYnNvbHV0ZTogcyxcbiAgICAgICAgcmVsYXRpdmVUb0NvbW1vblJvb3Q6IHMsXG4gICAgICB9LFxuICAgICAgdGVzdHM6IFtnZXREdW1teUZhaWxlZFRlc3Qoc3RhcnQsIGVycm9yKV0sXG4gICAgICBzaG91bGRVcGxvYWRWaWRlbzogZmFsc2UsXG4gICAgICBza2lwcGVkU3BlYzogZmFsc2UsXG4gICAgfSkpLFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3lwcmVzc1J1blJlc3VsdEZvclNwZWMoXG4gIHNwZWM6IHN0cmluZyxcbiAgY3lwcmVzc1Jlc3VsdDogQ3lwcmVzc1Jlc3VsdFxuKTogQ3lwcmVzc0NvbW1hbmRMaW5lLkN5cHJlc3NSdW5SZXN1bHQgfCB1bmRlZmluZWQge1xuICBpZiAoIWlzU3VjY2Vzc1Jlc3VsdChjeXByZXNzUmVzdWx0KSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHJ1biA9IGN5cHJlc3NSZXN1bHQucnVucy5maW5kKChyKSA9PiByLnNwZWMucmVsYXRpdmUgPT09IHNwZWMpO1xuICBpZiAoIXJ1bikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBzdGF0cyA9IGdldFN0YXRzKHJ1bi5zdGF0cyk7XG4gIC8vIGFkanVzdCB0aGUgcmVzdWx0IGZvciBzaW5nZSBzcGVjXG4gIHJldHVybiB7XG4gICAgLi4uY3lwcmVzc1Jlc3VsdCxcbiAgICBydW5zOiBbcnVuXSxcbiAgICB0b3RhbFN1aXRlczogMSxcbiAgICB0b3RhbER1cmF0aW9uOiBzdGF0cy53YWxsQ2xvY2tEdXJhdGlvbixcbiAgICB0b3RhbFRlc3RzOiBzdGF0cy50ZXN0cyxcbiAgICB0b3RhbEZhaWxlZDogc3RhdHMuZmFpbHVyZXMsXG4gICAgdG90YWxQYXNzZWQ6IHN0YXRzLnBhc3NlcyxcbiAgICB0b3RhbFBlbmRpbmc6IHN0YXRzLnBlbmRpbmcsXG4gICAgdG90YWxTa2lwcGVkOiBzdGF0cy5za2lwcGVkLFxuICAgIHN0YXJ0ZWRUZXN0c0F0OiBzdGF0cy53YWxsQ2xvY2tTdGFydGVkQXQsXG4gICAgZW5kZWRUZXN0c0F0OiBzdGF0cy53YWxsQ2xvY2tFbmRlZEF0LFxuICB9O1xufVxuIiwgImltcG9ydCBfIGZyb20gXCJsb2Rhc2hcIjtcbmltcG9ydCBwcmV0dHlNUyBmcm9tIFwicHJldHR5LW1zXCI7XG5pbXBvcnQgeyB0YWJsZSB9IGZyb20gXCJ0YWJsZVwiO1xuaW1wb3J0IHsgY3lhbiwgZ3JheSwgZ3JlZW4sIHJlZCwgd2hpdGUgfSBmcm9tIFwiLi4vbG9nXCI7XG5cbmNvbnN0IGZhaWx1cmVJY29uID0gcmVkKFwiXHUyNzE2XCIpO1xuY29uc3Qgc3VjY2Vzc0ljb24gPSBncmVlbihcIlx1MjcxNFwiKTtcblxuZXhwb3J0IGNvbnN0IHN1bW1hcnlUYWJsZSA9IChyOiBDeXByZXNzQ29tbWFuZExpbmUuQ3lwcmVzc1J1blJlc3VsdCkgPT4ge1xuICBjb25zdCBvdmVyYWxsU3BlY0NvdW50ID0gci5ydW5zLmxlbmd0aDtcbiAgY29uc3QgZmFpbGVkU3BlY3NDb3VudCA9IF8uc3VtKFxuICAgIHIucnVucy5maWx0ZXIoKHYpID0+IHYuc3RhdHMuZmFpbHVyZXMgKyB2LnN0YXRzLnNraXBwZWQgPiAwKS5tYXAoKCkgPT4gMSlcbiAgKTtcbiAgY29uc3QgaGFzRmFpbGVkID0gZmFpbGVkU3BlY3NDb3VudCA+IDA7XG5cbiAgY29uc3QgdmVyZGljdCA9IGhhc0ZhaWxlZFxuICAgID8gcmVkKGAke2ZhaWxlZFNwZWNzQ291bnR9IG9mICR7b3ZlcmFsbFNwZWNDb3VudH0gZmFpbGVkYClcbiAgICA6IG92ZXJhbGxTcGVjQ291bnQgPiAwXG4gICAgPyBcIkFsbCBzcGVjcyBwYXNzZWQhXCJcbiAgICA6IFwiTm8gc3BlY3MgZXhlY3V0ZWRcIjtcblxuICBjb25zdCBkYXRhID0gci5ydW5zLm1hcCgocikgPT4gW1xuICAgIHIuc3RhdHMuZmFpbHVyZXMgKyByLnN0YXRzLnNraXBwZWQgPiAwID8gZmFpbHVyZUljb24gOiBzdWNjZXNzSWNvbixcbiAgICByLnNwZWMucmVsYXRpdmVUb0NvbW1vblJvb3QsXG4gICAgZ3JheShwcmV0dHlNUyhyLnN0YXRzLmR1cmF0aW9uKSksXG4gICAgd2hpdGUoci5zdGF0cy50ZXN0cyA/PyAwKSxcbiAgICByLnN0YXRzLnBhc3NlcyA/IGdyZWVuKHIuc3RhdHMucGFzc2VzKSA6IGdyYXkoXCItXCIpLFxuICAgIHIuc3RhdHMuZmFpbHVyZXMgPyByZWQoci5zdGF0cy5mYWlsdXJlcykgOiBncmF5KFwiLVwiKSxcbiAgICByLnN0YXRzLnBlbmRpbmcgPyBjeWFuKHIuc3RhdHMucGVuZGluZykgOiBncmF5KFwiLVwiKSxcbiAgICByLnN0YXRzLnNraXBwZWQgPyByZWQoci5zdGF0cy5za2lwcGVkKSA6IGdyYXkoXCItXCIpLFxuICBdKTtcblxuICByZXR1cm4gdGFibGUoXG4gICAgW1xuICAgICAgW1xuICAgICAgICBcIlwiLCAvLyBtYXJrZXJcbiAgICAgICAgZ3JheShcIlNwZWNcIiksXG4gICAgICAgIFwiXCIsXG4gICAgICAgIGdyYXkoXCJUZXN0c1wiKSxcbiAgICAgICAgZ3JheShcIlBhc3NpbmdcIiksXG4gICAgICAgIGdyYXkoXCJGYWlsaW5nXCIpLFxuICAgICAgICBncmF5KFwiUGVuZGluZ1wiKSxcbiAgICAgICAgZ3JheShcIlNraXBwZWRcIiksXG4gICAgICBdLFxuICAgICAgLi4uZGF0YSxcbiAgICAgIFtcbiAgICAgICAgaGFzRmFpbGVkID8gZmFpbHVyZUljb24gOiBzdWNjZXNzSWNvbiwgLy8gbWFya2VyXG4gICAgICAgIHZlcmRpY3QsXG4gICAgICAgIGdyYXkocHJldHR5TVMoci50b3RhbER1cmF0aW9uID8/IDApKSxcbiAgICAgICAgb3ZlcmFsbFNwZWNDb3VudCA+IDAgPyB3aGl0ZShyLnRvdGFsVGVzdHMgPz8gMCkgOiBncmF5KFwiLVwiKSxcbiAgICAgICAgci50b3RhbFBhc3NlZCA/IGdyZWVuKHIudG90YWxQYXNzZWQpIDogZ3JheShcIi1cIiksXG4gICAgICAgIHIudG90YWxGYWlsZWQgPyByZWQoci50b3RhbEZhaWxlZCkgOiBncmF5KFwiLVwiKSxcbiAgICAgICAgci50b3RhbFBlbmRpbmcgPyBjeWFuKHIudG90YWxQZW5kaW5nKSA6IGdyYXkoXCItXCIpLFxuICAgICAgICByLnRvdGFsU2tpcHBlZCA/IHJlZChyLnRvdGFsU2tpcHBlZCkgOiBncmF5KFwiLVwiKSxcbiAgICAgIF0sXG4gICAgXSxcbiAgICB7XG4gICAgICBib3JkZXIsXG4gICAgICBjb2x1bW5EZWZhdWx0OiB7XG4gICAgICAgIHdpZHRoOiA4LFxuICAgICAgfSxcbiAgICAgIGNvbHVtbnM6IFtcbiAgICAgICAgeyBhbGlnbm1lbnQ6IFwibGVmdFwiLCB3aWR0aDogMiB9LFxuICAgICAgICB7IGFsaWdubWVudDogXCJsZWZ0XCIsIHdpZHRoOiAzMCB9LFxuICAgICAgICB7IGFsaWdubWVudDogXCJyaWdodFwiIH0sXG4gICAgICAgIHsgYWxpZ25tZW50OiBcInJpZ2h0XCIgfSxcbiAgICAgICAgeyBhbGlnbm1lbnQ6IFwicmlnaHRcIiB9LFxuICAgICAgICB7IGFsaWdubWVudDogXCJyaWdodFwiIH0sXG4gICAgICAgIHsgYWxpZ25tZW50OiBcInJpZ2h0XCIgfSxcbiAgICAgICAgeyBhbGlnbm1lbnQ6IFwicmlnaHRcIiB9LFxuICAgICAgXSxcbiAgICAgIC8vIHNpbmdsZUxpbmU6IHRydWUsXG4gICAgICBkcmF3SG9yaXpvbnRhbExpbmU6IChsaW5lSW5kZXgsIHJvd0NvdW50KSA9PiB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgbGluZUluZGV4ID09PSAxIHx8XG4gICAgICAgICAgbGluZUluZGV4ID09PSAwIHx8XG4gICAgICAgICAgbGluZUluZGV4ID09PSByb3dDb3VudCAtIDEgfHxcbiAgICAgICAgICBsaW5lSW5kZXggPT09IHJvd0NvdW50XG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgZHJhd1ZlcnRpY2FsTGluZTogKGxpbmVJbmRleCwgcm93Q291bnQpID0+IHtcbiAgICAgICAgcmV0dXJuIGxpbmVJbmRleCA9PT0gMCB8fCByb3dDb3VudCA9PT0gbGluZUluZGV4O1xuICAgICAgfSxcbiAgICB9XG4gICk7XG59O1xuXG5jb25zdCBib3JkZXIgPSBfLm1hcFZhbHVlcyhcbiAge1xuICAgIHRvcEJvZHk6IGBcdTI1MDBgLFxuICAgIHRvcEpvaW46IGBcdTI1MkNgLFxuICAgIHRvcExlZnQ6IGAgIFx1MjUwQ2AsXG4gICAgdG9wUmlnaHQ6IGBcdTI1MTBgLFxuXG4gICAgYm90dG9tQm9keTogYFx1MjUwMGAsXG4gICAgYm90dG9tSm9pbjogYFx1MjUzNGAsXG4gICAgYm90dG9tTGVmdDogYCAgXHUyNTE0YCxcbiAgICBib3R0b21SaWdodDogYFx1MjUxOGAsXG5cbiAgICBib2R5TGVmdDogYCAgXHUyNTAyYCxcbiAgICBib2R5UmlnaHQ6IGBcdTI1MDJgLFxuICAgIGJvZHlKb2luOiBgXHUyNTAyYCxcblxuICAgIGpvaW5Cb2R5OiBgXHUyNTAwYCxcbiAgICBqb2luTGVmdDogYCAgXHUyNTFDYCxcbiAgICBqb2luUmlnaHQ6IGBcdTI1MjRgLFxuICAgIGpvaW5Kb2luOiBgXHUyNTNDYCxcbiAgfSxcbiAgKHYpID0+IGdyYXkodilcbik7XG4iLCAiaW1wb3J0IERlYnVnIGZyb20gXCJkZWJ1Z1wiO1xuaW1wb3J0IHtcbiAgcmVwb3J0SW5zdGFuY2VSZXN1bHRzTWVyZ2VkLFxuICBzZXRJbnN0YW5jZVRlc3RzLFxuICBTZXRJbnN0YW5jZVRlc3RzUGF5bG9hZCxcbiAgdXBkYXRlSW5zdGFuY2VSZXN1bHRzLFxuICBVcGRhdGVJbnN0YW5jZVJlc3VsdHNQYXlsb2FkLFxufSBmcm9tIFwiLi4vYXBpXCI7XG5pbXBvcnQgeyB1cGxvYWRBcnRpZmFjdHMsIHVwbG9hZFN0ZG91dFNhZmUgfSBmcm9tIFwiLi4vYXJ0aWZhY3RzXCI7XG5pbXBvcnQgeyBzZXRDYW5jZWxsYXRpb25SZWFzb24gfSBmcm9tIFwiLi4vY2FuY2VsbGF0aW9uXCI7XG5pbXBvcnQgeyBnZXRJbml0aWFsT3V0cHV0IH0gZnJvbSBcIi4uL2NhcHR1cmVcIjtcbmltcG9ydCB7IGlzQ3VycmVudHMgfSBmcm9tIFwiLi4vZW52XCI7XG5pbXBvcnQgeyBnZXRJbnN0YW5jZVJlc3VsdFBheWxvYWQsIGdldEluc3RhbmNlVGVzdHNQYXlsb2FkIH0gZnJvbSBcIi4vcmVzdWx0c1wiO1xuY29uc3QgZGVidWcgPSBEZWJ1ZyhcImN1cnJlbnRzOnJlc3VsdHNcIik7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRSZXBvcnRSZXN1bHRzVGFzayhcbiAgaW5zdGFuY2VJZDogc3RyaW5nLFxuICByZXN1bHRzOiBDeXByZXNzQ29tbWFuZExpbmUuQ3lwcmVzc1J1blJlc3VsdCxcbiAgc3Rkb3V0OiBzdHJpbmdcbikge1xuICBjb25zdCBydW4gPSByZXN1bHRzLnJ1bnNbMF07XG4gIGlmICghcnVuKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gcnVuIGZvdW5kIGluIEN5cHJlc3MgcmVzdWx0c1wiKTtcbiAgfVxuICBjb25zdCBpbnN0YW5jZVJlc3VsdHMgPSBnZXRJbnN0YW5jZVJlc3VsdFBheWxvYWQocnVuKTtcbiAgY29uc3QgaW5zdGFuY2VUZXN0cyA9IGdldEluc3RhbmNlVGVzdHNQYXlsb2FkKHJ1biwgcmVzdWx0cy5jb25maWcpO1xuXG4gIGNvbnN0IHsgdmlkZW9VcGxvYWRVcmwsIHNjcmVlbnNob3RVcGxvYWRVcmxzLCBjbG91ZCB9ID0gYXdhaXQgcmVwb3J0UmVzdWx0cyhcbiAgICBpbnN0YW5jZUlkLFxuICAgIGluc3RhbmNlVGVzdHMsXG4gICAgaW5zdGFuY2VSZXN1bHRzXG4gICk7XG5cbiAgaWYgKGNsb3VkPy5zaG91bGRDYW5jZWwpIHtcbiAgICBkZWJ1ZyhcImluc3RhbmNlICVzIHNob3VsZCBjYW5jZWxcIiwgaW5zdGFuY2VJZCk7XG4gICAgc2V0Q2FuY2VsbGF0aW9uUmVhc29uKGNsb3VkLnNob3VsZENhbmNlbCk7XG4gIH1cblxuICBkZWJ1ZyhcImluc3RhbmNlICVzIGFydGlmYWN0IHVwbG9hZCBpbnN0cnVjdGlvbnMgJW9cIiwgaW5zdGFuY2VJZCwge1xuICAgIHZpZGVvVXBsb2FkVXJsLFxuICAgIHNjcmVlbnNob3RVcGxvYWRVcmxzLFxuICB9KTtcblxuICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgIHVwbG9hZEFydGlmYWN0cyh7XG4gICAgICB2aWRlb1VwbG9hZFVybCxcbiAgICAgIHZpZGVvUGF0aDogcnVuLnZpZGVvLFxuICAgICAgc2NyZWVuc2hvdFVwbG9hZFVybHMsXG4gICAgICBzY3JlZW5zaG90czogaW5zdGFuY2VSZXN1bHRzLnNjcmVlbnNob3RzLFxuICAgIH0pLFxuICAgIHVwbG9hZFN0ZG91dFNhZmUoaW5zdGFuY2VJZCwgZ2V0SW5pdGlhbE91dHB1dCgpICsgc3Rkb3V0KSxcbiAgXSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlcG9ydFJlc3VsdHMoXG4gIGluc3RhbmNlSWQ6IHN0cmluZyxcbiAgaW5zdGFuY2VUZXN0czogU2V0SW5zdGFuY2VUZXN0c1BheWxvYWQsXG4gIGluc3RhbmNlUmVzdWx0czogVXBkYXRlSW5zdGFuY2VSZXN1bHRzUGF5bG9hZFxuKSB7XG4gIGRlYnVnKFwicmVwb3J0aW5nIGluc3RhbmNlICVzIHJlc3VsdHMuLi5cIiwgaW5zdGFuY2VJZCk7XG4gIGlmIChpc0N1cnJlbnRzKCkpIHtcbiAgICByZXR1cm4gcmVwb3J0SW5zdGFuY2VSZXN1bHRzTWVyZ2VkKGluc3RhbmNlSWQsIHtcbiAgICAgIHRlc3RzOiBpbnN0YW5jZVRlc3RzLFxuICAgICAgcmVzdWx0czogaW5zdGFuY2VSZXN1bHRzLFxuICAgIH0pO1xuICB9XG5cbiAgLy8gcnVuIG9uZSBhZnRlciBhbm90aGVyXG4gIGF3YWl0IHNldEluc3RhbmNlVGVzdHMoaW5zdGFuY2VJZCwgaW5zdGFuY2VUZXN0cyk7XG4gIHJldHVybiB1cGRhdGVJbnN0YW5jZVJlc3VsdHMoaW5zdGFuY2VJZCwgaW5zdGFuY2VSZXN1bHRzKTtcbn1cbiIsICJpbXBvcnQgRGVidWcgZnJvbSBcImRlYnVnXCI7XG5pbXBvcnQgeyBTY3JlZW5zaG90QXJ0aWZhY3QsIFNjcmVlbnNob3RVcGxvYWRJbnN0cnVjdGlvbiB9IGZyb20gXCIuLi90eXBlc1wiO1xuaW1wb3J0IHsgdXBkYXRlSW5zdGFuY2VTdGRvdXQgfSBmcm9tIFwiLi9hcGlcIjtcbmltcG9ydCB7IHNhZmUgfSBmcm9tIFwiLi9sYW5nXCI7XG5pbXBvcnQgeyB3YXJuIH0gZnJvbSBcIi4vbG9nXCI7XG5pbXBvcnQgeyB1cGxvYWRJbWFnZSwgdXBsb2FkVmlkZW8gfSBmcm9tIFwiLi91cGxvYWRcIjtcbmNvbnN0IGRlYnVnID0gRGVidWcoXCJjdXJyZW50czphcnRpZmFjdHNcIik7XG5pbnRlcmZhY2UgVXBsb2FkQXJ0aWZhY3RzIHtcbiAgdmlkZW9QYXRoOiBzdHJpbmcgfCBudWxsO1xuICB2aWRlb1VwbG9hZFVybD86IHN0cmluZyB8IG51bGw7XG4gIHNjcmVlbnNob3RzOiBTY3JlZW5zaG90QXJ0aWZhY3RbXTtcbiAgc2NyZWVuc2hvdFVwbG9hZFVybHM6IFNjcmVlbnNob3RVcGxvYWRJbnN0cnVjdGlvbltdO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwbG9hZEFydGlmYWN0cyh7XG4gIHZpZGVvUGF0aCxcbiAgdmlkZW9VcGxvYWRVcmwsXG4gIHNjcmVlbnNob3RzLFxuICBzY3JlZW5zaG90VXBsb2FkVXJscyxcbn06IFVwbG9hZEFydGlmYWN0cykge1xuICAvLyB0aXRsZShcImJsdWVcIiwgXCJVcGxvYWRpbmcgIFJlc3VsdHNcIik7XG5cbiAgZGVidWcoXCJ1cGxvYWRpbmcgYXJ0aWZhY3RzOiAlb1wiLCB7XG4gICAgdmlkZW9QYXRoLFxuICAgIHZpZGVvVXBsb2FkVXJsLFxuICAgIHNjcmVlbnNob3RzLFxuICAgIHNjcmVlbnNob3RVcGxvYWRVcmxzLFxuICB9KTtcblxuICBjb25zdCB0b3RhbFVwbG9hZHMgPSAodmlkZW9QYXRoID8gMSA6IDApICsgc2NyZWVuc2hvdHMubGVuZ3RoO1xuICBpZiAodG90YWxVcGxvYWRzID09PSAwKSB7XG4gICAgLy8gaW5mbyhcIk5vdGhpbmcgdG8gdXBsb2FkXCIpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHVwbG9hZCB2aWRlb1xuICBpZiAodmlkZW9VcGxvYWRVcmwgJiYgdmlkZW9QYXRoKSB7XG4gICAgYXdhaXQgc2FmZShcbiAgICAgIHVwbG9hZFZpZGVvLFxuICAgICAgKGUpID0+IGRlYnVnKFwiZmFpbGVkIHVwbG9hZGluZyB2aWRlbyAlcy4gRXJyb3I6ICVvXCIsIHZpZGVvUGF0aCwgZSksXG4gICAgICAoKSA9PiBkZWJ1ZyhcInN1Y2Nlc3MgdXBsb2FkaW5nXCIsIHZpZGVvUGF0aClcbiAgICApKHZpZGVvUGF0aCwgdmlkZW9VcGxvYWRVcmwpO1xuICB9XG4gIC8vIHVwbG9hZCBzY3JlZW5zaG90c1xuICBpZiAoc2NyZWVuc2hvdFVwbG9hZFVybHMgJiYgc2NyZWVuc2hvdFVwbG9hZFVybHMubGVuZ3RoKSB7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICBzY3JlZW5zaG90cy5tYXAoKHNjcmVlbnNob3QpID0+IHtcbiAgICAgICAgY29uc3QgdXJsID0gc2NyZWVuc2hvdFVwbG9hZFVybHMuZmluZChcbiAgICAgICAgICAodXJscykgPT4gdXJscy5zY3JlZW5zaG90SWQgPT09IHNjcmVlbnNob3Quc2NyZWVuc2hvdElkXG4gICAgICAgICk/LnVwbG9hZFVybDtcbiAgICAgICAgaWYgKCF1cmwpIHtcbiAgICAgICAgICBkZWJ1ZyhcbiAgICAgICAgICAgIFwiTm8gdXBsb2FkIHVybCBmb3Igc2NyZWVuc2hvdCAlbywgc2NyZWVuc2hvdFVwbG9hZFVybHM6ICVvXCIsXG4gICAgICAgICAgICBzY3JlZW5zaG90LFxuICAgICAgICAgICAgc2NyZWVuc2hvdFVwbG9hZFVybHNcbiAgICAgICAgICApO1xuICAgICAgICAgIHdhcm4oXCJDYW5ub3QgZmluZCB1cGxvYWQgdXJsIGZvciBzY3JlZW5zaG90OiAlc1wiLCBzY3JlZW5zaG90LnBhdGgpO1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2FmZShcbiAgICAgICAgICB1cGxvYWRJbWFnZSxcbiAgICAgICAgICAoZSkgPT5cbiAgICAgICAgICAgIGRlYnVnKFxuICAgICAgICAgICAgICBcImZhaWxlZCB1cGxvYWRpbmcgc2NyZWVuc2hvdCAlcy4gRXJyb3I6ICVvXCIsXG4gICAgICAgICAgICAgIHNjcmVlbnNob3QucGF0aCxcbiAgICAgICAgICAgICAgZVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAoKSA9PiBkZWJ1ZyhcInN1Y2Nlc3MgdXBsb2FkaW5nXCIsIHNjcmVlbnNob3QucGF0aClcbiAgICAgICAgKShzY3JlZW5zaG90LnBhdGgsIHVybCk7XG4gICAgICB9KVxuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHVwbG9hZFN0ZG91dFNhZmUgPSBzYWZlKFxuICB1cGRhdGVJbnN0YW5jZVN0ZG91dCxcbiAgKCkgPT4ge30sXG4gICgpID0+IHt9XG4pO1xuIiwgImltcG9ydCBEZWJ1ZyBmcm9tIFwiZGVidWdcIjtcbmltcG9ydCBmcyBmcm9tIFwiZnNcIjtcbmltcG9ydCB7IG1ha2VSZXF1ZXN0IH0gZnJvbSBcIi4vaHR0cENsaWVudFwiO1xuY29uc3QgcmVhZEZpbGUgPSBmcy5wcm9taXNlcy5yZWFkRmlsZTtcbmNvbnN0IGRlYnVnID0gRGVidWcoXCJjdXJyZW50czp1cGxvYWRcIik7XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGxvYWRWaWRlbyhmaWxlOiBzdHJpbmcsIHVybDogc3RyaW5nKSB7XG4gIHJldHVybiB1cGxvYWRGaWxlKGZpbGUsIHVybCwgXCJ2aWRlby9tcDRcIik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGxvYWRJbWFnZShmaWxlOiBzdHJpbmcsIHVybDogc3RyaW5nKSB7XG4gIHJldHVybiB1cGxvYWRGaWxlKGZpbGUsIHVybCwgXCJpbWFnZS9wbmdcIik7XG59XG5cbnR5cGUgVXBsb2FkVHlwZXMgPSBcInZpZGVvL21wNFwiIHwgXCJpbWFnZS9wbmdcIiB8IFwicGxhaW4vdGV4dFwiO1xuYXN5bmMgZnVuY3Rpb24gdXBsb2FkRmlsZShmaWxlOiBzdHJpbmcsIHVybDogc3RyaW5nLCB0eXBlOiBVcGxvYWRUeXBlcykge1xuICBkZWJ1ZygndXBsb2FkaW5nIGZpbGUgXCIlc1wiIHRvIFwiJXNcIicsIGZpbGUsIHVybCk7XG4gIGNvbnN0IGYgPSBhd2FpdCByZWFkRmlsZShmaWxlKTtcbiAgYXdhaXQgbWFrZVJlcXVlc3Qoe1xuICAgIHVybCxcbiAgICBtZXRob2Q6IFwiUFVUXCIsXG4gICAgZGF0YTogZixcbiAgICBoZWFkZXJzOiB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiB0eXBlLFxuICAgICAgXCJDb250ZW50LURpc3Bvc2l0aW9uXCI6IGBpbmxpbmVgLFxuICAgIH0sXG4gIH0pO1xufVxuIiwgImltcG9ydCB7IEV2ZW50LCBwdWJzdWIgfSBmcm9tIFwiLi4vcHVic3ViXCI7XG5cbmludGVyZmFjZSBFeGVjdXRpb25TdGF0ZSB7XG4gIGNhbmNlbGxhdGlvblJlYXNvbjogc3RyaW5nIHwgbnVsbDtcbn1cbmNvbnN0IHN0YXRlOiBFeGVjdXRpb25TdGF0ZSA9IHtcbiAgY2FuY2VsbGF0aW9uUmVhc29uOiBudWxsLFxufTtcblxuZXhwb3J0IGNvbnN0IHNldENhbmNlbGxhdGlvblJlYXNvbiA9IChyZWFzb246IHN0cmluZykgPT4ge1xuICBpZiAoc3RhdGUuY2FuY2VsbGF0aW9uUmVhc29uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHN0YXRlLmNhbmNlbGxhdGlvblJlYXNvbiA9IHJlYXNvbjtcbiAgcHVic3ViLmVtaXQoRXZlbnQuUlVOX0NBTkNFTExFRCwgcmVhc29uKTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRDYW5jZWxsYXRpb25SZWFzb24gPSAoKSA9PiBzdGF0ZS5jYW5jZWxsYXRpb25SZWFzb247XG4iLCAiaW1wb3J0IHtcbiAgU3BlY1dpdGhSZWxhdGl2ZVJvb3QsXG4gIFZhbGlkYXRlZEN1cnJlbnRzUGFyYW1ldGVycyxcbn0gZnJvbSBcImN5cHJlc3MtY2xvdWQvdHlwZXNcIjtcbmltcG9ydCB7IGdldENhcHR1cmVkT3V0cHV0LCByZXNldENhcHR1cmUgfSBmcm9tIFwiLi4vY2FwdHVyZVwiO1xuXG5pbXBvcnQgeyBnZXRDeXByZXNzUnVuUmVzdWx0Rm9yU3BlYyB9IGZyb20gXCIuLi9yZXN1bHRzXCI7XG5cbmltcG9ydCBEZWJ1ZyBmcm9tIFwiZGVidWdcIjtcbmltcG9ydCB7XG4gIGNyZWF0ZUJhdGNoZWRJbnN0YW5jZXMsXG4gIGNyZWF0ZUluc3RhbmNlLFxuICBDcmVhdGVJbnN0YW5jZVBheWxvYWQsXG4gIEluc3RhbmNlUmVzcG9uc2VTcGVjRGV0YWlscyxcbn0gZnJvbSBcIi4uL2FwaVwiO1xuXG5pbXBvcnQgeyBydW5TcGVjRmlsZVNhZmUgfSBmcm9tIFwiLi4vY3lwcmVzc1wiO1xuaW1wb3J0IHsgaXNDdXJyZW50cyB9IGZyb20gXCIuLi9lbnZcIjtcbmltcG9ydCB7IGRpdmlkZXIsIGluZm8sIHRpdGxlLCB3YXJuIH0gZnJvbSBcIi4uL2xvZ1wiO1xuaW1wb3J0IHsgQ29uZmlnU3RhdGUsIEV4ZWN1dGlvblN0YXRlIH0gZnJvbSBcIi4uL3N0YXRlXCI7XG5pbXBvcnQgeyBjcmVhdGVSZXBvcnRUYXNrLCByZXBvcnRUYXNrcyB9IGZyb20gXCIuL3JlcG9ydFRhc2tcIjtcblxuY29uc3QgZGVidWcgPSBEZWJ1ZyhcImN1cnJlbnRzOnJ1bm5lclwiKTtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJ1blRpbGxEb25lKFxuICBleGVjdXRpb25TdGF0ZTogRXhlY3V0aW9uU3RhdGUsXG4gIGNvbmZpZ1N0YXRlOiBDb25maWdTdGF0ZSxcbiAge1xuICAgIHJ1bklkLFxuICAgIGdyb3VwSWQsXG4gICAgbWFjaGluZUlkLFxuICAgIHBsYXRmb3JtLFxuICAgIHNwZWNzOiBhbGxTcGVjcyxcbiAgfTogQ3JlYXRlSW5zdGFuY2VQYXlsb2FkICYge1xuICAgIHNwZWNzOiBTcGVjV2l0aFJlbGF0aXZlUm9vdFtdO1xuICB9LFxuICBwYXJhbXM6IFZhbGlkYXRlZEN1cnJlbnRzUGFyYW1ldGVyc1xuKSB7XG4gIGxldCBoYXNNb3JlID0gdHJ1ZTtcblxuICB3aGlsZSAoaGFzTW9yZSkge1xuICAgIGNvbnN0IG5ld1Rhc2tzID0gYXdhaXQgcnVuQmF0Y2goZXhlY3V0aW9uU3RhdGUsIGNvbmZpZ1N0YXRlLCB7XG4gICAgICBydW5NZXRhOiB7XG4gICAgICAgIHJ1bklkLFxuICAgICAgICBncm91cElkLFxuICAgICAgICBtYWNoaW5lSWQsXG4gICAgICAgIHBsYXRmb3JtLFxuICAgICAgfSxcbiAgICAgIGFsbFNwZWNzLFxuICAgICAgcGFyYW1zLFxuICAgIH0pO1xuICAgIGlmICghbmV3VGFza3MubGVuZ3RoKSB7XG4gICAgICBkZWJ1ZyhcIk5vIG1vcmUgdGFza3MgdG8gcnVuLiBVcGxvYWRzIHF1ZXVlOiAlZFwiLCByZXBvcnRUYXNrcy5sZW5ndGgpO1xuICAgICAgaGFzTW9yZSA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG5ld1Rhc2tzLmZvckVhY2goKHQpID0+XG4gICAgICBjcmVhdGVSZXBvcnRUYXNrKGNvbmZpZ1N0YXRlLCBleGVjdXRpb25TdGF0ZSwgdC5pbnN0YW5jZUlkKVxuICAgICk7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gcnVuQmF0Y2goXG4gIGV4ZWN1dGlvblN0YXRlOiBFeGVjdXRpb25TdGF0ZSxcbiAgY29uZmlnU3RhdGU6IENvbmZpZ1N0YXRlLFxuICB7XG4gICAgcnVuTWV0YSxcbiAgICBwYXJhbXMsXG4gICAgYWxsU3BlY3MsXG4gIH06IHtcbiAgICBydW5NZXRhOiB7XG4gICAgICBydW5JZDogc3RyaW5nO1xuICAgICAgZ3JvdXBJZDogc3RyaW5nO1xuICAgICAgbWFjaGluZUlkOiBzdHJpbmc7XG4gICAgICBwbGF0Zm9ybTogQ3JlYXRlSW5zdGFuY2VQYXlsb2FkW1wicGxhdGZvcm1cIl07XG4gICAgfTtcbiAgICBhbGxTcGVjczogU3BlY1dpdGhSZWxhdGl2ZVJvb3RbXTtcbiAgICBwYXJhbXM6IFZhbGlkYXRlZEN1cnJlbnRzUGFyYW1ldGVycztcbiAgfVxuKSB7XG4gIGxldCBiYXRjaCA9IHtcbiAgICBzcGVjczogW10gYXMgSW5zdGFuY2VSZXNwb25zZVNwZWNEZXRhaWxzW10sXG4gICAgY2xhaW1lZEluc3RhbmNlczogMCxcbiAgICB0b3RhbEluc3RhbmNlczogMCxcbiAgfTtcblxuICBpZiAoaXNDdXJyZW50cygpKSB7XG4gICAgZGVidWcoXCJHZXR0aW5nIGJhdGNoZWQgdGFza3M6ICVkXCIsIHBhcmFtcy5iYXRjaFNpemUpO1xuICAgIGJhdGNoID0gYXdhaXQgY3JlYXRlQmF0Y2hlZEluc3RhbmNlcyh7XG4gICAgICAuLi5ydW5NZXRhLFxuICAgICAgYmF0Y2hTaXplOiBwYXJhbXMuYmF0Y2hTaXplLFxuICAgIH0pO1xuICAgIGRlYnVnKFwiR290IGJhdGNoZWQgdGFza3M6ICVvXCIsIGJhdGNoKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNyZWF0ZUluc3RhbmNlKHJ1bk1ldGEpO1xuXG4gICAgaWYgKHJlc3BvbnNlLnNwZWMgIT09IG51bGwgJiYgcmVzcG9uc2UuaW5zdGFuY2VJZCAhPT0gbnVsbCkge1xuICAgICAgYmF0Y2guc3BlY3MucHVzaCh7XG4gICAgICAgIHNwZWM6IHJlc3BvbnNlLnNwZWMsXG4gICAgICAgIGluc3RhbmNlSWQ6IHJlc3BvbnNlLmluc3RhbmNlSWQsXG4gICAgICB9KTtcbiAgICB9XG4gICAgYmF0Y2guY2xhaW1lZEluc3RhbmNlcyA9IHJlc3BvbnNlLmNsYWltZWRJbnN0YW5jZXM7XG4gICAgYmF0Y2gudG90YWxJbnN0YW5jZXMgPSByZXNwb25zZS50b3RhbEluc3RhbmNlcztcbiAgfVxuXG4gIGlmIChiYXRjaC5zcGVjcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICAvKipcbiAgICogQmF0Y2ggY2FuIGhhdmUgbXVsdGlwbGUgc3BlY3MuIFdoaWxlIHJ1bm5pbmcgdGhlIHNwZWNzLFxuICAgKiBjeXByZXNzIGNhbiBoYXJkLWNyYXNoIHdpdGhvdXQgcmVwb3J0aW5nIGFueSByZXN1bHQuXG4gICAqXG4gICAqIFdoZW4gY3Jhc2hlZCwgaWRlYWxseSwgd2UgbmVlZCB0bzpcbiAgICogLSBkZXRlcm1pbmUgd2hpY2ggc3BlYyBjcmFzaGVkXG4gICAqIC0gYXNzb2NpYXRlIHRoZSBjcmFzaCB3aXRoIHRoZSBzcGVjXG4gICAqIC0gcnVuIHRoZSByZXN0IG9mIHVucmVwb3J0ZWQgc3BlY3MgaW4gdGhlIGJhdGNoXG4gICAqXG4gICAqIEJ1dCBkZXRlY3RpbmcgdGhlIGNyYXNoZWQgc3BlYyBpcyBlcnJvci1wcm9uZSBhbmQgaW5hY2N1cmF0ZSxcbiAgICogc28gd2UgZmFsbCBiYWNrIHRvIHJlcG9ydGluZyBoYXJkIGNyYXNoIHRvIGFsbCBzdWJzZXF1ZW50XG4gICAqIHNwZWNzIGluIHRoZSBiYXRjaC5cbiAgICpcbiAgICogV29yc3QtY2FzZSBzY2VuYXJpbzogd2UgcmVwb3J0IGhhcmQgY3Jhc2ggdG8gYWxsIHNwZWNzIGluIHRoZSBiYXRjaC5cbiAgICovXG5cbiAgLy8gJXN0YXRlXG4gIGJhdGNoLnNwZWNzLmZvckVhY2goKGkpID0+IGV4ZWN1dGlvblN0YXRlLmluaXRJbnN0YW5jZShpKSk7XG5cbiAgZGl2aWRlcigpO1xuICBpbmZvKFxuICAgIFwiUnVubmluZzogJXMgKCVkLyVkKVwiLFxuICAgIGJhdGNoLnNwZWNzLm1hcCgocykgPT4gcy5zcGVjKS5qb2luKFwiLCBcIiksXG4gICAgYmF0Y2guY2xhaW1lZEluc3RhbmNlcyxcbiAgICBiYXRjaC50b3RhbEluc3RhbmNlc1xuICApO1xuXG4gIGNvbnN0IHJhd1Jlc3VsdCA9IGF3YWl0IHJ1blNwZWNGaWxlU2FmZShcbiAgICB7XG4gICAgICAvLyB1c2UgYWJzb2x1dGUgcGF0aHMgLSB1c2VyIGNhbiBydW4gdGhlIHByb2dyYW0gZnJvbSBhIGRpZmZlcmVudCBkaXJlY3RvcnksIGUuZy4gbnggb3IgYSBtb25vcmVwbyB3b3Jrc3BhY2VcbiAgICAgIC8vIGN5cHJlc3Mgc3RpbGwgcmVwb3J0IHRoZSBwYXRoIHJlbGF0aXZlIHRvIHRoZSBwcm9qZWN0IHJvb3RcbiAgICAgIHNwZWM6IGJhdGNoLnNwZWNzXG4gICAgICAgIC5tYXAoKGJzKSA9PiBnZXRTcGVjQWJzb2x1dGVQYXRoKGFsbFNwZWNzLCBicy5zcGVjKSlcbiAgICAgICAgLmpvaW4oXCIsXCIpLFxuICAgIH0sXG4gICAgcGFyYW1zXG4gICk7XG5cbiAgdGl0bGUoXCJibHVlXCIsIFwiUmVwb3J0aW5nIHJlc3VsdHMgYW5kIGFydGlmYWN0cyBpbiBiYWNrZ3JvdW5kLi4uXCIpO1xuXG4gIGNvbnN0IG91dHB1dCA9IGdldENhcHR1cmVkT3V0cHV0KCk7XG5cbiAgLy8gJXN0YXRlXG4gIGJhdGNoLnNwZWNzLmZvckVhY2goKHNwZWMpID0+IHtcbiAgICBleGVjdXRpb25TdGF0ZS5zZXRJbnN0YW5jZU91dHB1dChzcGVjLmluc3RhbmNlSWQsIG91dHB1dCk7XG4gICAgY29uc3Qgc3BlY1J1blJlc3VsdCA9IGdldEN5cHJlc3NSdW5SZXN1bHRGb3JTcGVjKHNwZWMuc3BlYywgcmF3UmVzdWx0KTtcbiAgICBpZiAoIXNwZWNSdW5SZXN1bHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZXhlY3V0aW9uU3RhdGUuc2V0SW5zdGFuY2VSZXN1bHQoXG4gICAgICBjb25maWdTdGF0ZSxcbiAgICAgIHNwZWMuaW5zdGFuY2VJZCxcbiAgICAgIHNwZWNSdW5SZXN1bHRcbiAgICApO1xuICB9KTtcblxuICByZXNldENhcHR1cmUoKTtcblxuICByZXR1cm4gYmF0Y2guc3BlY3M7XG59XG5cbmZ1bmN0aW9uIGdldFNwZWNBYnNvbHV0ZVBhdGgoXG4gIGFsbFNwZWNzOiBTcGVjV2l0aFJlbGF0aXZlUm9vdFtdLFxuICByZWxhdGl2ZTogc3RyaW5nXG4pIHtcbiAgY29uc3QgYWJzb2x1dGVQYXRoID0gYWxsU3BlY3MuZmluZCgoaSkgPT4gaS5yZWxhdGl2ZSA9PT0gcmVsYXRpdmUpPy5hYnNvbHV0ZTtcbiAgaWYgKCFhYnNvbHV0ZVBhdGgpIHtcbiAgICB3YXJuKFxuICAgICAgJ0Nhbm5vdCBmaW5kIGFic29sdXRlIHBhdGggZm9yIHNwZWMuIFNwZWM6IFwiJXNcIiwgY2FuZGlkYXRlczogJW8nLFxuICAgICAgcmVsYXRpdmUsXG4gICAgICBhbGxTcGVjc1xuICAgICk7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZmluZCBhYnNvbHV0ZSBwYXRoIGZvciBzcGVjYCk7XG4gIH1cbiAgcmV0dXJuIGFic29sdXRlUGF0aDtcbn1cbiIsICJpbXBvcnQgeyBJbnN0YW5jZUlkIH0gZnJvbSBcImN5cHJlc3MtY2xvdWQvdHlwZXNcIjtcbmltcG9ydCBEZWJ1ZyBmcm9tIFwiZGVidWdcIjtcbmltcG9ydCB7IGVycm9yIH0gZnJvbSBcIi4uL2xvZ1wiO1xuaW1wb3J0IHsgZ2V0UmVwb3J0UmVzdWx0c1Rhc2sgfSBmcm9tIFwiLi4vcmVzdWx0c1wiO1xuaW1wb3J0IHsgQ29uZmlnU3RhdGUsIEV4ZWN1dGlvblN0YXRlIH0gZnJvbSBcIi4uL3N0YXRlXCI7XG5cbmNvbnN0IGRlYnVnID0gRGVidWcoXCJjdXJyZW50czpyZXBvcnRUYXNrXCIpO1xuXG5leHBvcnQgY29uc3QgcmVwb3J0VGFza3M6IFByb21pc2U8YW55PltdID0gW107XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVSZXBvcnRUYXNrID0gKFxuICBjb25maWdTdGF0ZTogQ29uZmlnU3RhdGUsXG4gIGV4ZWN1dGlvblN0YXRlOiBFeGVjdXRpb25TdGF0ZSxcbiAgaW5zdGFuY2VJZDogSW5zdGFuY2VJZFxuKSA9PiB7XG4gIGNvbnN0IGluc3RhbmNlID0gZXhlY3V0aW9uU3RhdGUuZ2V0SW5zdGFuY2UoaW5zdGFuY2VJZCk7XG4gIGlmICghaW5zdGFuY2UpIHtcbiAgICBlcnJvcihcIkNhbm5vdCBmaW5kIGV4ZWN1dGlvbiBzdGF0ZSBmb3IgaW5zdGFuY2UgJXNcIiwgaW5zdGFuY2VJZCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChpbnN0YW5jZS5yZXBvcnRTdGFydGVkQXQpIHtcbiAgICBkZWJ1ZyhcIlJlcG9ydCB0YXNrIGFscmVhZHkgY3JlYXRlZCBmb3IgaW5zdGFuY2UgJXNcIiwgaW5zdGFuY2VJZCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaW5zdGFuY2UucmVwb3J0U3RhcnRlZEF0ID0gbmV3IERhdGUoKTtcblxuICBkZWJ1ZyhcIkNyZWF0aW5nIHJlcG9ydCB0YXNrIGZvciBpbnN0YW5jZUlkICVzXCIsIGluc3RhbmNlSWQpO1xuICByZXBvcnRUYXNrcy5wdXNoKFxuICAgIGdldFJlcG9ydFJlc3VsdHNUYXNrKFxuICAgICAgaW5zdGFuY2VJZCxcbiAgICAgIGV4ZWN1dGlvblN0YXRlLmdldEluc3RhbmNlUmVzdWx0cyhjb25maWdTdGF0ZSwgaW5zdGFuY2VJZCksXG4gICAgICBpbnN0YW5jZS5vdXRwdXQgPz8gXCJubyBvdXRwdXQgY2FwdHVyZWRcIlxuICAgICkuY2F0Y2goZXJyb3IpXG4gICk7XG59O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlUmVwb3J0VGFza1NwZWMgPSAoXG4gIGNvbmZpZ1N0YXRlOiBDb25maWdTdGF0ZSxcbiAgZXhlY3V0aW9uU3RhdGU6IEV4ZWN1dGlvblN0YXRlLFxuICBzcGVjOiBzdHJpbmdcbikgPT4ge1xuICBjb25zdCBpID0gZXhlY3V0aW9uU3RhdGUuZ2V0U3BlYyhzcGVjKTtcbiAgaWYgKCFpKSB7XG4gICAgZXJyb3IoXCJDYW5ub3QgZmluZCBleGVjdXRpb24gc3RhdGUgZm9yIHNwZWMgJXNcIiwgc3BlYyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGRlYnVnKFwiQ3JlYXRpbmcgcmVwb3J0IHRhc2sgZm9yIHNwZWMgJXNcIiwgc3BlYyk7XG4gIHJldHVybiBjcmVhdGVSZXBvcnRUYXNrKGNvbmZpZ1N0YXRlLCBleGVjdXRpb25TdGF0ZSwgaS5pbnN0YW5jZUlkKTtcbn07XG4iLCAiaW1wb3J0IHsgQlByb21pc2UgfSBmcm9tIFwiLi4vbGFuZ1wiO1xuaW1wb3J0IHsgd2FybiB9IGZyb20gXCIuLi9sb2dcIjtcbmltcG9ydCB7IEV2ZW50LCBwdWJzdWIgfSBmcm9tIFwiLi4vcHVic3ViXCI7XG5pbXBvcnQgeyBydW5UaWxsRG9uZSB9IGZyb20gXCIuL3J1bm5lclwiO1xuXG5sZXQgY2FuY2VsbGFibGU6IHtcbiAgY2FuY2VsOiAoKSA9PiB2b2lkO1xufSB8IG51bGwgPSBudWxsO1xuXG5mdW5jdGlvbiBvblJ1bkNhbmNlbGxlZChyZWFzb246IHN0cmluZykge1xuICB3YXJuKFxuICAgIGBSdW4gY2FuY2VsbGVkOiAlcy4gV2FpdGluZyBmb3IgdXBsb2FkcyB0byBjb21wbGV0ZSBhbmQgc3RvcHBpbmcgZXhlY3V0aW9uLi4uYCxcbiAgICByZWFzb25cbiAgKTtcbiAgY2FuY2VsbGFibGU/LmNhbmNlbCgpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJ1blRpbGxEb25lT3JDYW5jZWxsZWQoXG4gIC4uLmFyZ3M6IFBhcmFtZXRlcnM8dHlwZW9mIHJ1blRpbGxEb25lPlxuKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgoX3Jlc29sdmUsIF9yZWplY3QpID0+IHtcbiAgICBjYW5jZWxsYWJsZSA9IG5ldyBCUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0LCBvbkNhbmNlbCkgPT4ge1xuICAgICAgaWYgKCFvbkNhbmNlbCkge1xuICAgICAgICBfcmVqZWN0KG5ldyBFcnJvcihcIkJsdWVCaXJkIGlzIG1pc2NvbmZpZ3VyZWQ6IG9uQ2FuY2VsIGlzIHVuZGVmaW5lZFwiKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG9uQ2FuY2VsKCgpID0+IF9yZXNvbHZlKHZvaWQgMCkpO1xuICAgICAgcnVuVGlsbERvbmUoLi4uYXJncykudGhlbihcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICBfcmVzb2x2ZSh2b2lkIDApO1xuICAgICAgICB9LFxuICAgICAgICAoZXJyb3IpID0+IHtcbiAgICAgICAgICByZWplY3QoKTtcbiAgICAgICAgICBfcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHB1YnN1Yi5hZGRMaXN0ZW5lcihFdmVudC5SVU5fQ0FOQ0VMTEVELCBvblJ1bkNhbmNlbGxlZCk7XG4gIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgIHB1YnN1Yi5yZW1vdmVMaXN0ZW5lcihFdmVudC5SVU5fQ0FOQ0VMTEVELCBvblJ1bkNhbmNlbGxlZCk7XG4gIH0pO1xufVxuIiwgImltcG9ydCB7IHN0b3BXU1MgfSBmcm9tIFwiLi93c1wiO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2h1dGRvd24oKSB7XG4gIGF3YWl0IHN0b3BXU1MoKTtcbn1cbiIsICIvKiEgQHByZXNlcnZlXG5cbiMjIyBNSVRcblxuUGFydHMgb2YgdGhpcyBjb2RlIHdhcyBjb3BpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vY3lwcmVzcy1pby9jeXByZXNzIGFuZCBpcyBzdWJqZWN0IHRvIE1JVCBsaWNlbnNlLlxuXG5NSVQgTGljZW5zZVxuXG5Db3B5cmlnaHQgKGMpIDIwMjIgQ3lwcmVzcy5pb1xuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuU09GVFdBUkUuXG4qL1xuXG5pbXBvcnQgRGVidWcgZnJvbSBcImRlYnVnXCI7XG5pbXBvcnQgcGF0aCBmcm9tIFwicGF0aFwiO1xuXG5pbXBvcnQgY29tbW9uUGF0aFByZWZpeCBmcm9tIFwiY29tbW9uLXBhdGgtcHJlZml4XCI7XG5pbXBvcnQgZ2xvYmJ5LCB7IEdsb2JieU9wdGlvbnMgfSBmcm9tIFwiZ2xvYmJ5XCI7XG5pbXBvcnQgXyBmcm9tIFwibG9kYXNoXCI7XG5pbXBvcnQgb3MgZnJvbSBcIm9zXCI7XG5pbXBvcnQge1xuICBGaW5kU3BlY3MsXG4gIFNwZWNUeXBlLFxuICBTcGVjV2l0aFJlbGF0aXZlUm9vdCxcbiAgVGVzdGluZ1R5cGUsXG59IGZyb20gXCIuLi8uLi90eXBlc1wiO1xuaW1wb3J0IHsgdG9BcnJheSwgdG9Qb3NpeCB9IGZyb20gXCIuLi91dGlsc1wiO1xuXG5jb25zdCBkZWJ1ZyA9IERlYnVnKFwiY3VycmVudHM6c3BlY3NcIik7XG5cbnR5cGUgR2xvYlBhdHRlcm4gPSBzdHJpbmcgfCBzdHJpbmdbXTtcblxuLyoqXG4gKiBSZXBsaWNhdGUgaG93IGN5cHJlc3MgaXMgZGlzY292ZXJpbmcgc3BlYyBmaWxlc1xuICogaHR0cHM6Ly9naXRodWIuY29tL2N5cHJlc3MtaW8vY3lwcmVzcy9ibG9iL2JjOWVkYjQ0NTIzZDYyY2E5MzQ4MjdiOGU4NzBmMzhmODY2MzRjYTQvcGFja2FnZXMvZGF0YS1jb250ZXh0L3NyYy9zb3VyY2VzL1Byb2plY3REYXRhU291cmNlLnRzI0wyNTBcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jeXByZXNzLWlvL2N5cHJlc3MvYmxvYi9iYzllZGI0NDUyM2Q2MmNhOTM0ODI3YjhlODcwZjM4Zjg2NjM0Y2E0L3BhY2thZ2VzL2RhdGEtY29udGV4dC9zcmMvYWN0aW9ucy9Qcm9qZWN0QWN0aW9ucy50cyNMNDE3XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmaW5kU3BlY3Moe1xuICBwcm9qZWN0Um9vdCxcbiAgdGVzdGluZ1R5cGUsXG4gIHNwZWNQYXR0ZXJuLFxuICBjb25maWdTcGVjUGF0dGVybixcbiAgZXhjbHVkZVNwZWNQYXR0ZXJuLFxuICBhZGRpdGlvbmFsSWdub3JlUGF0dGVybixcbn06IEZpbmRTcGVjczxzdHJpbmdbXSB8IHN0cmluZz4pOiBQcm9taXNlPFNwZWNXaXRoUmVsYXRpdmVSb290W10+IHtcbiAgY29uZmlnU3BlY1BhdHRlcm4gPSB0b0FycmF5KGNvbmZpZ1NwZWNQYXR0ZXJuKTtcbiAgc3BlY1BhdHRlcm4gPSB0b0FycmF5KHNwZWNQYXR0ZXJuKTtcbiAgZXhjbHVkZVNwZWNQYXR0ZXJuID0gdG9BcnJheShleGNsdWRlU3BlY1BhdHRlcm4pIHx8IFtdO1xuXG4gIC8vIGV4Y2x1ZGUgYWxsIHNwZWNzIG1hdGNoaW5nIGUyZSBpZiBpbiBjb21wb25lbnQgdGVzdGluZ1xuICBhZGRpdGlvbmFsSWdub3JlUGF0dGVybiA9IHRvQXJyYXkoYWRkaXRpb25hbElnbm9yZVBhdHRlcm4pIHx8IFtdO1xuXG4gIGRlYnVnKFwiZXhwbG9yaW5nIHNwZWMgZmlsZXMgZm9yIGV4ZWN1dGlvbiAlT1wiLCB7XG4gICAgdGVzdGluZ1R5cGUsXG4gICAgcHJvamVjdFJvb3QsXG4gICAgc3BlY1BhdHRlcm4sXG4gICAgY29uZmlnU3BlY1BhdHRlcm4sXG4gICAgZXhjbHVkZVNwZWNQYXR0ZXJuLFxuICAgIGFkZGl0aW9uYWxJZ25vcmVQYXR0ZXJuLFxuICB9KTtcblxuICBpZiAoIXNwZWNQYXR0ZXJuIHx8ICFjb25maWdTcGVjUGF0dGVybikge1xuICAgIHRocm93IEVycm9yKFwiQ291bGQgbm90IGZpbmQgZ2xvYiBwYXR0ZXJucyBmb3IgZXhwbG9yaW5nIHNwZWNzXCIpO1xuICB9XG5cbiAgbGV0IHNwZWNBYnNvbHV0ZVBhdGhzID0gYXdhaXQgZ2V0RmlsZXNCeUdsb2IocHJvamVjdFJvb3QsIHNwZWNQYXR0ZXJuLCB7XG4gICAgYWJzb2x1dGU6IHRydWUsXG4gICAgaWdub3JlOiBbLi4uZXhjbHVkZVNwZWNQYXR0ZXJuLCAuLi5hZGRpdGlvbmFsSWdub3JlUGF0dGVybl0sXG4gIH0pO1xuXG4gIC8vIElmIHRoZSBzcGVjUGF0dGVybiBhbmQgY29uZmlnU3BlY1BhdHRlcm4gYXJlIGRpZmZlcmVudCxcbiAgLy8gaXQgbWVhbnMgdGhlIHVzZXIgcGFzc2VkIHNvbWV0aGluZyBub24tZGVmYXVsdCB2aWEgLS1zcGVjIChydW4gbW9kZSBvbmx5KVxuICAvLyBpbiB0aGlzIHNjZW5hcmlvLCB3ZSB3YW50IHRvIGdyYWIgZXZlcnl0aGluZyB0aGF0IG1hdGNoZXMgYC0tc3BlY2BcbiAgLy8gdGhhdCBmYWxscyB3aXRoaW4gdGhlaXIgZGVmYXVsdCBzcGVjUGF0dGVybi4gVGhlIHJlYXNvbiBpcyBzbyB3ZSBhdm9pZFxuICAvLyBhdHRlbXB0aW5nIHRvIHJ1biB0aGluZ3MgdGhhdCBhcmUgbm90IHNwZWNzLCBlZyBzb3VyY2UgY29kZSwgdmlkZW9zLCBldGMuXG4gIC8vXG4gIC8vIEV4YW1wbGU6IGRldmVsb3BlciB3YW50cyB0byBydW4gdGVzdHMgYXNzb2NpYXRlZCB3aXRoIHRpbWVycyBpbiBwYWNrYWdlcy9kcml2ZXJcbiAgLy8gU28gdGhleSBydW4geWFybiBjeXByZXNzOnJ1biAtLXNwZWMgKiovdGltZXJzKlxuICAvLyB3ZSBkbyAqKm5vdCoqIHdhbnQgdG8gY2FwdHVyZSBgdGltZXJzLnRzYCAoc291cmNlIGNvZGUpIG9yIGEgdmlkZW8gaW5cbiAgLy8gY3lwcmVzcy92aWRlb3MvdGltZXJzLmN5LnRzLm1wNCwgc28gd2UgdGFrZSB0aGUgaW50ZXJzZWN0aW9uIGJldHdlZW4gc3BlY1BhdHRlcm5cbiAgLy8gYW5kIC0tc3BlYy5cbiAgaWYgKCFfLmlzRXF1YWwoc3BlY1BhdHRlcm4sIGNvbmZpZ1NwZWNQYXR0ZXJuKSkge1xuICAgIGNvbnN0IGRlZmF1bHRTcGVjQWJzb2x1dGVQYXRocyA9IGF3YWl0IGdldEZpbGVzQnlHbG9iKFxuICAgICAgcHJvamVjdFJvb3QsXG4gICAgICBjb25maWdTcGVjUGF0dGVybixcbiAgICAgIHtcbiAgICAgICAgYWJzb2x1dGU6IHRydWUsXG4gICAgICAgIGlnbm9yZTogWy4uLmV4Y2x1ZGVTcGVjUGF0dGVybiwgLi4uYWRkaXRpb25hbElnbm9yZVBhdHRlcm5dLFxuICAgICAgfVxuICAgICk7XG5cbiAgICBzcGVjQWJzb2x1dGVQYXRocyA9IF8uaW50ZXJzZWN0aW9uKFxuICAgICAgc3BlY0Fic29sdXRlUGF0aHMsXG4gICAgICBkZWZhdWx0U3BlY0Fic29sdXRlUGF0aHNcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIG1hdGNoZWRTcGVjcyh7XG4gICAgcHJvamVjdFJvb3QsXG4gICAgdGVzdGluZ1R5cGUsXG4gICAgc3BlY0Fic29sdXRlUGF0aHMsXG4gICAgc3BlY1BhdHRlcm4sXG4gIH0pO1xufVxuXG5hc3luYyBmdW5jdGlvbiBnZXRGaWxlc0J5R2xvYihcbiAgcHJvamVjdFJvb3Q6IHN0cmluZyxcbiAgZ2xvYjogR2xvYlBhdHRlcm4sXG4gIGdsb2JPcHRpb25zOiBHbG9iYnlPcHRpb25zXG4pIHtcbiAgY29uc3Qgd29ya2luZ0RpcmVjdG9yeVByZWZpeCA9IHBhdGguam9pbihwcm9qZWN0Um9vdCwgcGF0aC5zZXApO1xuICBjb25zdCBnbG9icyA9IChbXSBhcyBzdHJpbmdbXSlcbiAgICAuY29uY2F0KGdsb2IpXG4gICAgLm1hcCgoZ2xvYlBhdHRlcm4pID0+XG4gICAgICBnbG9iUGF0dGVybi5zdGFydHNXaXRoKFwiLi9cIikgPyBnbG9iUGF0dGVybi5yZXBsYWNlKFwiLi9cIiwgXCJcIikgOiBnbG9iUGF0dGVyblxuICAgIClcbiAgICAubWFwKChnbG9iUGF0dGVybikgPT4ge1xuICAgICAgLy8gSWYgdGhlIHBhdHRlcm4gaW5jbHVkZXMgdGhlIHdvcmtpbmcgZGlyZWN0b3J5LCB3ZSBzdHJpcCBpdCBmcm9tIHRoZSBwYXR0ZXJuLlxuICAgICAgLy8gVGhlIHdvcmtpbmcgZGlyZWN0b3J5IHBhdGggbWF5IGluY2x1ZGUgY2hhcmFjdGVycyB0aGF0IGNvbmZsaWN0IHdpdGggZ2xvYlxuICAgICAgLy8gc3ludGF4IChicmFja2V0cywgcGFyZW50aGVzZXMsIGV0Yy4pIGFuZCBjYXVzZSBvdXIgc2VhcmNoZXMgdG8gaW5hZHZlcnRlbnRseSBmYWlsLlxuICAgICAgLy8gV2Ugc2NvcGUgb3VyIHNlYXJjaCB0byB0aGUgd29ya2luZyBkaXJlY3RvcnkgdXNpbmcgdGhlIGBjd2RgIGdsb2JieSBvcHRpb24uXG4gICAgICBpZiAoZ2xvYlBhdHRlcm4uc3RhcnRzV2l0aCh3b3JraW5nRGlyZWN0b3J5UHJlZml4KSkge1xuICAgICAgICByZXR1cm4gZ2xvYlBhdHRlcm4ucmVwbGFjZSh3b3JraW5nRGlyZWN0b3J5UHJlZml4LCBcIlwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdsb2JQYXR0ZXJuO1xuICAgIH0pO1xuXG4gIGlmIChvcy5wbGF0Zm9ybSgpID09PSBcIndpbjMyXCIpIHtcbiAgICAvLyBnbG9iYnkgY2FuJ3Qgd29yayB3aXRoIGJhY2t3YXJkcyBzbGFzaGVzXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9nbG9iYnkvaXNzdWVzLzE3OVxuICAgIGRlYnVnKFwidXBkYXRpbmcgZ2xvYiBwYXR0ZXJucyB0byBQT1NJWFwiKTtcbiAgICBmb3IgKGNvbnN0IGkgaW4gZ2xvYnMpIHtcbiAgICAgIGNvbnN0IGN1ciA9IGdsb2JzW2ldO1xuXG4gICAgICBpZiAoIWN1cikgdGhyb3cgbmV3IEVycm9yKFwidW5kZWZpbmVkIGdsb2IgcmVjZWl2ZWRcIik7XG5cbiAgICAgIGdsb2JzW2ldID0gdG9Qb3NpeChjdXIpO1xuICAgIH1cbiAgfVxuXG4gIHRyeSB7XG4gICAgZGVidWcoXCJnbG9iYmluZyBwYXR0ZXJuKHMpOiAlb1wiLCBnbG9icyk7XG4gICAgZGVidWcoXCJ3aXRoaW4gZGlyZWN0b3J5OiAlc1wiLCBwcm9qZWN0Um9vdCk7XG5cbiAgICByZXR1cm4gbWF0Y2hHbG9icyhnbG9icywge1xuICAgICAgb25seUZpbGVzOiB0cnVlLFxuICAgICAgYWJzb2x1dGU6IHRydWUsXG4gICAgICBjd2Q6IHByb2plY3RSb290LFxuICAgICAgLi4uZ2xvYk9wdGlvbnMsXG4gICAgICBpZ25vcmU6IChnbG9iT3B0aW9ucz8uaWdub3JlID8/IFtdKS5jb25jYXQoXCIqKi9ub2RlX21vZHVsZXMvKipcIiksXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBkZWJ1ZyhcImVycm9yIGluIGdldEZpbGVzQnlHbG9iICVvXCIsIGUpO1xuICAgIHJldHVybiBbXTtcbiAgfVxufVxuXG5jb25zdCBtYXRjaEdsb2JzID0gYXN5bmMgKGdsb2JzOiBHbG9iUGF0dGVybiwgZ2xvYmJ5T3B0aW9uczogR2xvYmJ5T3B0aW9ucykgPT4ge1xuICByZXR1cm4gYXdhaXQgZ2xvYmJ5KGdsb2JzLCBnbG9iYnlPcHRpb25zKTtcbn07XG5cbmludGVyZmFjZSBNYXRjaGVkU3BlY3Mge1xuICBwcm9qZWN0Um9vdDogc3RyaW5nO1xuICB0ZXN0aW5nVHlwZTogVGVzdGluZ1R5cGU7XG4gIHNwZWNBYnNvbHV0ZVBhdGhzOiBzdHJpbmdbXTtcbiAgc3BlY1BhdHRlcm46IHN0cmluZyB8IHN0cmluZ1tdO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVkU3BlY3Moe1xuICBwcm9qZWN0Um9vdCxcbiAgdGVzdGluZ1R5cGUsXG4gIHNwZWNBYnNvbHV0ZVBhdGhzLFxufTogTWF0Y2hlZFNwZWNzKSB7XG4gIGRlYnVnKFwiZm91bmQgc3BlY3MgJW9cIiwgc3BlY0Fic29sdXRlUGF0aHMpO1xuXG4gIGxldCBjb21tb25Sb290ID0gXCJcIjtcblxuICBpZiAoc3BlY0Fic29sdXRlUGF0aHMubGVuZ3RoID09PSAxKSB7XG4gICAgY29tbW9uUm9vdCA9IHBhdGguZGlybmFtZShzcGVjQWJzb2x1dGVQYXRoc1swXSk7XG4gIH0gZWxzZSB7XG4gICAgY29tbW9uUm9vdCA9IGNvbW1vblBhdGhQcmVmaXgoc3BlY0Fic29sdXRlUGF0aHMpO1xuICB9XG5cbiAgcmV0dXJuIHNwZWNBYnNvbHV0ZVBhdGhzLm1hcCgoYWJzb2x1dGUpID0+XG4gICAgdHJhbnNmb3JtU3BlYyh7XG4gICAgICBwcm9qZWN0Um9vdCxcbiAgICAgIGFic29sdXRlLFxuICAgICAgdGVzdGluZ1R5cGUsXG4gICAgICBjb21tb25Sb290LFxuICAgICAgcGxhdGZvcm06IG9zLnBsYXRmb3JtKCksXG4gICAgICBzZXA6IHBhdGguc2VwLFxuICAgIH0pXG4gICk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNmb3JtU3BlYyB7XG4gIHByb2plY3RSb290OiBzdHJpbmc7XG4gIGFic29sdXRlOiBzdHJpbmc7XG4gIHRlc3RpbmdUeXBlOiBUZXN0aW5nVHlwZTtcbiAgY29tbW9uUm9vdDogc3RyaW5nO1xuICBwbGF0Zm9ybTogTm9kZUpTLlBsYXRmb3JtO1xuICBzZXA6IHN0cmluZztcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtU3BlYyh7XG4gIHByb2plY3RSb290LFxuICBhYnNvbHV0ZSxcbiAgdGVzdGluZ1R5cGUsXG4gIGNvbW1vblJvb3QsXG4gIHBsYXRmb3JtLFxuICBzZXAsXG59OiBUcmFuc2Zvcm1TcGVjKSB7XG4gIGlmIChwbGF0Zm9ybSA9PT0gXCJ3aW4zMlwiKSB7XG4gICAgYWJzb2x1dGUgPSB0b1Bvc2l4KGFic29sdXRlLCBzZXApO1xuICAgIHByb2plY3RSb290ID0gdG9Qb3NpeChwcm9qZWN0Um9vdCwgc2VwKTtcbiAgfVxuXG4gIGNvbnN0IHJlbGF0aXZlID0gcGF0aC5yZWxhdGl2ZShwcm9qZWN0Um9vdCwgYWJzb2x1dGUpO1xuICBjb25zdCBwYXJzZWRGaWxlID0gcGF0aC5wYXJzZShhYnNvbHV0ZSk7XG4gIGNvbnN0IGZpbGVFeHRlbnNpb24gPSBwYXRoLmV4dG5hbWUoYWJzb2x1dGUpO1xuXG4gIGNvbnN0IHNwZWNGaWxlRXh0ZW5zaW9uID1cbiAgICBbXCIuc3BlY1wiLCBcIi50ZXN0XCIsIFwiLXNwZWNcIiwgXCItdGVzdFwiLCBcIi5jeVwiXVxuICAgICAgLm1hcCgoZXh0KSA9PiBleHQgKyBmaWxlRXh0ZW5zaW9uKVxuICAgICAgLmZpbmQoKGV4dCkgPT4gYWJzb2x1dGUuZW5kc1dpdGgoZXh0KSkgfHwgZmlsZUV4dGVuc2lvbjtcblxuICBjb25zdCBwYXJ0cyA9IGFic29sdXRlLnNwbGl0KHByb2plY3RSb290KTtcbiAgbGV0IG5hbWUgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXSB8fCBcIlwiO1xuXG4gIGlmIChuYW1lLnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgbmFtZSA9IG5hbWUuc2xpY2UoMSk7XG4gIH1cblxuICBjb25zdCBMRUFESU5HX1NMQVNIID0gL15cXC98L2c7XG4gIGNvbnN0IHJlbGF0aXZlVG9Db21tb25Sb290ID0gYWJzb2x1dGVcbiAgICAucmVwbGFjZShjb21tb25Sb290LCBcIlwiKVxuICAgIC5yZXBsYWNlKExFQURJTkdfU0xBU0gsIFwiXCIpO1xuXG4gIHJldHVybiB7XG4gICAgZmlsZUV4dGVuc2lvbixcbiAgICBiYXNlTmFtZTogcGFyc2VkRmlsZS5iYXNlLFxuICAgIGZpbGVOYW1lOiBwYXJzZWRGaWxlLmJhc2UucmVwbGFjZShzcGVjRmlsZUV4dGVuc2lvbiwgXCJcIiksXG4gICAgc3BlY0ZpbGVFeHRlbnNpb24sXG4gICAgcmVsYXRpdmVUb0NvbW1vblJvb3QsXG4gICAgc3BlY1R5cGU6ICh0ZXN0aW5nVHlwZSA9PT0gXCJjb21wb25lbnRcIlxuICAgICAgPyBcImNvbXBvbmVudFwiXG4gICAgICA6IFwiaW50ZWdyYXRpb25cIikgYXMgU3BlY1R5cGUsXG4gICAgbmFtZSxcbiAgICByZWxhdGl2ZSxcbiAgICBhYnNvbHV0ZSxcbiAgfTtcbn1cbiIsICJpbXBvcnQgcGF0aCBmcm9tIFwicGF0aFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gdG9BcnJheSh2YWw/OiBzdHJpbmcgfCBzdHJpbmdbXSkge1xuICByZXR1cm4gdmFsID8gKHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIgPyBbdmFsXSA6IHZhbCkgOiBbXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvUG9zaXgoZmlsZTogc3RyaW5nLCBzZXA6IHN0cmluZyA9IHBhdGguc2VwKSB7XG4gIHJldHVybiBmaWxlLnNwbGl0KHNlcCkuam9pbihwYXRoLnBvc2l4LnNlcCk7XG59XG4iLCAiaW1wb3J0IHtcbiAgQ3VycmVudHNSdW5QYXJhbWV0ZXJzLFxuICBWYWxpZGF0ZWRDdXJyZW50c1BhcmFtZXRlcnMsXG59IGZyb20gXCJjeXByZXNzLWNsb3VkL3R5cGVzXCI7XG5pbXBvcnQgeyBNZXJnZWRDb25maWcgfSBmcm9tIFwiLi4vY29uZmlnL2NvbmZpZ1wiO1xuaW1wb3J0IHsgd2FybiB9IGZyb20gXCIuLi9sb2dcIjtcbmltcG9ydCB7IGZpbmRTcGVjcyB9IGZyb20gXCIuL3NwZWNNYXRjaGVyXCI7XG5cbmV4cG9ydCBjb25zdCBnZXRTcGVjRmlsZXMgPSBhc3luYyAoe1xuICBjb25maWcsXG4gIHBhcmFtcyxcbn06IHtcbiAgY29uZmlnOiBNZXJnZWRDb25maWc7XG4gIHBhcmFtczogVmFsaWRhdGVkQ3VycmVudHNQYXJhbWV0ZXJzO1xufSkgPT4ge1xuICBjb25zdCBzcGVjUGF0dGVybiA9IGdldFNwZWNQYXR0ZXJuKGNvbmZpZy5zcGVjUGF0dGVybiwgcGFyYW1zLnNwZWMpO1xuICAvLyBmaW5kIHRoZSBzcGVjIGZpbGVzIGFjY29yZGluZyB0byB0aGUgcmVzb2x2ZWQgY29uZmlndXJhdGlvblxuICBjb25zdCBzcGVjcyA9IGF3YWl0IGZpbmRTcGVjcyh7XG4gICAgLy8gaHR0cHM6Ly9kb2NzLmN5cHJlc3MuaW8vZ3VpZGVzL2d1aWRlcy9jb21tYW5kLWxpbmUjY3lwcmVzcy1ydW4tc3BlYy1sdC1zcGVjLWd0XG4gICAgcHJvamVjdFJvb3Q6IHBhcmFtcy5wcm9qZWN0ID8/IGNvbmZpZy5wcm9qZWN0Um9vdCxcbiAgICB0ZXN0aW5nVHlwZTogcGFyYW1zLnRlc3RpbmdUeXBlLFxuICAgIHNwZWNQYXR0ZXJuLFxuICAgIGNvbmZpZ1NwZWNQYXR0ZXJuOiBjb25maWcuc3BlY1BhdHRlcm4sXG4gICAgZXhjbHVkZVNwZWNQYXR0ZXJuOiBjb25maWcuZXhjbHVkZVNwZWNQYXR0ZXJuLFxuICAgIGFkZGl0aW9uYWxJZ25vcmVQYXR0ZXJuOiBjb25maWcuYWRkaXRpb25hbElnbm9yZVBhdHRlcm4sXG4gIH0pO1xuICBpZiAoc3BlY3MubGVuZ3RoID09PSAwKSB7XG4gICAgd2FybihcbiAgICAgIFwiRm91bmQgbm8gc3BlYyBmaWxlcy4gV2FzIGxvb2tpbmcgZm9yIHNwZWMgZmlsZXMgdGhhdCBtYXRjaCBib3RoIGNvbmZpZ1NwZWNQYXR0ZXJuIGFuZCBzcGVjUGF0dGVybiByZWxhdGl2ZSB0byBwcm9qZWN0Um9vdC4gQ29uZmlndXJhdGlvbjogJU9cIixcbiAgICAgIHtcbiAgICAgICAgcHJvamVjdFJvb3Q6IGNvbmZpZy5wcm9qZWN0Um9vdCxcbiAgICAgICAgc3BlY1BhdHRlcm4sXG4gICAgICAgIGNvbmZpZ1NwZWNQYXR0ZXJuOiBjb25maWcuc3BlY1BhdHRlcm4sXG4gICAgICAgIGV4Y2x1ZGVTcGVjUGF0dGVybjogW1xuICAgICAgICAgIGNvbmZpZy5leGNsdWRlU3BlY1BhdHRlcm4sXG4gICAgICAgICAgY29uZmlnLmFkZGl0aW9uYWxJZ25vcmVQYXR0ZXJuLFxuICAgICAgICBdLmZsYXQoMiksXG4gICAgICAgIHRlc3RpbmdUeXBlOiBwYXJhbXMudGVzdGluZ1R5cGUsXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICByZXR1cm4geyBzcGVjcywgc3BlY1BhdHRlcm4gfTtcbn07XG5cbmZ1bmN0aW9uIGdldFNwZWNQYXR0ZXJuKFxuICBjb25maWdQYXR0ZXJuOiBNZXJnZWRDb25maWdbXCJzcGVjUGF0dGVyblwiXSxcbiAgZXhwbGljaXQ/OiBDdXJyZW50c1J1blBhcmFtZXRlcnNbXCJzcGVjXCJdXG4pIHtcbiAgcmV0dXJuIGV4cGxpY2l0IHx8IGNvbmZpZ1BhdHRlcm47XG59XG4iLCAiZXhwb3J0IGNsYXNzIENvbmZpZ1N0YXRlIHtcbiAgcHJpdmF0ZSBfY29uZmlnOiBDeXByZXNzLlJlc29sdmVkQ29uZmlnT3B0aW9ucyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgcHVibGljIHNldENvbmZpZyhjOiB0eXBlb2YgdGhpcy5fY29uZmlnKSB7XG4gICAgdGhpcy5fY29uZmlnID0gYztcbiAgfVxuICBwdWJsaWMgZ2V0Q29uZmlnKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25maWc7XG4gIH1cbn1cbiIsICJpbXBvcnQge1xuICBDeXByZXNzUnVuLFxuICBDeXByZXNzU2NyZWVuc2hvdCxcbiAgQ3lwcmVzc1Rlc3QsXG4gIEN5cHJlc3NUZXN0QXR0ZW1wdCxcbn0gZnJvbSBcImN5cHJlc3MtY2xvdWQvdHlwZXNcIjtcblxuaW1wb3J0ICogYXMgU3BlY0FmdGVyIGZyb20gXCIuLi9ydW5uZXIvc3BlYy50eXBlXCI7XG5pbXBvcnQgeyBDb25maWdTdGF0ZSB9IGZyb20gXCIuLi9zdGF0ZVwiO1xuaW1wb3J0IHsgZ2V0RmFrZVRlc3RGcm9tRXhjZXB0aW9uIH0gZnJvbSBcIi4vcmVzdWx0c1wiO1xuXG5mdW5jdGlvbiBnZXRTY3JlZW5zaG90KHM6IFNwZWNBZnRlci5TY3JlZW5zaG90KTogQ3lwcmVzc1NjcmVlbnNob3Qge1xuICByZXR1cm4ge1xuICAgIC4uLnMsXG4gICAgbmFtZTogcy5uYW1lID8/IFwic2NyZWVuc2hvdFwiLFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRUZXN0QXR0ZW1wdChcbiAgYXR0ZW1wdDogU3BlY0FmdGVyLlRlc3RBdHRlbXB0LFxuICBzY3JlZW5zaG90czogU3BlY0FmdGVyLlNjcmVlbnNob3RbXVxuKTogQ3lwcmVzc1Rlc3RBdHRlbXB0IHtcbiAgcmV0dXJuIHtcbiAgICAuLi5hdHRlbXB0LFxuICAgIHN0YXJ0ZWRBdDogYXR0ZW1wdC53YWxsQ2xvY2tTdGFydGVkQXQsXG4gICAgZHVyYXRpb246IGF0dGVtcHQud2FsbENsb2NrRHVyYXRpb24sXG4gICAgc2NyZWVuc2hvdHM6IHNjcmVlbnNob3RzLm1hcChnZXRTY3JlZW5zaG90KSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0VGVzdChcbiAgdDogU3BlY0FmdGVyLlRlc3QsXG4gIHNjcmVlbnNob3RzOiBTcGVjQWZ0ZXIuU2NyZWVuc2hvdFtdXG4pOiBDeXByZXNzVGVzdCB7XG4gIGNvbnN0IF9zY3JlZW5zaG90cyA9IHNjcmVlbnNob3RzLmZpbHRlcigocykgPT4gcy50ZXN0SWQgPT09IHQudGVzdElkKTtcbiAgcmV0dXJuIHtcbiAgICAuLi50LFxuICAgIGF0dGVtcHRzOiB0LmF0dGVtcHRzLm1hcCgoYSwgaSkgPT5cbiAgICAgIGdldFRlc3RBdHRlbXB0KFxuICAgICAgICBhLFxuICAgICAgICBfc2NyZWVuc2hvdHMuZmlsdGVyKChzKSA9PiBzLnRlc3RBdHRlbXB0SW5kZXggPT09IGkpXG4gICAgICApXG4gICAgKSxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNwZWNSZXN1bHRzVG9DeXByZXNzUmVzdWx0cyhcbiAgY29uZmlnU3RhdGU6IENvbmZpZ1N0YXRlLFxuICBzcGVjQWZ0ZXJSZXN1bHQ6IFNwZWNBZnRlci5TcGVjUmVzdWx0XG4pOiBDeXByZXNzQ29tbWFuZExpbmUuQ3lwcmVzc1J1blJlc3VsdCB7XG4gIHJldHVybiB7XG4gICAgc3RhdHVzOiBcImZpbmlzaGVkXCIsXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbmZpZzogY29uZmlnU3RhdGUuZ2V0Q29uZmlnKCksXG4gICAgdG90YWxEdXJhdGlvbjogc3BlY0FmdGVyUmVzdWx0LnN0YXRzLndhbGxDbG9ja0R1cmF0aW9uLFxuICAgIHRvdGFsU3VpdGVzOiBzcGVjQWZ0ZXJSZXN1bHQuc3RhdHMuc3VpdGVzLFxuICAgIHRvdGFsVGVzdHM6IHNwZWNBZnRlclJlc3VsdC5zdGF0cy50ZXN0cyxcbiAgICB0b3RhbEZhaWxlZDogc3BlY0FmdGVyUmVzdWx0LnN0YXRzLmZhaWx1cmVzLFxuICAgIHRvdGFsUGFzc2VkOiBzcGVjQWZ0ZXJSZXN1bHQuc3RhdHMucGFzc2VzLFxuICAgIHRvdGFsUGVuZGluZzogc3BlY0FmdGVyUmVzdWx0LnN0YXRzLnBlbmRpbmcsXG4gICAgdG90YWxTa2lwcGVkOiBzcGVjQWZ0ZXJSZXN1bHQuc3RhdHMuc2tpcHBlZCxcbiAgICBzdGFydGVkVGVzdHNBdDogc3BlY0FmdGVyUmVzdWx0LnN0YXRzLndhbGxDbG9ja1N0YXJ0ZWRBdCxcbiAgICBlbmRlZFRlc3RzQXQ6IHNwZWNBZnRlclJlc3VsdC5zdGF0cy53YWxsQ2xvY2tFbmRlZEF0LFxuICAgIHJ1bnM6IFtcbiAgICAgIHtcbiAgICAgICAgc3RhdHM6IHtcbiAgICAgICAgICAuLi5zcGVjQWZ0ZXJSZXN1bHQuc3RhdHMsXG4gICAgICAgICAgc3RhcnRlZEF0OiBzcGVjQWZ0ZXJSZXN1bHQuc3RhdHMud2FsbENsb2NrU3RhcnRlZEF0LFxuICAgICAgICAgIGVuZGVkQXQ6IHNwZWNBZnRlclJlc3VsdC5zdGF0cy53YWxsQ2xvY2tFbmRlZEF0LFxuICAgICAgICAgIGR1cmF0aW9uOiBzcGVjQWZ0ZXJSZXN1bHQuc3RhdHMud2FsbENsb2NrRHVyYXRpb24sXG4gICAgICAgIH0sXG4gICAgICAgIHJlcG9ydGVyOiBzcGVjQWZ0ZXJSZXN1bHQucmVwb3J0ZXIsXG4gICAgICAgIHJlcG9ydGVyU3RhdHM6IHNwZWNBZnRlclJlc3VsdC5yZXBvcnRlclN0YXRzID8/IHt9LFxuICAgICAgICBzcGVjOiBzcGVjQWZ0ZXJSZXN1bHQuc3BlYyxcbiAgICAgICAgZXJyb3I6IHNwZWNBZnRlclJlc3VsdC5lcnJvcixcbiAgICAgICAgdmlkZW86IHNwZWNBZnRlclJlc3VsdC52aWRlbyxcbiAgICAgICAgc2hvdWxkVXBsb2FkVmlkZW86IHRydWUsIC8vIG5vdCByZWFsbHkgdXNlZFxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIC8vIHdyb25nIHR5cGVkZWYgZm9yIEN5cHJlc3NDb21tYW5kTGluZS5DeXByZXNzUnVuUmVzdWx0XG4gICAgICAgIC8vIGFjdHVhbCBIb29rTmFtZSBpcyBcImJlZm9yZSBhbGxcIiB8IFwiYmVmb3JlIGVhY2hcIiB8IFwiYWZ0ZXIgYWxsXCIgfCBcImFmdGVyIGVhY2hcIlxuICAgICAgICBob29rczogc3BlY0FmdGVyUmVzdWx0Lmhvb2tzLFxuICAgICAgICB0ZXN0czogKHNwZWNBZnRlclJlc3VsdC50ZXN0cyA/PyBbXSkubWFwKCh0KSA9PlxuICAgICAgICAgIGdldFRlc3QodCwgc3BlY0FmdGVyUmVzdWx0LnNjcmVlbnNob3RzKVxuICAgICAgICApLFxuICAgICAgfSxcbiAgICBdLFxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgYmFja2ZpbGxFeGNlcHRpb24gPSAoXG4gIHJlc3VsdDogQ3lwcmVzc0NvbW1hbmRMaW5lLkN5cHJlc3NSdW5SZXN1bHRcbikgPT4ge1xuICByZXR1cm4ge1xuICAgIC4uLnJlc3VsdCxcbiAgICBydW5zOiByZXN1bHQucnVucy5tYXAoYmFja2ZpbGxFeGNlcHRpb25SdW4pLFxuICB9O1xufTtcblxuY29uc3QgYmFja2ZpbGxFeGNlcHRpb25SdW4gPSAocnVuOiBDeXByZXNzUnVuKSA9PiB7XG4gIGlmICghcnVuLmVycm9yKSB7XG4gICAgcmV0dXJuIHJ1bjtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLi4ucnVuLFxuICAgIHRlc3RzOiBbZ2V0RmFrZVRlc3RGcm9tRXhjZXB0aW9uKHJ1bi5lcnJvciwgcnVuLnN0YXRzKV0sXG4gIH07XG59O1xuIiwgImltcG9ydCB7IEluc3RhbmNlSWQgfSBmcm9tIFwiY3lwcmVzcy1jbG91ZC90eXBlc1wiO1xuaW1wb3J0IHsgZXJyb3IsIHdhcm4gfSBmcm9tIFwiLi4vbG9nXCI7XG5pbXBvcnQgeyBnZXRGYWlsZWREdW1teVJlc3VsdCB9IGZyb20gXCIuLi9yZXN1bHRzXCI7XG5pbXBvcnQge1xuICBiYWNrZmlsbEV4Y2VwdGlvbixcbiAgc3BlY1Jlc3VsdHNUb0N5cHJlc3NSZXN1bHRzLFxufSBmcm9tIFwiLi4vcmVzdWx0cy9tYXBSZXN1bHRcIjtcbmltcG9ydCB7IFNwZWNSZXN1bHQgfSBmcm9tIFwiLi4vcnVubmVyL3NwZWMudHlwZVwiO1xuXG5pbXBvcnQgRGVidWcgZnJvbSBcImRlYnVnXCI7XG5pbXBvcnQgeyBDb25maWdTdGF0ZSB9IGZyb20gXCIuL2NvbmZpZ1wiO1xuY29uc3QgZGVidWcgPSBEZWJ1ZyhcImN1cnJlbnRzOnN0YXRlXCIpO1xuXG50eXBlIEluc3RhbmNlRXhlY3V0aW9uU3RhdGUgPSB7XG4gIGluc3RhbmNlSWQ6IEluc3RhbmNlSWQ7XG4gIHNwZWM6IHN0cmluZztcbiAgb3V0cHV0Pzogc3RyaW5nO1xuICBzcGVjQmVmb3JlPzogRGF0ZTtcbiAgY3JlYXRlZEF0OiBEYXRlO1xuICBydW5SZXN1bHRzPzogQ3lwcmVzc0NvbW1hbmRMaW5lLkN5cHJlc3NSdW5SZXN1bHQ7XG4gIHJ1blJlc3VsdHNSZXBvcnRlZEF0PzogRGF0ZTtcbiAgc3BlY0FmdGVyPzogRGF0ZTtcbiAgc3BlY0FmdGVyUmVzdWx0cz86IFNwZWNSZXN1bHQ7XG4gIHJlcG9ydFN0YXJ0ZWRBdD86IERhdGU7XG59O1xuXG5leHBvcnQgY2xhc3MgRXhlY3V0aW9uU3RhdGUge1xuICBwcml2YXRlIHN0YXRlOiBSZWNvcmQ8SW5zdGFuY2VJZCwgSW5zdGFuY2VFeGVjdXRpb25TdGF0ZT4gPSB7fTtcblxuICBwdWJsaWMgZ2V0UmVzdWx0cyhjb25maWdTdGF0ZTogQ29uZmlnU3RhdGUpIHtcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGlzLnN0YXRlKS5tYXAoKGkpID0+XG4gICAgICB0aGlzLmdldEluc3RhbmNlUmVzdWx0cyhjb25maWdTdGF0ZSwgaS5pbnN0YW5jZUlkKVxuICAgICk7XG4gIH1cblxuICBwdWJsaWMgZ2V0SW5zdGFuY2UoaW5zdGFuY2VJZDogSW5zdGFuY2VJZCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlW2luc3RhbmNlSWRdO1xuICB9XG5cbiAgcHVibGljIGdldFNwZWMoc3BlYzogc3RyaW5nKSB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy5zdGF0ZSkuZmluZCgoaSkgPT4gaS5zcGVjID09PSBzcGVjKTtcbiAgfVxuXG4gIHB1YmxpYyBpbml0SW5zdGFuY2Uoe1xuICAgIGluc3RhbmNlSWQsXG4gICAgc3BlYyxcbiAgfToge1xuICAgIGluc3RhbmNlSWQ6IEluc3RhbmNlSWQ7XG4gICAgc3BlYzogc3RyaW5nO1xuICB9KSB7XG4gICAgZGVidWcoJ0luaXQgZXhlY3V0aW9uIHN0YXRlIGZvciBcIiVzXCInLCBzcGVjKTtcbiAgICB0aGlzLnN0YXRlW2luc3RhbmNlSWRdID0ge1xuICAgICAgaW5zdGFuY2VJZCxcbiAgICAgIHNwZWMsXG4gICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgfTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRTcGVjQmVmb3JlKHNwZWM6IHN0cmluZykge1xuICAgIGNvbnN0IGkgPSB0aGlzLmdldFNwZWMoc3BlYyk7XG4gICAgaWYgKCFpKSB7XG4gICAgICB3YXJuKCdDYW5ub3QgZmluZCBleGVjdXRpb24gc3RhdGUgZm9yIHNwZWMgXCIlc1wiJywgc3BlYyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaS5zcGVjQmVmb3JlID0gbmV3IERhdGUoKTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRTcGVjQWZ0ZXIoc3BlYzogc3RyaW5nLCByZXN1bHRzOiBTcGVjUmVzdWx0KSB7XG4gICAgY29uc3QgaSA9IHRoaXMuZ2V0U3BlYyhzcGVjKTtcbiAgICBpZiAoIWkpIHtcbiAgICAgIHdhcm4oJ0Nhbm5vdCBmaW5kIGV4ZWN1dGlvbiBzdGF0ZSBmb3Igc3BlYyBcIiVzXCInLCBzcGVjKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaS5zcGVjQWZ0ZXIgPSBuZXcgRGF0ZSgpO1xuICAgIGkuc3BlY0FmdGVyUmVzdWx0cyA9IHJlc3VsdHM7XG4gIH1cblxuICBwdWJsaWMgc2V0U3BlY091dHB1dChzcGVjOiBzdHJpbmcsIG91dHB1dDogc3RyaW5nKSB7XG4gICAgY29uc3QgaSA9IHRoaXMuZ2V0U3BlYyhzcGVjKTtcbiAgICBpZiAoIWkpIHtcbiAgICAgIHdhcm4oJ0Nhbm5vdCBmaW5kIGV4ZWN1dGlvbiBzdGF0ZSBmb3Igc3BlYyBcIiVzXCInLCBzcGVjKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zZXRJbnN0YW5jZU91dHB1dChpLmluc3RhbmNlSWQsIG91dHB1dCk7XG4gIH1cblxuICBwdWJsaWMgc2V0SW5zdGFuY2VPdXRwdXQoaW5zdGFuY2VJZDogc3RyaW5nLCBvdXRwdXQ6IHN0cmluZykge1xuICAgIGNvbnN0IGkgPSB0aGlzLnN0YXRlW2luc3RhbmNlSWRdO1xuICAgIGlmICghaSkge1xuICAgICAgd2FybignQ2Fubm90IGZpbmQgZXhlY3V0aW9uIHN0YXRlIGZvciBpbnN0YW5jZSBcIiVzXCInLCBpbnN0YW5jZUlkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGkub3V0cHV0KSB7XG4gICAgICBkZWJ1ZygnSW5zdGFuY2UgXCIlc1wiIGFscmVhZHkgaGFzIG91dHB1dCcsIGluc3RhbmNlSWQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpLm91dHB1dCA9IG91dHB1dDtcbiAgfVxuXG4gIHB1YmxpYyBzZXRJbnN0YW5jZVJlc3VsdChcbiAgICBjb25maWdTdGF0ZTogQ29uZmlnU3RhdGUsXG4gICAgaW5zdGFuY2VJZDogc3RyaW5nLFxuICAgIHJlc3VsdHM6IEN5cHJlc3NDb21tYW5kTGluZS5DeXByZXNzUnVuUmVzdWx0XG4gICkge1xuICAgIGNvbnN0IGkgPSB0aGlzLnN0YXRlW2luc3RhbmNlSWRdO1xuICAgIGlmICghaSkge1xuICAgICAgd2FybignQ2Fubm90IGZpbmQgZXhlY3V0aW9uIHN0YXRlIGZvciBpbnN0YW5jZSBcIiVzXCInLCBpbnN0YW5jZUlkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaS5ydW5SZXN1bHRzID0gcmVzdWx0cztcbiAgICBpLnJ1blJlc3VsdHNSZXBvcnRlZEF0ID0gbmV3IERhdGUoKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRJbnN0YW5jZVJlc3VsdHMoXG4gICAgY29uZmlnU3RhdGU6IENvbmZpZ1N0YXRlLFxuICAgIGluc3RhbmNlSWQ6IHN0cmluZ1xuICApOiBDeXByZXNzQ29tbWFuZExpbmUuQ3lwcmVzc1J1blJlc3VsdCB7XG4gICAgY29uc3QgaSA9IHRoaXMuZ2V0SW5zdGFuY2UoaW5zdGFuY2VJZCk7XG5cbiAgICBpZiAoIWkpIHtcbiAgICAgIGVycm9yKCdDYW5ub3QgZmluZCBleGVjdXRpb24gc3RhdGUgZm9yIGluc3RhbmNlIFwiJXNcIicsIGluc3RhbmNlSWQpO1xuXG4gICAgICByZXR1cm4gZ2V0RmFpbGVkRHVtbXlSZXN1bHQoY29uZmlnU3RhdGUsIHtcbiAgICAgICAgc3BlY3M6IFtcInVua25vd25cIl0sXG4gICAgICAgIGVycm9yOiBcIkNhbm5vdCBmaW5kIGV4ZWN1dGlvbiBzdGF0ZSBmb3IgaW5zdGFuY2VcIixcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIHVzZSBzcGVjOmFmdGVyIHJlc3VsdHMgLSBpdCBjYW4gYmVjb21lIGF2YWlsYWJsZSBiZWZvcmUgcnVuIHJlc3VsdHNcbiAgICBpZiAoaS5zcGVjQWZ0ZXJSZXN1bHRzKSB7XG4gICAgICByZXR1cm4gYmFja2ZpbGxFeGNlcHRpb24oXG4gICAgICAgIHNwZWNSZXN1bHRzVG9DeXByZXNzUmVzdWx0cyhjb25maWdTdGF0ZSwgaS5zcGVjQWZ0ZXJSZXN1bHRzKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoaS5ydW5SZXN1bHRzKSB7XG4gICAgICByZXR1cm4gYmFja2ZpbGxFeGNlcHRpb24oaS5ydW5SZXN1bHRzKTtcbiAgICB9XG5cbiAgICBkZWJ1ZygnTm8gcmVzdWx0cyBkZXRlY3RlZCBmb3IgXCIlc1wiJywgaS5zcGVjKTtcbiAgICByZXR1cm4gZ2V0RmFpbGVkRHVtbXlSZXN1bHQoY29uZmlnU3RhdGUsIHtcbiAgICAgIHNwZWNzOiBbaS5zcGVjXSxcbiAgICAgIGVycm9yOiBgTm8gcmVzdWx0cyBkZXRlY3RlZCBmb3IgdGhlIHNwZWMgZmlsZS4gVGhhdCB1c3VhbGx5IGhhcHBlbnMgYmVjYXVzZSBvZiBjeXByZXNzIGNyYXNoLiBTZWUgdGhlIGNvbnNvbGUgb3V0cHV0IGZvciBkZXRhaWxzLmAsXG4gICAgfSk7XG4gIH1cbn1cbiJdLAogICJtYXBwaW5ncyI6ICI7QUFDQSxPQUFPOzs7QUNEUCxTQUFTLHFCQUFxQjtBQUV2QixJQUFNQSxXQUFVLGNBQWMsWUFBWSxHQUFHOzs7QUNGcEQsT0FBTyxRQUFRO0FBQ2YsSUFBTSxVQUFVLEdBQUc7QUFHbkIsR0FBRyxRQUFRLFNBQVUsU0FBUyxNQUFNLFNBQVM7QUFFM0MsTUFBSSxRQUFRLE1BQU0sU0FBUyxHQUFHO0FBRTVCLFVBQU1DLFdBQVUsUUFBUSxTQUFTLE1BQU07QUFBQSxNQUNyQyxHQUFHO0FBQUE7QUFBQSxNQUVILE9BQU8sQ0FBQyxRQUFRLFFBQVEsTUFBTTtBQUFBLElBQ2hDLENBQUM7QUFDRCxXQUFPQTtBQUFBLEVBQ1Q7QUFHQSxTQUFPLFFBQVEsU0FBUyxNQUFNLE9BQU87QUFDdkM7OztBQ2xCQSxPQUFPLFdBQVc7QUFDbEIsT0FBTyxVQUFVO0FBRWpCLE9BQU8sb0JBQW9CO0FBQzNCLFNBQVMsT0FBTyxTQUFTO0FBQ3pCLFlBQVksZUFBZTs7O0FDTDNCLE9BQU8sa0JBQWtCO0FBSWxCLElBQU0sU0FBUyxJQUFJLGFBQWE7OztBREl2QyxJQUFNLFFBQVEsTUFBTSxhQUFhO0FBRWpDLElBQUksU0FBNkI7QUFDakMsSUFBSSxNQUErQjtBQUNuQyxJQUFJLGlCQUF3QztBQUVyQyxJQUFNLGFBQWEsTUFDeEIsTUFBTSxRQUFRLFFBQVEsQ0FBQyxFQUNwQixLQUFLLEVBQUUsTUFBTSxFQUFFLE9BQU8sR0FBRyxDQUFDLFlBQVksUUFBUSxJQUFJLEVBQ2xELFVBQVUsTUFBTSxDQUFDO0FBRWYsSUFBTSxVQUFVLFlBQVk7QUFDakMsUUFBTSw4QkFBOEIsV0FBVyxDQUFDO0FBQ2hELE1BQUksQ0FBQyxnQkFBZ0I7QUFDbkIsVUFBTSxlQUFlO0FBQ3JCO0FBQUEsRUFDRjtBQUNBLFFBQU0sRUFBRSxTQUFTLE1BQU0sU0FBUyxPQUFBQyxPQUFNLElBQUksTUFBTSxlQUFlLFVBQVU7QUFDekUsTUFBSSxDQUFDLFNBQVM7QUFDWixRQUFJLFNBQVM7QUFBYSxNQUFBQSxPQUFNLE9BQU87QUFDdkMsUUFBSSxTQUFTO0FBQWdCLE1BQUFBLE9BQU0sU0FBU0EsTUFBSztBQUNqRCxRQUFJLFNBQVM7QUFBa0IsTUFBQUEsT0FBTSxTQUFTQSxNQUFLO0FBQUEsRUFDckQ7QUFDQSxRQUFNLDZCQUE2QixXQUFXLENBQUM7QUFDakQ7QUFDTyxJQUFNLFdBQVcsTUFBTTtBQUM1QixNQUFJLEtBQUs7QUFDUDtBQUFBLEVBQ0Y7QUFDQSxXQUFTLEtBQ04sYUFBYSxFQUNiLEdBQUcsYUFBYSxNQUFNO0FBQ3JCLFFBQUksQ0FBQyxRQUFRO0FBQ1gsWUFBTSxJQUFJLE1BQU0sd0JBQXdCO0FBQUEsSUFDMUM7QUFDQSxVQUFNLElBQWMsMEJBQWdCO0FBQUEsTUFDbEM7QUFBQSxJQUNGLENBQUM7QUFDRCxVQUFNLDJCQUEyQixXQUFXLENBQUM7QUFDN0MsUUFBSSxHQUFHLGNBQWMsU0FBUyxXQUFXLElBQUk7QUFDM0MsU0FBRyxHQUFHLFdBQVcsU0FBUyxTQUFTLE9BQU87QUFDeEMsY0FBTSxVQUFVLEtBQUssTUFBTSxNQUFNLFNBQVMsQ0FBQztBQUMzQyxlQUFPLEtBQUssUUFBUSxNQUFNLFFBQVEsT0FBTztBQUFBLE1BQzNDLENBQUM7QUFBQSxJQUNILENBQUM7QUFBQSxFQUNILENBQUMsRUFDQSxPQUFPO0FBRVYsbUJBQWlCLGVBQWU7QUFBQSxJQUM5QjtBQUFBLEVBQ0YsQ0FBQztBQUNIOzs7QUUzREEsT0FBT0MsWUFBVztBQUNsQixJQUFNQyxTQUFRRCxPQUFNLGtCQUFrQjtBQUV0QyxJQUFNLFNBQVMsUUFBUSxPQUFPO0FBQzlCLElBQU0sT0FBTyxRQUFRO0FBRWQsSUFBTSxVQUFVLFdBQVk7QUFFakMsVUFBUSxPQUFPLFFBQVE7QUFDdkIsVUFBUSxNQUFNO0FBQ2hCO0FBSUEsSUFBTSxTQUFTLFdBQVk7QUFDekIsRUFBQUUsT0FBTSxrQkFBa0I7QUFDeEIsTUFBSSxPQUFpQixDQUFDO0FBR3RCLFFBQU0sRUFBRSxNQUFNLElBQUksUUFBUTtBQUMxQixRQUFNLEVBQUUsS0FBQUMsS0FBSSxJQUFJO0FBS2hCLE1BQUlBLE1BQUs7QUFDUCxZQUFRLE1BQU0sU0FBVSxLQUFhO0FBQ25DLFdBQUssS0FBSyxHQUFHO0FBSWIsYUFBT0EsS0FBSSxNQUFNLE1BQU0sU0FBUztBQUFBLElBQ2xDO0FBQUEsRUFDRjtBQUVBLFVBQVEsT0FBTyxRQUFRLFNBQVUsS0FBYTtBQUM1QyxTQUFLLEtBQUssR0FBRztBQUliLFdBQU8sTUFBTSxNQUFNLE1BQU0sU0FBUztBQUFBLEVBQ3BDO0FBRUEsU0FBTztBQUFBLElBQ0wsV0FBVztBQUNULGFBQU8sS0FBSyxLQUFLLEVBQUU7QUFBQSxJQUNyQjtBQUFBLElBQ0EsTUFBTTtBQUFBLElBQ047QUFBQSxJQUNBLE9BQU8sTUFBTTtBQUNYLE1BQUFELE9BQU0sMkJBQTJCO0FBQ2pDLGFBQU8sQ0FBQztBQUFBLElBQ1Y7QUFBQSxFQUNGO0FBQ0Y7QUFFQSxJQUFJLGdCQUF3QjtBQUM1QixJQUFJLGlCQUFtRDtBQUVoRCxJQUFNLGNBQWMsTUFBTyxpQkFBaUIsT0FBTztBQUVuRCxJQUFNLG1CQUFtQixNQUFNO0FBQ3BDLE1BQUksQ0FBQztBQUFnQixVQUFNLElBQUksTUFBTSx3QkFBd0I7QUFDN0Qsa0JBQWdCLGVBQWUsU0FBUztBQUN4QyxpQkFBZSxNQUFNO0FBQ3ZCO0FBQ08sSUFBTSxlQUFlLE1BQU07QUFDaEMsTUFBSSxDQUFDO0FBQWdCLFVBQU0sSUFBSSxNQUFNLHdCQUF3QjtBQUM3RCxpQkFBZSxNQUFNO0FBQ3ZCO0FBRU8sSUFBTSxvQkFBb0IsTUFBTTtBQUNyQyxNQUFJLENBQUM7QUFBZ0IsVUFBTSxJQUFJLE1BQU0sd0JBQXdCO0FBQzdELFNBQU8sZUFBZSxTQUFTO0FBQ2pDO0FBQ08sSUFBTSxtQkFBbUIsTUFBTTs7O0FDM0V0QyxTQUFxQixvQkFBb0I7QUFFbEMsSUFBTSxtQkFBbUIsQ0FBQyxRQUE2QjtBQUM1RCxNQUFJLElBQUksU0FBUyxnQkFBZ0I7QUFDL0IsV0FBTztBQUFBLEVBQ1Q7QUFDQSxNQUFJLElBQUksU0FBUyxnQkFBZ0I7QUFDL0IsV0FBTztBQUFBLEVBQ1Q7QUFDQSxNQUFJLElBQUksU0FBUyxhQUFhO0FBQzVCLFdBQU87QUFBQSxFQUNUO0FBRUEsTUFBSSxDQUFDLGFBQWEsR0FBRyxHQUFHO0FBQ3RCLFdBQU87QUFBQSxFQUNUO0FBRUEsU0FBTyxDQUFDLEVBQ04sS0FBSyxVQUFVLFVBQ2YsT0FBTyxJQUFJLFNBQVMsVUFDcEIsSUFBSSxTQUFTLFNBQVM7QUFFMUI7QUFFTyxJQUFNLFdBQVcsQ0FBQyxNQUFjLENBQUMsSUFBSSxLQUFNLEtBQUssS0FBTSxLQUFLLEdBQUksRUFBRSxJQUFJLENBQUM7QUFFN0UsSUFBSSxVQUFVO0FBQ1AsSUFBTSxnQkFBZ0IsTUFBTSxXQUFXO0FBQ3ZDLElBQU0sZ0JBQWdCLENBQUMsUUFDM0IsVUFBVSxPQUFPOzs7QUM3QnBCLE9BQU8sV0FNQTtBQUNQLE9BQU8sZ0JBQWdCO0FBQ3ZCLE9BQU9FLFlBQVc7QUFDbEIsT0FBT0MsUUFBTztBQUNkLE9BQU8sd0JBQXdCOzs7QUNWL0IsT0FBT0MsWUFBVztBQUVsQixTQUFTLEtBQUFDLElBQUcsU0FBQUMsY0FBYTs7O0FDRnpCLFNBQVMsa0JBQWtCO0FBRTNCLE9BQU9DLFlBQVc7QUFDbEIsT0FBTyxXQUEyQjtBQUNsQyxPQUFPLFFBQVE7OztBQ0pSLElBQU0sa0JBQU4sY0FBOEIsTUFBTTtBQUFBLEVBQ3pDLFlBQVksU0FBaUI7QUFDM0IsVUFBTSxPQUFPO0FBQ2IsU0FBSyxPQUFPO0FBQUEsRUFDZDtBQUNGOzs7QUNMQSxTQUFTLFlBQVk7QUFFZCxJQUFNLGlCQUFpQixZQUFZO0FBQ3hDLFFBQU0sRUFBRSxNQUFBQyxNQUFLLElBQUksTUFBTSxLQUFLO0FBQzVCLFNBQU9BO0FBQ1Q7OztBQ0xBLE9BQU8sV0FBVztBQUNsQixPQUFPLFVBQVU7QUFFakIsSUFBTSxNQUFNLElBQUksU0FBb0IsUUFBUSxJQUFJLEtBQUssT0FBTyxHQUFHLElBQUksQ0FBQztBQUU3RCxJQUFNLE9BQU87QUFFYixJQUFNLFlBQVksQ0FBQyxRQUN4QixNQUFNLE1BQU0sTUFBTSxTQUFTLElBQUksTUFBTTtBQUNoQyxJQUFNLGNBQWMsQ0FBQyxRQUMxQixNQUFNLFNBQVMsTUFBTSxXQUFXLElBQUksTUFBTTtBQUVyQyxJQUFNLE9BQU8sSUFBSSxTQUN0QixJQUFJLFlBQVksS0FBSyxPQUFPLEdBQUcsSUFBSSxDQUFDLENBQUM7QUFLaEMsSUFBTSxRQUFRLElBQUksU0FDdkIsSUFBSSxVQUFVLEtBQUssT0FBTyxHQUFHLElBQUksQ0FBQyxJQUFJLElBQUk7QUFHckMsSUFBTSxRQUFRLENBQUMsVUFBaUIsU0FDckMsS0FBSyxTQUFjLE1BQU0sS0FBSyxFQUFFLEtBQUssS0FBSyxPQUFPLEdBQUcsSUFBSSxDQUFDLElBQUksTUFBVztBQUVuRSxJQUFNLFVBQVUsTUFDckIsUUFBUSxJQUFJLE9BQU8sTUFBTSxLQUFLLE1BQU0sR0FBRyxFQUFFLEtBQUssR0FBRyxFQUFFLEtBQUssRUFBRSxDQUFDLElBQUksSUFBSTtBQUU5RCxJQUFNLFNBQVMsQ0FBQyxJQUFZLE1BQ2pDLFFBQVEsSUFBSSxNQUFNLENBQUMsRUFBRSxLQUFLLEVBQUUsRUFBRSxLQUFLLElBQUksQ0FBQztBQUVuQyxJQUFNLE9BQU8sTUFBTTtBQUNuQixJQUFNLE9BQU8sTUFBTTtBQUNuQixJQUFNLE1BQU0sTUFBTTtBQUNsQixJQUFNLFFBQVEsTUFBTTtBQUNwQixJQUFNLE9BQU8sTUFBTTtBQUNuQixJQUFNLFFBQVEsTUFBTTtBQUNwQixJQUFNLFVBQVUsTUFBTTtBQUN0QixJQUFNLE9BQU8sTUFBTTs7O0FDbEMxQixPQUFPQyxZQUFXO0FBQ2xCLE9BQU8sT0FBTztBQUNkLFNBQVMsc0JBQXNCO0FBRS9CLElBQU1DLFNBQVFDLE9BQU0sZUFBZTtBQUVuQyxJQUFNLGVBQWUsZUFBZSw4QkFBOEIsRUFBRTtBQUU3RCxTQUFTLGlCQUFpQjtBQUFBLEVBQy9CO0FBQUEsRUFDQTtBQUNGLEdBR0c7QUFDRCxTQUFPLEVBQUUsTUFBTSxvQkFBb0IsTUFBTSxDQUFDLEVBQ3ZDLEtBQUssQ0FBQyxVQUFVO0FBQUEsSUFDZixHQUFHO0FBQUE7QUFBQSxJQUVILEtBQUs7QUFBQSxNQUNILEdBQUksS0FBSyxPQUFPLENBQUM7QUFBQSxNQUNqQixvQkFBb0I7QUFBQSxNQUNwQix3QkFBd0IsUUFBUSxJQUFJLE9BQU8sU0FBUyxXQUFXLElBQzNELE9BQ0E7QUFBQSxJQUNOO0FBQUEsRUFDRixFQUFFLEVBQ0QsSUFBSSxDQUFDLFNBQVM7QUFDYixJQUFBRCxPQUFNLGdDQUFnQyxJQUFJO0FBQUEsRUFDNUMsQ0FBQyxFQUNBLEtBQUssZ0JBQWdCLEVBQ3JCLElBQUksQ0FBQyxTQUFTO0FBQ2IsSUFBQUEsT0FBTSwyQ0FBMkMsSUFBSTtBQUFBLEVBQ3ZELENBQUMsRUFDQSxLQUFLLENBQUMsU0FBUztBQUNkLFdBQU87QUFBQSxNQUNMLEdBQUc7QUFBQSxNQUNIO0FBQUEsTUFDQSxhQUFhO0FBQUEsTUFDYixPQUFPLGdCQUFnQixjQUFjLGdCQUFnQjtBQUFBLElBQ3ZEO0FBQUEsRUFDRixDQUFDLEVBQ0EsTUFBTTtBQUNYO0FBV0EsU0FBUyxvQkFDUCxRQUNzQjtBQUN0QixRQUFNLFNBQVMsdUJBQXVCLE1BQU07QUFDNUMsUUFBTSxjQUNKLE9BQU8sZ0JBQWdCLGNBQ25CO0FBQUEsSUFDRSxXQUFXO0FBQUEsRUFDYixJQUNBLENBQUM7QUFDUCxTQUFPO0FBQUEsSUFDTCxHQUFHLEVBQUUsS0FBSyxRQUFRLGFBQWE7QUFBQSxJQUMvQixHQUFHO0FBQUEsRUFDTDtBQUNGO0FBRUEsU0FBUyxpQkFBaUIsU0FBNEM7QUFDcEUsU0FBTyxPQUFPLFFBQVEsT0FBTyxFQUFFLFFBQVEsQ0FBQyxDQUFDLEtBQUssS0FBSyxNQUFNO0FBQ3ZELFVBQU0sT0FBTyxPQUFPLEdBQUc7QUFDdkIsUUFBSSxPQUFPLFVBQVUsV0FBVztBQUM5QixhQUFPLFVBQVUsT0FBTyxDQUFDLEtBQUssTUFBTSxJQUFJLENBQUMsS0FBSyxRQUFRLEtBQUs7QUFBQSxJQUM3RDtBQUVBLFFBQUksRUFBRSxTQUFTLEtBQUssR0FBRztBQUNyQixhQUFPLENBQUMsS0FBSyxRQUFRLHNCQUFzQixLQUFLLENBQUM7QUFBQSxJQUNuRDtBQUdBLFdBQU8sQ0FBQyxLQUFLLFFBQVEsTUFBTSxTQUFTLENBQUM7QUFBQSxFQUN2QyxDQUFDO0FBQ0g7QUFFQSxTQUFTLHNCQUFzQixPQUFXO0FBQ3hDLFNBQU8sS0FBSyxVQUFVLEtBQUs7QUFDN0I7QUFFQSxJQUFNLFNBQVMsQ0FBQyxNQUFjLEVBQUUsUUFBUSxVQUFVLENBQUMsTUFBTSxNQUFNLEVBQUUsWUFBWSxDQUFDOzs7QUpuRjlFLElBQU1FLFNBQVFDLE9BQU0sZUFBZTtBQUU1QixJQUFNLGNBQWMsT0FBTyxXQUF3QztBQUN4RSxFQUFBRCxPQUFNLG9CQUFvQjtBQUMxQixRQUFNLGVBQWUsTUFBTSxlQUFlO0FBRTFDLFFBQU0sYUFBYSxNQUFNLFdBQVdFLFNBQVEsUUFBUSxTQUFTLENBQUM7QUFDOUQsRUFBQUYsT0FBTSxtQ0FBbUMsVUFBVTtBQUduRCxRQUFNLE9BQU8saUJBQWlCLEVBQUUsY0FBYyxPQUFPLENBQUM7QUFDdEQsRUFBQUEsT0FBTSxpQ0FBaUMsSUFBSTtBQUMzQyxRQUFNLEVBQUUsUUFBQUcsU0FBUSxPQUFPLElBQUksTUFBTSxZQUFZLFlBQVksSUFBSTtBQUU3RCxNQUFJLENBQUMsR0FBRyxXQUFXLFlBQVksR0FBRztBQUNoQyxVQUFNLElBQUk7QUFBQSxNQUNSLDZDQUE2QztBQUFBLElBQy9DO0FBQUEsRUFDRjtBQUNBLE1BQUk7QUFDRixVQUFNLElBQUksR0FBRyxhQUFhLGNBQWMsT0FBTztBQUMvQyxRQUFJLENBQUMsR0FBRztBQUNOLFlBQU0sSUFBSSxNQUFNLG9DQUFvQztBQUFBLElBQ3REO0FBQ0EsSUFBQUgsT0FBTSw2QkFBNkIsY0FBYyxDQUFDO0FBQ2xELFdBQU8sS0FBSyxNQUFNLENBQUM7QUFBQSxFQUNyQixTQUFTLEtBQVA7QUFDQSxJQUFBQSxPQUFNLG9DQUFvQyxHQUFHO0FBQzdDLFNBQUssS0FBSyxtQkFBbUIsR0FBR0csT0FBTTtBQUN0QyxTQUFLLEtBQUssbUJBQW1CLEdBQUcsTUFBTTtBQUV0QyxVQUFNLElBQUksZ0JBQWdCO0FBQUE7QUFBQTtBQUFBLENBRzdCO0FBQUEsRUFDQztBQUNGO0FBRUEsZUFBZSxZQUFZLFlBQW9CLE1BQXlCO0FBQ3RFLE1BQUlBLFVBQVM7QUFDYixNQUFJLFNBQVM7QUFDYixNQUFJO0FBQ0YsVUFBTSxNQUFNLFlBQVksQ0FBQyxPQUFPLEdBQUcsSUFBSSxHQUFHO0FBQUEsTUFDeEMsT0FBTztBQUFBLE1BQ1AsS0FBSztBQUFBLFFBQ0gsR0FBRyxRQUFRO0FBQUE7QUFBQSxRQUVYLG9CQUFvQjtBQUFBLFFBQ3BCLG9CQUFvQjtBQUFBLE1BQ3RCO0FBQUEsSUFDRixDQUFDO0FBQUEsRUFDSCxTQUFTLEtBQVA7QUFDQSxJQUFBSCxPQUFNLDJEQUEyRCxHQUFHO0FBQ3BFLElBQUFHLFVBQVUsSUFBbUI7QUFDN0IsYUFBVSxJQUFtQjtBQUFBLEVBQy9CO0FBQ0EsU0FBTyxFQUFFLFFBQUFBLFNBQVEsT0FBTztBQUMxQjs7O0FLcEVBLE9BQU8sZ0JBQWdCO0FBQ3ZCLE9BQU9DLFFBQU87QUFDZCxPQUFPLFVBQVU7QUFFVixJQUFNLG1CQUFtQjtBQUFBLEVBQzlCO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFDRjtBQUNPLFNBQVMsa0JBQ2QsY0FBNkIsTUFDN0Isd0JBQ1U7QUFDVixRQUFNLFNBQVMsZUFBZSxRQUFRLElBQUk7QUFDMUMsTUFDRUEsR0FBRSxTQUFTLHNCQUFzQixLQUNqQyxXQUFXLHNCQUFzQixHQUNqQztBQUNBLFdBQU8sQ0FBQyxzQkFBc0I7QUFBQSxFQUNoQztBQUNBLE1BQUlBLEdBQUUsU0FBUyxzQkFBc0IsR0FBRztBQUN0QyxXQUFPLENBQUMsY0FBYyxRQUFRLHNCQUFzQixDQUFDO0FBQUEsRUFDdkQ7QUFFQSxTQUFPLGlCQUFpQixJQUFJLENBQUMsTUFBTSxjQUFjLFFBQVEsQ0FBQyxDQUFDO0FBQzdEO0FBRU8sU0FBUyxjQUFjLFFBQWdCLFVBQTBCO0FBQ3RFLFNBQU8sVUFBVSxLQUFLLFFBQVEsUUFBUSxRQUFRO0FBQ2hEOzs7QU5yQkEsSUFBTUMsU0FBUUMsT0FBTSxpQkFBaUI7QUFpQnJDLElBQUksVUFBaUM7QUFFckMsSUFBTSxnQkFBZ0M7QUFBQSxFQUNwQyxLQUFLO0FBQUEsSUFDSCxXQUFXO0FBQUEsRUFDYjtBQUFBLEVBQ0EsV0FBVztBQUFBLElBQ1QsV0FBVztBQUFBLEVBQ2I7QUFBQSxFQUNBLGlCQUFpQjtBQUFBLEVBQ2pCLGdCQUFnQjtBQUNsQjtBQUVBLGVBQXNCLGtCQUNwQixhQUNBLHdCQUN5QjtBQUN6QixNQUFJLFNBQVM7QUFDWCxXQUFPO0FBQUEsRUFDVDtBQUVBLFFBQU0saUJBQWlCLGtCQUFrQixhQUFhLHNCQUFzQjtBQUU1RSxhQUFXLFlBQVksZ0JBQWdCO0FBQ3JDLFVBQU0sU0FBU0MsT0FBTSxNQUFNLGVBQWUsUUFBUSxDQUFDLEVBQ2hELEtBQUssRUFBRSxTQUFTQyxHQUFFLElBQUlBLEdBQUUsT0FBTyxFQUFFLEdBQUcsQ0FBQyxNQUFNLEVBQUUsT0FBTyxFQUNwRCxLQUFLQSxHQUFFLElBQUlBLEdBQUUsT0FBTyxHQUFHLENBQUMsTUFBTSxDQUFDLEVBQy9CLFVBQVUsTUFBTSxJQUFJO0FBRXZCLFFBQUksUUFBUTtBQUNWLE1BQUFILE9BQU0sd0NBQXdDLFVBQVUsTUFBTTtBQUM5RCxXQUFLLDJCQUEyQixRQUFRO0FBQ3hDLGdCQUFVO0FBQUEsUUFDUixHQUFHO0FBQUEsUUFDSCxHQUFHO0FBQUEsTUFDTDtBQUNBLGFBQU87QUFBQSxJQUNUO0FBQUEsRUFDRjtBQUVBO0FBQUEsSUFDRTtBQUFBLElBQ0E7QUFBQSxFQUNGO0FBQ0EsWUFBVTtBQUNWLFNBQU87QUFDVDtBQUVBLGVBQWUsZUFBZSxVQUFrQjtBQUM5QyxNQUFJO0FBQ0YsSUFBQUEsT0FBTSwwQ0FBMEMsUUFBUTtBQUN4RCxXQUFPLE1BQU0sT0FBTztBQUFBLEVBQ3RCLFNBQVMsR0FBUDtBQUNBLElBQUFBLE9BQU0sdUNBQXVDLENBQUM7QUFDOUMsV0FBTztBQUFBLEVBQ1Q7QUFDRjtBQUdBLGVBQXNCLGdCQUFnQixRQUFxQztBQUN6RSxFQUFBQSxPQUFNLDBCQUEwQjtBQUNoQyxRQUFNLHdCQU1VLE1BQU0sWUFBWSxNQUFNO0FBRXhDLEVBQUFBLE9BQU0sOEJBQThCLHFCQUFxQjtBQUd6RCxRQUFNLGdCQUFnQixzQkFBc0IsU0FBUyxLQUFLO0FBQzFELE1BQUksMEJBQW9DLENBQUM7QUFDekMsTUFBSSxPQUFPLGdCQUFnQixlQUFlLGVBQWU7QUFFdkQsOEJBQTBCO0FBQUEsRUFDNUI7QUFJQSxRQUFNLFNBQVM7QUFBQSxJQUNiLGFBQWEsdUJBQXVCLGVBQWUsUUFBUSxJQUFJO0FBQUEsSUFDL0QsV0FBVyxPQUFPO0FBQUEsSUFDbEIsYUFBYSx1QkFBdUIsZUFBZTtBQUFBLElBQ25EO0FBQUE7QUFBQSxNQUVFLHVCQUF1QixTQUFTLG1CQUFtQixTQUFTLENBQUM7QUFBQTtBQUFBLElBQy9EO0FBQUEsSUFDQSxVQUFVO0FBQUEsRUFDWjtBQUNBLEVBQUFBLE9BQU0scUJBQXFCLE1BQU07QUFDakMsU0FBTztBQUNUOzs7QU9qSEEsT0FBT0ksWUFBVztBQUNsQixPQUFPQyxRQUFPO0FBSWQsSUFBTUMsU0FBUUMsT0FBTSx5QkFBeUI7QUFFN0MsZUFBc0Isc0JBQ3BCLFFBQ2dDO0FBQ2hDLFFBQU0saUJBQWlCLE1BQU07QUFBQSxJQUMzQixPQUFPO0FBQUEsSUFDUCxPQUFPO0FBQUEsRUFDVDtBQUVBLEVBQUFELE9BQU0saUNBQWlDLE1BQU07QUFDN0MsRUFBQUEsT0FBTSxzQ0FBc0MsY0FBYztBQUMxRCxRQUFNLGtCQUNKLE9BQU8sbUJBQ1AsUUFBUSxJQUFJLG9CQUNaLGVBQWU7QUFFakIsUUFBTSxZQUNKLE9BQU8sYUFDUCxRQUFRLElBQUksdUJBQ1osZUFBZTtBQUVqQixRQUFNLFlBQ0osT0FBTyxhQUNQLFFBQVEsSUFBSSx1QkFDWixlQUFlO0FBRWpCLFFBQU0sY0FBYyxPQUFPLGVBQWU7QUFFMUMsUUFBTSxZQUNKLGdCQUFnQixRQUNaLGVBQWUsSUFBSSxZQUNuQixlQUFlLFVBQVU7QUFHL0IsU0FBTztBQUFBLElBQ0wsR0FBRztBQUFBLElBQ0g7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsRUFDRjtBQUNGO0FBRU8sSUFBTSxpQkFBaUI7QUFBQTtBQUFBO0FBQUE7QUFLdkIsSUFBTSx1QkFBdUI7QUFBQTtBQUFBO0FBQUE7QUFLN0IsSUFBTSw4QkFBOEI7QUFFcEMsSUFBTSxpQkFBaUI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFROUIsZUFBc0IsZUFDcEIsU0FDc0M7QUFDdEMsUUFBTSxTQUFTLE1BQU0sc0JBQXNCLE9BQU87QUFFbEQsRUFBQUEsT0FBTSxrQ0FBa0MsTUFBTTtBQUM5QyxNQUFJLENBQUMsT0FBTyxpQkFBaUI7QUFDM0IsVUFBTSxJQUFJLGdCQUFnQixvQkFBb0I7QUFBQSxFQUNoRDtBQUNBLE1BQUksQ0FBQyxPQUFPLFdBQVc7QUFDckIsVUFBTSxJQUFJLGdCQUFnQixjQUFjO0FBQUEsRUFDMUM7QUFDQSxNQUFJLENBQUMsT0FBTyxXQUFXO0FBQ3JCLFVBQU0sSUFBSSxnQkFBZ0IsY0FBYztBQUFBLEVBQzFDO0FBRUEsY0FBWSxPQUFPLGVBQWU7QUFFbEMsUUFBTSxxQkFBeUQ7QUFBQSxJQUM3RDtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsRUFDRjtBQUNBLHFCQUFtQixRQUFRLENBQUMsUUFBUTtBQUNsQyxRQUFJLE9BQU8sT0FBTyxHQUFHLE1BQU0sYUFBYTtBQUN0QyxZQUFNLG1DQUFtQyxHQUFHO0FBQzVDLFlBQU0sSUFBSSxNQUFNLDRCQUE0QjtBQUFBLElBQzlDO0FBQUEsRUFDRixDQUFDO0FBRUQsU0FBTyxNQUFNLFVBQVUsT0FBTyxHQUFHO0FBQ2pDLFNBQU8sMEJBQTBCO0FBQUEsSUFDL0IsT0FBTztBQUFBLEVBQ1Q7QUFFQSxFQUFBQSxPQUFNLGlDQUFpQyxNQUFNO0FBRzdDLFNBQU87QUFDVDtBQUVBLFNBQVMsbUJBQW1CLE9BQTRDO0FBQ3RFLE1BQUksT0FBTyxVQUFVLGFBQWE7QUFDaEMsV0FBTztBQUFBLEVBQ1Q7QUFDQSxNQUFJLE9BQU8sVUFBVSxXQUFXO0FBQzlCLFdBQU8sUUFBUSxJQUFJO0FBQUEsRUFDckI7QUFFQSxNQUFJLE9BQU8sVUFBVSxZQUFZLFFBQVEsR0FBRztBQUMxQyxXQUFPO0FBQUEsRUFDVDtBQUVBLFFBQU0sSUFBSTtBQUFBLElBQ1IsMkVBQTJFO0FBQUEsRUFDN0U7QUFDRjtBQUVPLFNBQVMsVUFBVSxRQUErQjtBQUN2RCxTQUFPLE9BQU8sV0FBVztBQUMzQjtBQUVBLFNBQVMsVUFBVSxXQUFtRDtBQUNwRSxNQUFJLENBQUMsV0FBVztBQUNkLFdBQU8sQ0FBQztBQUFBLEVBQ1Y7QUFDQSxNQUFJLE1BQU0sUUFBUSxTQUFTLEdBQUc7QUFDNUIsV0FBTyxVQUFVLE9BQU8sT0FBTztBQUFBLEVBQ2pDO0FBQ0EsU0FBTyxVQUNKLE1BQU0sR0FBRyxFQUNULElBQUksQ0FBQyxRQUFRLElBQUksS0FBSyxDQUFDLEVBQ3ZCLE9BQU8sT0FBTztBQUNuQjtBQUVBLFNBQVMsWUFBWSxLQUFtQjtBQUN0QyxNQUFJO0FBQ0YsUUFBSSxJQUFJLEdBQUc7QUFBQSxFQUNiLFNBQVMsS0FBUDtBQUNBLFVBQU0sSUFBSSxnQkFBZ0IsR0FBRyxpQ0FBaUMsTUFBTTtBQUFBLEVBQ3RFO0FBQ0Y7QUFNTyxTQUFTLHVCQUNkLFFBQ3NCO0FBQ3RCLFNBQU87QUFBQSxJQUNMLEdBQUdFLEdBQUU7QUFBQSxNQUNIQSxHQUFFLEtBQUssUUFBUTtBQUFBLFFBQ2I7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxNQUNGLENBQUM7QUFBQSxNQUNEO0FBQUEsSUFDRjtBQUFBLElBQ0EsUUFBUTtBQUFBLEVBQ1Y7QUFDRjtBQUVPLFNBQVMsaUJBQ2QsUUFDdUI7QUFDdkIsU0FBTztBQUFBLElBQ0wsR0FBRztBQUFBLElBQ0gsTUFBTSxpQkFBaUIsT0FBTyxJQUFJO0FBQUEsRUFDcEM7QUFDRjtBQUVBLFNBQVMsaUJBQ1AsTUFDc0I7QUFDdEIsTUFBSSxDQUFDLE1BQU07QUFDVCxXQUFPO0FBQUEsRUFDVDtBQUVBLE1BQUksTUFBTSxRQUFRLElBQUksR0FBRztBQUN2QixXQUFPQSxHQUFFLFFBQVEsS0FBSyxJQUFJLENBQUMsTUFBTSxFQUFFLE1BQU0sR0FBRyxDQUFDLENBQUM7QUFBQSxFQUNoRDtBQUVBLFNBQU8sS0FBSyxNQUFNLEdBQUc7QUFDdkI7OztBQ25OQSxPQUFPQyxRQUFPO0FBR1AsU0FBUyxpQkFDZCxLQUNBO0FBQ0EsTUFBSSxDQUFDLElBQUksVUFBVSxRQUFRLENBQUMsSUFBSSxVQUFVLFFBQVE7QUFDaEQ7QUFBQSxFQUNGO0FBRUEsUUFBTSxFQUFFLFNBQVMsT0FBTyxJQUFJLElBQUksU0FBUztBQUV6QyxVQUFRLElBQUksU0FBUyxRQUFRO0FBQUEsSUFDM0IsS0FBSztBQUNILFdBQUssMkJBQTJCO0FBQ2hDO0FBQUEsSUFDRixLQUFLO0FBQ0gsYUFBTyxDQUFDO0FBQ1IsV0FBSyxHQUFHLG1CQUFtQixTQUFTLE1BQU0sQ0FBQztBQUMzQyxhQUFPLENBQUM7QUFDUjtBQUFBLElBQ0Y7QUFDRTtBQUFBLEVBQ0o7QUFDRjtBQUVPLFNBQVMsbUJBQ2QsU0FDQSxRQUNVO0FBQ1YsTUFBSSxDQUFDQyxHQUFFLFNBQVMsT0FBTyxHQUFHO0FBQ3hCLFdBQU8sQ0FBQyx5Q0FBeUM7QUFBQSxFQUNuRDtBQUVBLE1BQUksUUFBUSxXQUFXLEdBQUc7QUFDeEIsV0FBTyxDQUFDLE9BQWlCO0FBQUEsRUFDM0I7QUFDQSxTQUFPO0FBQUEsSUFDTDtBQUFBLElBQ0E7QUFBQSxHQUNELFVBQVUsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLE9BQU8sR0FBRyxFQUFFLEtBQUssSUFBSTtBQUFBO0FBQUEsRUFFL0M7QUFDRjs7O0FUM0JBLElBQU1DLFNBQVFDLE9BQU0sY0FBYztBQUVsQyxJQUFNLGNBQWM7QUFDcEIsSUFBTSxhQUFhLEtBQUs7QUFDeEIsSUFBSSxVQUFnQztBQUVwQyxlQUFzQixZQUFZO0FBQ2hDLE1BQUksU0FBUztBQUNYLFdBQU87QUFBQSxFQUNUO0FBQ0EsUUFBTSxpQkFBaUIsTUFBTSxrQkFBa0I7QUFDL0MsWUFBVSxNQUFNLE9BQU87QUFBQSxJQUNyQixTQUFTLGNBQWM7QUFBQSxJQUN2QixTQUFTO0FBQUEsRUFDWCxDQUFDO0FBRUQsVUFBUSxhQUFhLFFBQVEsSUFBSSxDQUFDLFdBQVc7QUFDM0MsVUFBTSxZQUFZLG9CQUFvQjtBQUN0QyxVQUFNLFVBQWtDO0FBQUEsTUFDdEMsR0FBRyxPQUFPO0FBQUE7QUFBQSxNQUVWLDZCQUE2QixPQUFPLGFBQWEsR0FBRyxjQUFjO0FBQUEsTUFDbEUscUJBQXFCLG1CQUFtQjtBQUFBLE1BQ3hDLGlCQUFpQjtBQUFBLE1BQ2pCLGNBQWMsaUJBQWlCO0FBQUEsSUFDakM7QUFDQSxRQUFJLFFBQVE7QUFDVixjQUFRLGtCQUFrQixJQUFJO0FBQUEsSUFDaEM7QUFDQSxRQUFJLENBQUMsUUFBUSxjQUFjLEdBQUc7QUFDNUIsY0FBUSxjQUFjLElBQUk7QUFBQSxJQUM1QjtBQUVBLFFBQUksZUFBZSxnQkFBZ0I7QUFDakMsWUFBTSxrQkFBa0JDLEdBQUUsS0FBSyxlQUFlLGdCQUFnQjtBQUFBLFFBQzVEO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLE1BQ0YsQ0FBQztBQUNELE1BQUFGLE9BQU0sb0NBQW9DLGVBQWU7QUFDekQsYUFBTyxPQUFPLFNBQVMsZUFBZTtBQUFBLElBQ3hDO0FBRUEsVUFBTSxNQUFNO0FBQUEsTUFDVixHQUFHO0FBQUEsTUFDSDtBQUFBLElBQ0Y7QUFFQSxJQUFBQSxPQUFNLHVCQUF1QjtBQUFBLE1BQzNCLEdBQUdFLEdBQUUsS0FBSyxLQUFLLFVBQVUsT0FBTyxTQUFTO0FBQUEsTUFDekMsTUFBTSxPQUFPLFNBQVMsSUFBSSxJQUFJLElBQUksV0FBVyxJQUFJO0FBQUEsSUFDbkQsQ0FBQztBQUVELFdBQU87QUFBQSxFQUNULENBQUM7QUFFRCxhQUFXLFNBQVM7QUFBQSxJQUNsQixTQUFTO0FBQUEsSUFDVCxnQkFBZ0I7QUFBQSxJQUNoQixZQUFZO0FBQUE7QUFBQSxJQUVaO0FBQUEsSUFDQSxvQkFBb0I7QUFBQSxFQUN0QixDQUFDO0FBQ0QsU0FBTztBQUNUO0FBRUEsSUFBSSxTQUE2QjtBQUMxQixJQUFNLFdBQVcsQ0FBQyxVQUFrQjtBQUN6QyxXQUFTO0FBQ1g7QUFFQSxJQUFJLGtCQUFzQztBQUNuQyxJQUFNLG9CQUFvQixDQUFDLG1CQUEyQjtBQUMzRCxvQkFBa0I7QUFDcEI7QUFFQSxJQUFJLG1CQUF1QztBQUNwQyxJQUFNLHFCQUFxQixDQUFDLE1BQWM7QUFDL0MscUJBQW1CO0FBQ3JCO0FBRUEsU0FBUyxRQUNQLFlBQ0EsS0FDQSxRQUNBO0FBQ0E7QUFBQSxJQUNFO0FBQUEsSUFDQSxHQUFHLE9BQU8sVUFBVSxPQUFPO0FBQUEsSUFDM0IsSUFBSTtBQUFBLElBQ0osbUJBQW1CLFNBQVMsVUFBVSxDQUFDO0FBQUEsSUFDdkM7QUFBQSxJQUNBO0FBQUEsRUFDRjtBQUNGO0FBRU8sSUFBTSxjQUFjLE9BQ3pCLFdBQ0c7QUFDSCxVQUFRLE1BQU0sVUFBVSxHQUF3QixNQUFNLEVBQ25ELEtBQUssQ0FBQyxRQUFRO0FBQ2IsSUFBQUYsT0FBTSx3QkFBd0JFLEdBQUUsS0FBSyxLQUFLLFdBQVcsUUFBUSxDQUFDO0FBQzlELFdBQU87QUFBQSxFQUNULENBQUMsRUFDQSxNQUFNLENBQUNDLFdBQVU7QUFDaEIscUJBQWlCQSxNQUFLO0FBQ3RCLFVBQU0sSUFBSSxnQkFBZ0JBLE9BQU0sT0FBTztBQUFBLEVBQ3pDLENBQUM7QUFDTDs7O0FVNUhBLElBQU0sYUFBYUMsU0FBUSxzQkFBc0I7QUFDakQsSUFBTSxNQUFNQSxTQUFRLDRCQUE0QjtBQUtoRCxZQUFZO0FBQ1osa0JBQWtCLFdBQVcsT0FBTztBQUNwQyxtQkFBbUIsSUFBSSxPQUFPOzs7QUNWOUIsT0FBT0MsYUFBVzs7O0FDRlgsU0FBUyxpQkFBaUI7QUFDL0IsU0FBTztBQUFBLGlCQUNPLG9CQUFJLEtBQUssR0FBRSxZQUFZO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU12Qzs7O0FDUkEsT0FBT0MsUUFBTztBQU1QLFNBQVMsY0FBYyxVQUEwQjtBQUN0RCxPQUFLLDRCQUE0QjtBQUNqQyxXQUFTLElBQUksQ0FBQyxNQUFNO0FBQ2xCLFdBQU8sQ0FBQztBQUNSLFNBQUssUUFBUSxLQUFLLEVBQUUsT0FBTyxDQUFDO0FBQzVCLFdBQU8sUUFBUUMsR0FBRSxLQUFLLEdBQUcsU0FBUyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsS0FBSyxLQUFLLE1BQU07QUFDekQsV0FBSyxZQUFZLEtBQUssS0FBSztBQUFBLElBQzdCLENBQUM7QUFDRCxXQUFPLENBQUM7QUFBQSxFQUNWLENBQUM7QUFDSDs7O0FDRE8sSUFBTSxZQUFZLE9BQU8sWUFBOEI7QUFDNUQsUUFBTSxXQUFXLE1BQU0sWUFBaUQ7QUFBQSxJQUN0RSxRQUFRO0FBQUEsSUFDUixLQUFLO0FBQUEsSUFDTCxNQUFNO0FBQUEsRUFDUixDQUFDO0FBRUQsT0FBSyxTQUFTLEtBQUssVUFBVSxVQUFVLEtBQUssR0FBRztBQUM3QyxrQkFBYyxTQUFTLEtBQUssUUFBUTtBQUFBLEVBQ3RDO0FBRUEsU0FBTyxTQUFTO0FBQ2xCO0FBRU8sSUFBTSxpQkFBaUIsT0FBTztBQUFBLEVBQ25DO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBLFVBQUFDO0FBQ0YsTUFBNkI7QUFDM0IsUUFBTSxXQUFXLE1BQU0sWUFHckI7QUFBQSxJQUNBLFFBQVE7QUFBQSxJQUNSLEtBQUssUUFBUTtBQUFBLElBQ2IsTUFBTTtBQUFBLE1BQ0o7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0EsVUFBQUE7QUFBQSxJQUNGO0FBQUEsRUFDRixDQUFDO0FBRUQsU0FBTyxTQUFTO0FBQ2xCO0FBRU8sSUFBTSx5QkFBeUIsT0FBTyxTQUFrQztBQUM3RSxRQUFNLFVBQVUsTUFBTSxZQUdwQjtBQUFBLElBQ0EsUUFBUTtBQUFBLElBQ1IsS0FBSyxRQUFRLEtBQUs7QUFBQSxJQUNsQjtBQUFBLEVBQ0YsQ0FBQztBQUVELFNBQU8sUUFBUTtBQUNqQjtBQUVPLElBQU0sbUJBQW1CLENBQzlCLFlBQ0EsWUFFQSxZQUF5QztBQUFBLEVBQ3ZDLFFBQVE7QUFBQSxFQUNSLEtBQUssYUFBYTtBQUFBLEVBQ2xCLE1BQU07QUFDUixDQUFDLEVBQUUsS0FBSyxDQUFDLFdBQVcsT0FBTyxJQUFJO0FBRTFCLElBQU0sd0JBQXdCLENBQ25DLFlBQ0EsWUFFQSxZQUF5RTtBQUFBLEVBQ3ZFLFFBQVE7QUFBQSxFQUNSLEtBQUssYUFBYTtBQUFBLEVBQ2xCLE1BQU07QUFDUixDQUFDLEVBQUUsS0FBSyxDQUFDLFdBQVcsT0FBTyxJQUFJO0FBRTFCLElBQU0sOEJBQThCLENBQ3pDLFlBQ0EsWUFFQSxZQUdFO0FBQUEsRUFDQSxRQUFRO0FBQUEsRUFDUixLQUFLLGFBQWE7QUFBQSxFQUNsQixNQUFNO0FBQ1IsQ0FBQyxFQUFFLEtBQUssQ0FBQyxXQUFXLE9BQU8sSUFBSTtBQUUxQixJQUFNLHVCQUF1QixDQUFDLFlBQW9CQyxZQUN2RCxZQUFxQztBQUFBLEVBQ25DLFFBQVE7QUFBQSxFQUNSLEtBQUssYUFBYTtBQUFBLEVBQ2xCLE1BQU07QUFBQSxJQUNKLFFBQUFBO0FBQUEsRUFDRjtBQUNGLENBQUM7OztBQzVFSCxPQUFPLGFBQWE7QUFFcEIsT0FBT0MsUUFBTztBQUdkLElBQU1DLFNBQVEsUUFBUSxhQUFhO0FBRW5DLElBQU0sT0FBTyxDQUFDLFNBQWlCLFdBQW1DO0FBQ2hFLFNBQU9DLEdBQUUsTUFBTSxNQUFNLEVBQUUsUUFBUSxFQUFFLEtBQUssSUFBSSxFQUFFLE1BQU07QUFDcEQ7QUFFQSxJQUFNLGdCQUFnQixDQUFDLEtBQVUsUUFBZ0I7QUFDL0MsU0FBT0EsR0FBRSxJQUFJLEtBQUtBLEdBQUUsVUFBVSxHQUFHLEdBQUcsUUFBUSxJQUFJLEdBQUcsQ0FBQztBQUN0RDtBQUVBLElBQU0sVUFBVSxDQUFDLFlBQXNCO0FBQ3JDLFNBQU9BLEdBQUUsVUFBVSxTQUFTLGVBQWUsQ0FBQyxDQUFDO0FBQy9DO0FBTUEsSUFBTSxtQkFBbUIsTUFBTTtBQUM3QixTQUFPLFFBQVEsSUFBSSxZQUFZLFFBQVEsSUFBSTtBQUM3QztBQU9BLElBQU0sWUFBWSxNQUFNO0FBQ3RCLFNBQU8sUUFBUSxJQUFJLFlBQVksUUFBUSxJQUFJO0FBQzdDO0FBRUEsSUFBTSxpQkFBaUIsTUFBTTtBQUMzQixTQUFPQSxHQUFFLEtBQUssUUFBUSxLQUFLLENBQUMsS0FBSyxRQUFRO0FBQ3ZDLFdBQU8sY0FBYyxLQUFLLEdBQUc7QUFBQSxFQUMvQixDQUFDO0FBQ0g7QUFFQSxJQUFNLFdBQVcsTUFBTTtBQUNyQixTQUFPLFFBQVEsSUFBSTtBQUNyQjtBQUVBLElBQU0sa0JBQWtCLE1BQU07QUFDNUIsU0FDRSxRQUFRLElBQUksV0FDWixRQUFRLElBQUksWUFBWSxjQUN4QixRQUFRLElBQUk7QUFFaEI7QUFFQSxJQUFNLGdCQUFnQixNQUFNO0FBQzFCLFNBQ0UsUUFBUSxJQUFJLFdBQ1osUUFBUSxJQUFJLFlBQVksY0FDeEIsQ0FBQyxRQUFRLElBQUk7QUFFakI7QUFFQSxJQUFNLGNBQWMsTUFBTTtBQUN4QixTQUFPQSxHQUFFLEtBQUssUUFBUSxLQUFLLENBQUMsS0FBSyxRQUFRO0FBQ3ZDLFdBQU8sY0FBYyxLQUFLLEdBQUc7QUFBQSxFQUMvQixDQUFDO0FBQ0g7QUFFQSxJQUFNLFdBQVcsTUFBTTtBQUNyQixTQUNFLFFBQVEsSUFBSSxhQUNYLFFBQVEsSUFBSSxrQkFBa0IsVUFBVSxLQUFLLFFBQVEsSUFBSSxjQUFjO0FBRTVFO0FBRUEsSUFBTSxnQkFBZ0IsTUFBTTtBQUkxQixTQUNFLFFBQVEsSUFBSSxlQUNaLFFBQVEsSUFBSSxrQkFDWixRQUFRLElBQUk7QUFFaEI7QUFFQSxJQUFNLFlBQVksTUFBTTtBQUN0QixTQUNFLFFBQVEsSUFBSSxlQUNaLFFBQVEsSUFBSSxnQkFDWixRQUFRLElBQUksbUJBQ1osUUFBUSxJQUFJLGNBQ1osUUFBUSxJQUFJO0FBRWhCO0FBRUEsSUFBTSxZQUFZLE1BQU07QUFDdEIsU0FBTyxRQUFRLElBQUksV0FBVyxRQUFRLElBQUk7QUFDNUM7QUFVQSxJQUFNLGVBQWU7QUFBQSxFQUNuQixVQUFVO0FBQUEsRUFDVixPQUFPO0FBQUEsRUFDUCxjQUFjO0FBQUEsRUFDZCxRQUFRO0FBQUEsRUFDUixXQUFXO0FBQUEsRUFDWCxXQUFXO0FBQUEsRUFDWCxRQUFRO0FBQUEsRUFDUixlQUFlO0FBQUEsRUFDZixhQUFhO0FBQUEsRUFDYixXQUFXO0FBQUEsRUFDWCxXQUFXO0FBQUEsRUFDWCxPQUFPO0FBQUEsRUFDUCxlQUFlO0FBQUEsRUFDZixRQUFRO0FBQUEsRUFDUixNQUFNO0FBQUEsRUFDTixhQUFhO0FBQUEsRUFDYixTQUFTO0FBQUEsRUFDVCxXQUFXO0FBQUEsRUFDWCxXQUFXO0FBQUEsRUFDWCxVQUFVO0FBQUEsRUFDVixnQkFBZ0I7QUFBQSxFQUNoQixRQUFRO0FBQUEsRUFDUixTQUFTO0FBQUEsRUFDVCxTQUFTO0FBQUEsRUFDVCxTQUFTO0FBQ1g7QUFFQSxTQUFTLHNCQUEwQztBQUNqRCxRQUFNLEVBQUUsSUFBSSxJQUFJO0FBSWhCLFNBQU9BLEdBQUUsUUFBUSxjQUFjLENBQUMsVUFBVTtBQUN4QyxRQUFJQSxHQUFFLFNBQVMsS0FBSyxHQUFHO0FBQ3JCLGFBQU8sSUFBSSxLQUFLO0FBQUEsSUFDbEI7QUFFQSxRQUFJQSxHQUFFLFdBQVcsS0FBSyxHQUFHO0FBQ3ZCLGFBQU8sTUFBTTtBQUFBLElBQ2Y7QUFBQSxFQUNGLENBQUM7QUFDSDtBQUlBLElBQU0sb0JBQW9CLE1BQTJCO0FBQ25ELFNBQU87QUFBQSxJQUNMLFVBQVUsUUFBUTtBQUFBLE1BQ2hCO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsSUFDRixDQUFDO0FBQUEsSUFDRCxPQUFPLFFBQVE7QUFBQSxNQUNiO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsSUFDRixDQUFDO0FBQUEsSUFDRCxjQUFjLFFBQVE7QUFBQSxNQUNwQjtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxJQUNGLENBQUM7QUFBQSxJQUNELFFBQVEsUUFBUTtBQUFBLE1BQ2Q7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxJQUNGLENBQUM7QUFBQSxJQUNELFdBQVcsUUFBUTtBQUFBLE1BQ2pCO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBO0FBQUEsTUFFQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsSUFDRixDQUFDO0FBQUEsSUFDRCxXQUFXLFFBQVE7QUFBQSxNQUNqQjtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsSUFDRixDQUFDO0FBQUEsSUFDRCxRQUFRLFFBQVE7QUFBQSxNQUNkO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLElBQ0YsQ0FBQztBQUFBLElBQ0QsZUFBZSxRQUFRO0FBQUEsTUFDckI7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLElBQ0YsQ0FBQztBQUFBO0FBQUE7QUFBQSxJQUdELGFBQWEsUUFBUSxDQUFDLGVBQWUsZ0JBQWdCLGVBQWUsQ0FBQztBQUFBO0FBQUEsSUFFckUsV0FBVyxRQUFRO0FBQUEsTUFDakI7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLElBQ0YsQ0FBQztBQUFBO0FBQUEsSUFFRCxXQUFXLFFBQVE7QUFBQSxNQUNqQjtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUE7QUFBQSxNQUVBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsSUFDRixDQUFDO0FBQUEsSUFDRCxPQUFPLFFBQVE7QUFBQSxNQUNiO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsSUFDRixDQUFDO0FBQUE7QUFBQSxJQUVELGVBQWUsUUFBUTtBQUFBLE1BQ3JCO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxJQUNGLENBQUM7QUFBQTtBQUFBLElBRUQsUUFBUSxRQUFRO0FBQUE7QUFBQSxNQUVkO0FBQUEsTUFDQTtBQUFBO0FBQUEsTUFFQTtBQUFBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUE7QUFBQSxNQUVBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQTtBQUFBLElBRUYsQ0FBQztBQUFBO0FBQUEsSUFFRCxNQUFNLFFBQVE7QUFBQSxNQUNaO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsSUFDRixDQUFDO0FBQUEsSUFDRCxhQUFhLFFBQVE7QUFBQTtBQUFBLE1BRW5CO0FBQUEsTUFDQTtBQUFBO0FBQUEsTUFFQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQTtBQUFBLElBRUYsQ0FBQztBQUFBLElBQ0QsU0FBUyxRQUFRLENBQUMsWUFBWSxhQUFhLGdCQUFnQixhQUFhLENBQUM7QUFBQTtBQUFBO0FBQUEsSUFHekUsV0FBVyxRQUFRO0FBQUEsTUFDakI7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUE7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUE7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUE7QUFBQSxJQUNGLENBQUM7QUFBQTtBQUFBLElBRUQsV0FBVyxRQUFRO0FBQUE7QUFBQSxNQUVqQjtBQUFBO0FBQUEsTUFDQTtBQUFBO0FBQUEsTUFDQTtBQUFBO0FBQUEsTUFDQTtBQUFBO0FBQUEsTUFDQTtBQUFBO0FBQUEsTUFDQTtBQUFBO0FBQUEsTUFDQTtBQUFBO0FBQUE7QUFBQSxNQUVBO0FBQUE7QUFBQSxNQUNBO0FBQUE7QUFBQSxNQUNBO0FBQUE7QUFBQSxNQUNBO0FBQUE7QUFBQSxNQUNBO0FBQUE7QUFBQSxNQUNBO0FBQUE7QUFBQSxNQUNBO0FBQUE7QUFBQSxNQUNBO0FBQUE7QUFBQTtBQUFBLE1BRUE7QUFBQTtBQUFBLE1BQ0E7QUFBQTtBQUFBLE1BQ0E7QUFBQTtBQUFBLE1BQ0E7QUFBQTtBQUFBLE1BQ0E7QUFBQTtBQUFBLE1BQ0E7QUFBQTtBQUFBLElBQ0YsQ0FBQztBQUFBLElBQ0QsVUFBVTtBQUFBLElBQ1YsZ0JBQWdCLFFBQVE7QUFBQSxNQUN0QjtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsSUFDRixDQUFDO0FBQUEsSUFDRCxRQUFRLFFBQVE7QUFBQSxNQUNkO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLElBQ0YsQ0FBQztBQUFBLElBQ0QsU0FBUztBQUFBO0FBQUEsSUFFVCxTQUFTLFFBQVE7QUFBQSxNQUNmO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxJQUNGLENBQUM7QUFBQTtBQUFBLElBRUQsU0FBUyxRQUFRO0FBQUEsTUFDZjtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQTtBQUFBLElBQ0YsQ0FBQztBQUFBLEVBQ0g7QUFDRjtBQUlBLElBQU0sd0JBQXdCLE1BQStCO0FBQzNELFFBQU0sRUFBRSxJQUFJLElBQUk7QUFFaEIsU0FBTztBQUFBLElBQ0wsVUFBVTtBQUFBLE1BQ1IsS0FBSyxJQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BTVQsUUFDRSxJQUFJLDBDQUEwQyxJQUFJO0FBQUEsTUFDcEQsU0FBUztBQUFBLFFBQ1A7QUFBQSxRQUNBLElBQUk7QUFBQSxRQUNKLElBQUk7QUFBQSxNQUNOO0FBQUEsTUFDQSxZQUFZLElBQUk7QUFBQSxNQUNoQixhQUFhLElBQUk7QUFBQTtBQUFBO0FBQUEsSUFHbkI7QUFBQSxJQUNBLGNBQWM7QUFBQSxNQUNaLEtBQUssSUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFLVCxjQUFjLElBQUk7QUFBQTtBQUFBLElBRXBCO0FBQUEsSUFDQSxPQUFPO0FBQUEsTUFDTCxLQUFLLElBQUk7QUFBQSxNQUNULFFBQVEsSUFBSTtBQUFBLE1BQ1osU0FBUyxJQUFJO0FBQUEsTUFDYixZQUFZLElBQUk7QUFBQSxNQUNoQixhQUFhLElBQUk7QUFBQSxJQUNuQjtBQUFBLElBQ0EsUUFBUTtBQUFBLE1BQ04sS0FBSyxJQUFJO0FBQUEsTUFDVCxRQUFRLElBQUk7QUFBQTtBQUFBLE1BRVosWUFBWSxJQUFJO0FBQUE7QUFBQSxNQUVoQixjQUFjLElBQUk7QUFBQTtBQUFBLElBRXBCO0FBQUEsSUFDQSxXQUFXO0FBQUEsTUFDVCxLQUFLLElBQUk7QUFBQSxNQUNULFFBQVEsSUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQU1kO0FBQUEsSUFDQSxXQUFXO0FBQUEsTUFDVCxLQUFLLElBQUk7QUFBQSxNQUNULFFBQVEsSUFBSTtBQUFBLE1BQ1osU0FBUyxJQUFJO0FBQUEsTUFDYixZQUFZLElBQUk7QUFBQSxNQUNoQixhQUFhLElBQUk7QUFBQSxNQUNqQixjQUFjLElBQUk7QUFBQSxNQUNsQixlQUFlLElBQUk7QUFBQSxJQUNyQjtBQUFBLElBQ0EsUUFBUTtBQUFBLE1BQ04sS0FBSyxJQUFJO0FBQUEsTUFDVCxRQUFRLElBQUk7QUFBQTtBQUFBLE1BRVosWUFBWSxJQUFJO0FBQUE7QUFBQSxNQUVoQixjQUFjLElBQUk7QUFBQTtBQUFBLElBRXBCO0FBQUEsSUFDQSxlQUFlO0FBQUEsTUFDYixLQUFLLElBQUk7QUFBQSxNQUNULFFBQVEsSUFBSTtBQUFBLE1BQ1osU0FBUyxJQUFJO0FBQUEsTUFDYixZQUFZLElBQUk7QUFBQSxNQUNoQixhQUFhLElBQUk7QUFBQTtBQUFBO0FBQUEsSUFHbkI7QUFBQSxJQUNBLGFBQWE7QUFBQSxNQUNYLEtBQUssSUFBSTtBQUFBLE1BQ1QsUUFBUSxJQUFJO0FBQUEsTUFDWixTQUFTLElBQUk7QUFBQSxNQUNiLFlBQVksSUFBSTtBQUFBLE1BQ2hCLGFBQWEsSUFBSTtBQUFBO0FBQUE7QUFBQSxJQUduQjtBQUFBLElBQ0EsV0FBVztBQUFBLE1BQ1QsS0FBSyxJQUFJO0FBQUEsTUFDVCxRQUFRLElBQUk7QUFBQSxNQUNaLFNBQVMsSUFBSTtBQUFBLE1BQ2IsWUFBWSxJQUFJO0FBQUEsSUFDbEI7QUFBQSxJQUNBLE9BQU87QUFBQSxNQUNMLEtBQUssSUFBSTtBQUFBO0FBQUEsTUFFVCxRQUFRLElBQUk7QUFBQSxNQUNaLFNBQVMsSUFBSTtBQUFBLE1BQ2IsWUFBWSxJQUFJO0FBQUEsTUFDaEIsYUFBYSxJQUFJO0FBQUEsTUFDakIsY0FBYyxJQUFJO0FBQUEsTUFDbEIsZUFBZSxJQUFJO0FBQUEsSUFDckI7QUFBQSxJQUNBLGVBQWU7QUFBQSxNQUNiLEtBQUssSUFBSTtBQUFBLE1BQ1QsUUFBUSxJQUFJLGFBQWEsSUFBSTtBQUFBLE1BQzdCLGVBQWUsSUFBSTtBQUFBLE1BQ25CLGNBQWMsSUFBSTtBQUFBLE1BQ2xCLFlBQVksSUFBSTtBQUFBLElBQ2xCO0FBQUEsSUFDQSxRQUFRO0FBQUEsTUFDTixLQUFLLElBQUk7QUFBQSxNQUNULFFBQVEsSUFBSTtBQUFBLE1BQ1osU0FBUyxJQUFJO0FBQUEsTUFDYixZQUFZLElBQUk7QUFBQSxNQUNoQixhQUFhLElBQUk7QUFBQSxNQUNqQixjQUFjLElBQUk7QUFBQSxNQUNsQixlQUFlLElBQUk7QUFBQSxJQUNyQjtBQUFBLElBQ0EsYUFBYTtBQUFBLE1BQ1gsS0FBSyxJQUFJO0FBQUEsTUFDVCxRQUFRLElBQUk7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFNZDtBQUFBLElBQ0EsU0FBUztBQUFBLE1BQ1AsS0FBSyxJQUFJO0FBQUEsTUFDVCxRQUFRLElBQUk7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFNZDtBQUFBO0FBQUEsSUFFQSxXQUFXO0FBQUEsTUFDVCxLQUFLLElBQUk7QUFBQSxNQUNULFFBQVEsSUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BSVosY0FBYyxJQUFJO0FBQUE7QUFBQSxJQUVwQjtBQUFBLElBQ0EsV0FBVztBQUFBLE1BQ1QsS0FBSyxJQUFJO0FBQUEsTUFDVCxRQUFRLElBQUk7QUFBQSxNQUNaLFNBQVMsSUFBSTtBQUFBLE1BQ2IsWUFBWSxJQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFJbEI7QUFBQSxJQUNBLE1BQU07QUFBQSxJQUNOLFVBQVU7QUFBQSxJQUNWLGdCQUFnQjtBQUFBLE1BQ2QsS0FBSyxJQUFJO0FBQUEsTUFDVCxRQUFRLElBQUk7QUFBQSxNQUNaLFNBQVMsSUFBSTtBQUFBLE1BQ2IsWUFBWSxJQUFJO0FBQUEsSUFDbEI7QUFBQSxJQUNBLFFBQVE7QUFBQSxNQUNOLEtBQUssSUFBSSwyQkFBMkIsSUFBSTtBQUFBO0FBQUEsTUFFeEMsUUFBUSxJQUFJLDhCQUE4QixJQUFJO0FBQUE7QUFBQTtBQUFBLE1BRzlDLFNBQVMsSUFBSTtBQUFBO0FBQUE7QUFBQSxJQUdmO0FBQUEsSUFDQSxTQUFTO0FBQUEsSUFDVCxTQUFTO0FBQUEsTUFDUCxLQUFLLElBQUk7QUFBQSxNQUNULFFBQVEsSUFBSTtBQUFBLE1BQ1osY0FBYyxJQUFJO0FBQUEsSUFDcEI7QUFBQSxJQUNBLFNBQVM7QUFBQSxNQUNQLEtBQUssSUFBSTtBQUFBLE1BQ1QsUUFBUSxJQUFJO0FBQUEsTUFDWixTQUFTLElBQUk7QUFBQSxJQUNmO0FBQUEsRUFDRjtBQUNGO0FBd0JBLElBQU0sT0FBTyxDQUFDLE9BQTREO0FBQ3hFLFFBQU0sZUFBZSxjQUFjO0FBQ25DLE1BQUksQ0FBQztBQUFjLFdBQU8sQ0FBQztBQUUzQixTQUFPQSxHQUFFLE1BQU0sR0FBRyxDQUFDLEVBQUUsSUFBSSxZQUFZLEVBQUUsTUFBTTtBQUMvQztBQVFBLFNBQVMsc0JBQXNCLFlBQTJCO0FBQ3hELE1BQUksY0FBYyw2QkFBNkIsRUFBRSxTQUFTLFVBQVU7QUFDbEUsV0FBTztBQUVULFFBQU0sSUFBSTtBQUFBLElBQ1I7QUFBQSxFQUNGO0FBQ0Y7QUFRTyxTQUFTLCtCQUErQjtBQUM3QyxTQUFPQyxHQUFFLE1BQU0sa0JBQWtCLENBQUMsRUFBRSxPQUFPQSxHQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsTUFBTTtBQUNwRTtBQUlPLFNBQVMsZ0JBQTRCO0FBQzFDLFNBQU8sb0JBQW9CLEtBQUs7QUFDbEM7QUFNTyxTQUFTLGNBQWM7QUFDNUIsU0FBTyxLQUFLLGlCQUFpQjtBQUMvQjtBQUVPLFNBQVMsa0JBQWtCO0FBQ2hDLFNBQU8sS0FBSyxxQkFBcUI7QUFDbkM7QUFFTyxTQUFTLE1BQU0sV0FBb0I7QUFDeEMsUUFBTSxTQUFTLFlBQVk7QUFDM0IsUUFBTSxXQUFXLGNBQWM7QUFDL0IsTUFBSSxDQUFDO0FBQVcsMEJBQXNCLFFBQVE7QUFFOUMsRUFBQUMsT0FBTSw0QkFBNEIsUUFBUTtBQUMxQyxFQUFBQSxPQUFNLDBCQUEwQixNQUFNO0FBQ3RDLFNBQU87QUFBQSxJQUNMO0FBQUEsSUFDQTtBQUFBLEVBQ0Y7QUFDRjtBQUVPLFNBQVMsa0JBQWtCLGNBQThCO0FBQzlELEVBQUFBLE9BQU0sMEJBQTBCO0FBQ2hDLEVBQUFBLE9BQU0sWUFBWTtBQUVsQixRQUFNLGtCQUFrQixnQkFBZ0I7QUFFeEMsRUFBQUEsT0FBTSx1REFBdUQsZUFBZTtBQU01RSxRQUFNLFdBQVdELEdBQUU7QUFBQSxJQUNqQjtBQUFBLElBQ0EsQ0FDRSxNQUNBLE9BQ0EsUUFDRztBQUNILGFBQVEsS0FBSyxHQUFHLElBQUlBLEdBQUUsVUFBVSxTQUFTLGdCQUFnQixHQUFHLEdBQUcsSUFBSTtBQUFBLElBQ3JFO0FBQUEsRUFDRjtBQUVBLEVBQUFDLE9BQU0sc0RBQXNEO0FBQzVELEVBQUFBLE9BQU0sUUFBUTtBQUVkLFNBQU87QUFDVDs7O0FDbHZCQSxPQUFPLGFBQWE7QUFNcEIsT0FBT0MsWUFBVztBQUNsQixPQUFPQyxRQUFPOzs7QUNQZCxPQUFPLGNBQWM7QUFFckIsU0FBUyxRQUFRLE9BQU87QUFBQSxFQUN0QixjQUFjO0FBQ2hCLENBQUM7QUFDTSxJQUFNLFdBQVcsU0FBUztBQUUxQixJQUFNLE9BQ1gsQ0FDRSxJQUNBLFNBQ0EsY0FFRixVQUFVLFNBQVk7QUFDcEIsTUFBSTtBQUNGLFVBQU0sSUFBSSxNQUFNLEdBQUcsR0FBRyxJQUFJO0FBQzFCLGNBQVU7QUFDVixXQUFPO0FBQUEsRUFDVCxTQUFTLEdBQVA7QUFDQSxXQUFPLFFBQVEsQ0FBQztBQUFBLEVBQ2xCO0FBQ0Y7OztBRFJGLElBQU1DLFNBQVFDLE9BQU0sa0JBQWtCO0FBSy9CLFNBQVMsZUFBZSxTQUFnQyxDQUFDLEdBQUc7QUFHakUsUUFBTSxJQUFJO0FBQUEsSUFDUixHQUFHO0FBQUEsSUFDSCxXQUFXO0FBQUEsSUFDWCxLQUFLO0FBQUEsSUFDTCxVQUFVO0FBQUEsSUFDVixRQUFRO0FBQUEsSUFDUixPQUFPO0FBQUEsSUFDUCxNQUFNQyxHQUFFLFFBQVEsT0FBTyxJQUFJLEVBQUUsS0FBSyxHQUFHO0FBQUEsRUFDdkM7QUFDQSxFQUFBRixPQUFNLHVDQUF1QyxDQUFDO0FBQzlDLFNBQU8sUUFBUSxJQUFJLENBQUM7QUFDdEI7QUFLQSxlQUFzQixZQUNwQixFQUFFLEtBQUssR0FDUCxtQkFDQTtBQUNBLFFBQU0sZ0JBQWdCLHVCQUF1QixpQkFBaUI7QUFFOUQsUUFBTSxVQUFVO0FBQUEsSUFDZCxHQUFHO0FBQUEsSUFDSCxRQUFRO0FBQUEsTUFDTixHQUFHLGNBQWM7QUFBQSxNQUNqQix1QkFBdUI7QUFBQSxJQUN6QjtBQUFBLElBQ0EsS0FBSztBQUFBLE1BQ0gsR0FBRyxjQUFjO0FBQUEsTUFDakIsYUFBYSxXQUFXO0FBQUEsSUFDMUI7QUFBQSxJQUNBO0FBQUEsRUFDRjtBQUNBLEVBQUFBLE9BQU0sbUNBQW1DLE9BQU87QUFDaEQsUUFBTSxTQUFTLE1BQU0sUUFBUSxJQUFJLE9BQU87QUFFeEMsTUFBSSxPQUFPLFdBQVcsVUFBVTtBQUM5QixTQUFLLDRDQUE0QyxPQUFPLE9BQU87QUFDL0Q7QUFBQSxNQUNFO0FBQUEsTUFDQSxLQUNHLE1BQU0sR0FBRyxFQUNULElBQUksQ0FBQyxNQUFNO0FBQUEsS0FBUSxHQUFHLEVBQ3RCLEtBQUssRUFBRTtBQUFBLElBQ1o7QUFBQSxFQUNGO0FBQ0EsRUFBQUEsT0FBTSx5QkFBeUIsTUFBTTtBQUNyQyxTQUFPO0FBQ1Q7QUFFTyxJQUFNLGtCQUFrQixDQUM3QixNQUNBLHNCQUVBO0FBQUEsRUFDRTtBQUFBLEVBQ0EsQ0FBQ0csV0FBVTtBQUNULFVBQU0sVUFBVTtBQUFBLEVBQ2JBLE9BQWdCO0FBQUEsRUFDYkEsT0FBZ0I7QUFDdEIsSUFBQUgsT0FBTSw0QkFBNEJHLE1BQUs7QUFDdkMsU0FBSyxnQ0FBZ0MsT0FBTztBQUM1QztBQUFBLE1BQ0U7QUFBQSxNQUNBLEtBQUssS0FDRixNQUFNLEdBQUcsRUFDVCxJQUFJLENBQUMsTUFBTTtBQUFBLEtBQVEsR0FBRyxFQUN0QixLQUFLLEVBQUU7QUFBQSxJQUNaO0FBQ0EsV0FBTztBQUFBLE1BQ0wsUUFBUTtBQUFBLE1BQ1IsVUFBVTtBQUFBLE1BQ1Y7QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUFBLEVBQ0EsTUFBTTtBQUFBLEVBQUM7QUFDVCxFQUFFLE1BQU0saUJBQWlCOzs7QUVsRzNCLE9BQU9DLGFBQVc7QUFDbEIsU0FBUyxTQUFBQyxRQUFPLEtBQUFDLFVBQVM7QUFRbEIsU0FBUyxjQUFjLE1BQTJDO0FBQ3ZFLEVBQUFDLE9BQU0sSUFBSSxFQUNQLEtBQUtDLEdBQUUsV0FBVyxLQUFLLEdBQUcsQ0FBQyxNQUFNLEVBQUUsUUFBUSxZQUFZLENBQUMsRUFDeEQsS0FBSyxNQUFNLE1BQU0sNEJBQTBCLENBQUMsRUFDNUM7QUFBQSxJQUNDQSxHQUFFO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUtGO0FBQUEsSUFDQSxDQUFDLE1BQU0sYUFBYSxDQUFDO0FBQUEsRUFDdkIsRUFDQyxVQUFVLE1BQU0sOEJBQTJCLENBQUM7QUFDakQ7QUFFQSxTQUFTLGFBQWEsTUFBYztBQUNsQyxNQUFJLDRCQUF5QjtBQUMzQjtBQUFBLEVBQ0Y7QUFFQSxRQUFNLFNBQVMsSUFBSSxJQUFJLFFBQVEsSUFBSSxRQUFRLFFBQVEsSUFBSSxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsQ0FBQztBQUM1RSxFQUFBRCxPQUFNLElBQUksRUFDUCxzQkFBb0IsTUFBTTtBQUN6QixXQUFPLElBQUksOEJBQXNCO0FBQ2pDLFdBQU8sSUFBSSwyQkFBb0I7QUFDL0IsV0FBTyxJQUFJLHlCQUFtQjtBQUFBLEVBQ2hDLENBQUMsRUFDQSxnQ0FBeUIsTUFBTSxPQUFPLElBQUksMkJBQW9CLENBQUMsRUFDL0QsOEJBQXdCLE1BQU0sT0FBTyxJQUFJLHlCQUFtQixDQUFDLEVBQzdELHFDQUEyQixNQUFNLE9BQU8sSUFBSSw4QkFBc0IsQ0FBQyxFQUNuRSxVQUFVLE1BQU07QUFBQSxFQUFDLENBQUM7QUFFckIsRUFBQUUsUUFBTSxPQUFPLE1BQU0sS0FBSyxNQUFNLEVBQUUsS0FBSyxHQUFHLENBQUM7QUFDM0M7OztBQ3pDTyxJQUFNLGFBQWEsTUFDeEIsQ0FBQyxDQUFDLFFBQVEsSUFBSSxnQ0FDZCxjQUFjLE1BQU07OztBQ0h0QixPQUFPLFNBQVM7QUFHVCxJQUFNLGFBQWEsT0FBTyxnQkFBd0I7QUFDdkQsUUFBTSxhQUFhLE1BQU0sSUFBSSxXQUFXLFdBQVc7QUFDbkQsU0FBTyxrQkFBa0I7QUFBQSxJQUN2QixRQUFRLFdBQVc7QUFBQSxJQUNuQixjQUFjLFdBQVc7QUFBQSxJQUN6QixhQUFhLFdBQVc7QUFBQSxJQUN4QixZQUFZLFdBQVc7QUFBQSxJQUN2QixTQUFTLFdBQVc7QUFBQSxJQUNwQixLQUFLLFdBQVc7QUFBQSxFQUNsQixDQUFDO0FBQ0g7OztBQ2RBLE9BQU9DLFlBQVc7QUFJbEIsSUFBTUMsVUFBUUMsT0FBTSxrQkFBa0I7QUFFL0IsU0FBUyxhQUNkLFNBQ0Esb0JBQXVDLENBQUMsR0FDVTtBQUNsRCxFQUFBRDtBQUFBLElBQ0U7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLEVBQ0Y7QUFFQSxNQUFJLFNBQVMsa0JBQWtCLEtBQUssQ0FBQyxNQUFNLEVBQUUsU0FBUyxPQUFPO0FBRTdELE1BQUksUUFBUTtBQUNWLElBQUFBLFFBQU0sa0NBQWtDLE1BQU07QUFDOUMsV0FBTztBQUFBLE1BQ0wsYUFBYSxPQUFPO0FBQUEsTUFDcEIsZ0JBQWdCLE9BQU87QUFBQSxJQUN6QjtBQUFBLEVBQ0Y7QUFHQSxXQUFTLGtCQUFrQixLQUFLLENBQUMsTUFBTSxFQUFFLFNBQVMsT0FBTztBQUN6RCxNQUFJLFFBQVE7QUFDVixJQUFBQSxRQUFNLGtDQUFrQyxNQUFNO0FBQzlDLFdBQU87QUFBQSxNQUNMLGFBQWEsT0FBTyxlQUFlLE9BQU87QUFBQSxNQUMxQyxnQkFBZ0IsT0FBTztBQUFBLElBQ3pCO0FBQUEsRUFDRjtBQUVBLE9BQUssNkNBQTZDO0FBR2xELFNBQU87QUFBQSxJQUNMLGFBQWE7QUFBQSxJQUNiLGdCQUFnQjtBQUFBLEVBQ2xCO0FBQ0Y7OztBQzNDQSxPQUFPRSxhQUFXO0FBQ2xCLE9BQU8sV0FBVztBQUNsQixTQUFTLE1BQU0sU0FBUyxVQUFVLFNBQVMsZ0JBQWdCO0FBQzNELFNBQVMsaUJBQWlCO0FBRTFCLElBQU1DLFVBQVFELFFBQU0sbUJBQW1CO0FBRXZDLElBQU0sZUFBZSxZQUFZO0FBQy9CLE1BQUksU0FBUyxNQUFNLFNBQVM7QUFDMUIsUUFBSTtBQUNGLFlBQU0sVUFBVSxNQUFNLFVBQVUsS0FBSyxFQUFFO0FBQ3ZDLFVBQUksVUFBVSxXQUFXLGFBQWEsU0FBUztBQUM3QyxlQUFPLENBQUMsUUFBUSxNQUFNLFFBQVEsT0FBTyxFQUFFLEtBQUssS0FBSztBQUFBLE1BQ25ELE9BQU87QUFDTCxlQUFPLFFBQVE7QUFBQSxNQUNqQjtBQUFBLElBQ0YsUUFBRTtBQUNBLGFBQU8sUUFBUTtBQUFBLElBQ2pCO0FBQUEsRUFDRjtBQUNBLFNBQU8sUUFBUTtBQUNqQjtBQUVPLElBQU0sa0JBQWtCLFlBQVk7QUFDekMsUUFBTSxZQUFZLE1BQU0sYUFBYTtBQUNyQyxRQUFNLFNBQVM7QUFBQSxJQUNiLFFBQVEsU0FBUztBQUFBLElBQ2pCO0FBQUEsSUFDQSxRQUFRLEtBQUs7QUFBQSxJQUNiLFVBQVU7QUFBQSxNQUNSLE1BQU0sUUFBUTtBQUFBLE1BQ2QsT0FBTyxTQUFTO0FBQUEsSUFDbEI7QUFBQSxFQUNGO0FBQ0EsRUFBQUMsUUFBTSxxQkFBcUIsTUFBTTtBQUNqQyxTQUFPO0FBQ1Q7OztBQ2hDQSxlQUFzQixZQUFZO0FBQUEsRUFDaEM7QUFBQSxFQUNBO0FBQ0YsR0FHRztBQUNELFNBQU87QUFBQSxJQUNMLEdBQUksTUFBTSxnQkFBZ0I7QUFBQSxJQUMxQixHQUFHLGFBQWEsV0FBVyxZQUFZLE9BQU8sVUFBVSxRQUFRO0FBQUEsRUFDbEU7QUFDRjs7O0FDZEEsT0FBT0MsYUFBVztBQUNsQixPQUFPQyxRQUFPO0FBQ2QsU0FBUyxjQUFjO0FBU3ZCLElBQU1DLFVBQVFGLFFBQU0sa0JBQWtCO0FBRS9CLElBQU0sa0JBQWtCLENBQzdCLFdBQ2tEO0FBQ2xELFNBQU8sT0FBTyxXQUFXO0FBQzNCO0FBRU8sSUFBTSx3QkFBd0IsQ0FDbkMsUUFBeUMsQ0FBQyxNQUNqQjtBQUN6QixTQUFPLE1BQU07QUFBQSxJQUFRLENBQUMsTUFBTSxNQUMxQixLQUFLLFNBQVM7QUFBQSxNQUFRLENBQUMsR0FBRyxPQUN4QixFQUFFLFlBQVksUUFBUSxDQUFDLE9BQU87QUFBQSxRQUM1QixHQUFHO0FBQUEsUUFDSCxRQUFRLElBQUk7QUFBQSxRQUNaLGtCQUFrQjtBQUFBLFFBQ2xCLGNBQWMsT0FBTztBQUFBLE1BQ3ZCLEVBQUU7QUFBQSxJQUNKO0FBQUEsRUFDRjtBQUNGO0FBRU8sSUFBTSxXQUFXLENBQUMsVUFBaUQ7QUFDeEUsU0FBTztBQUFBLElBQ0wsR0FBRztBQUFBLElBQ0gsbUJBQW1CLE1BQU07QUFBQSxJQUN6QixvQkFBb0IsTUFBTTtBQUFBLElBQzFCLGtCQUFrQixNQUFNO0FBQUEsRUFDMUI7QUFDRjtBQUVPLElBQU0saUJBQWlCLENBQUMsWUFBOEM7QUFDM0UsU0FBTztBQUFBLElBQ0wsR0FBRztBQUFBLElBQ0gsT0FBTyxRQUFRO0FBQUEsSUFDZixtQkFBbUIsUUFBUTtBQUFBLElBQzNCLG9CQUFvQixRQUFRO0FBQUEsRUFDOUI7QUFDRjtBQUVPLElBQU0sMkJBQTJCLENBQ3RDLGNBQ2lDO0FBQ2pDLFNBQU87QUFBQSxJQUNMLE9BQU8sU0FBUyxVQUFVLEtBQUs7QUFBQSxJQUMvQixlQUFlLFVBQVU7QUFBQSxJQUN6QixXQUFXLFVBQVUsU0FBUztBQUFBLElBQzlCLE9BQU8sQ0FBQyxDQUFDLFVBQVU7QUFBQTtBQUFBLElBQ25CLGFBQWEsc0JBQXNCLFVBQVUsU0FBUyxDQUFDLENBQUM7QUFBQSxJQUN4RCxPQUNFLFVBQVUsT0FBTyxJQUFJLENBQUMsTUFBTSxPQUFPO0FBQUEsTUFDakMsY0FBYyxLQUFLO0FBQUEsTUFDbkIsT0FBTyxLQUFLO0FBQUEsTUFDWixPQUFPLFVBQVU7QUFBQSxNQUNqQixVQUFVLEtBQUssVUFBVSxJQUFJLGNBQWMsS0FBSyxDQUFDO0FBQUEsTUFDakQsVUFBVSxJQUFJO0FBQUEsSUFDaEIsRUFBRSxLQUFLLENBQUM7QUFBQSxFQUNaO0FBQ0Y7QUFFTyxTQUFTLHlCQUNkRyxRQUNBLE9BQ0E7QUFDQSxTQUFPO0FBQUEsSUFDTCxPQUFPLENBQUMsU0FBUztBQUFBLElBQ2pCLE1BQU07QUFBQSxJQUNOLGNBQWNBLE9BQU0sTUFBTSxJQUFJLEVBQUUsQ0FBQztBQUFBLElBQ2pDLE9BQU87QUFBQSxJQUNQLE9BQU8sQ0FBQztBQUFBLElBQ1IsVUFBVTtBQUFBLE1BQ1IsZUFBZTtBQUFBLFFBQ2IsT0FBTztBQUFBLFFBQ1AsVUFBVTtBQUFBLFFBQ1YsT0FBTztBQUFBLFVBQ0wsTUFBTTtBQUFBLFVBQ04sU0FBU0EsT0FBTSxNQUFNLElBQUksRUFBRSxDQUFDO0FBQUEsVUFDNUIsT0FBT0E7QUFBQSxRQUNUO0FBQUEsUUFDQSxhQUFhLENBQUM7QUFBQSxRQUNkLFdBQVcsTUFBTTtBQUFBLFFBQ2pCLGdCQUFnQjtBQUFBLE1BQ2xCLENBQUM7QUFBQSxJQUNIO0FBQUEsSUFDQSxVQUFVO0FBQUEsRUFDWjtBQUNGO0FBRU8sSUFBTSwwQkFBMEIsQ0FDckMsV0FDQSxXQUM0QjtBQUM1QixTQUFPO0FBQUEsSUFDTDtBQUFBLElBQ0EsT0FDRSxVQUFVLE9BQU8sSUFBSSxDQUFDLE1BQU0sT0FBTztBQUFBLE1BQ2pDLE9BQU8sS0FBSztBQUFBLE1BQ1osUUFBUTtBQUFBLE1BQ1IsTUFBTSxLQUFLO0FBQUEsTUFDWCxVQUFVLElBQUk7QUFBQSxNQUNkLFNBQVMsQ0FBQztBQUFBLElBQ1osRUFBRSxLQUFLLENBQUM7QUFBQSxJQUNWLE9BQU8sVUFBVTtBQUFBLEVBQ25CO0FBQ0Y7QUFFTyxJQUFNLHVCQUF1QixDQUNsQyxPQUNBLFdBQ3dDO0FBQ3hDLE1BQUksQ0FBQyxNQUFNLFFBQVE7QUFDakIsV0FBTyx1QkFBdUIsTUFBTTtBQUFBLEVBQ3RDO0FBRUEsUUFBTSxVQUFVLE1BQU07QUFBQSxJQUNwQixDQUNFLEtBQ0E7QUFBQSxNQUNFO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsSUFDRixPQUNJO0FBQUEsTUFDSixlQUFlLElBQUksZ0JBQWdCO0FBQUEsTUFDbkMsYUFBYSxJQUFJLGNBQWM7QUFBQSxNQUMvQixjQUFjLElBQUksZUFBZTtBQUFBLE1BQ2pDLGFBQWEsSUFBSSxjQUFjO0FBQUEsTUFDL0IsY0FBYyxJQUFJLGVBQWU7QUFBQSxNQUNqQyxhQUFhLElBQUksY0FBYztBQUFBLE1BQy9CLFlBQVksSUFBSSxhQUFhO0FBQUEsSUFDL0I7QUFBQSxJQUNBO0FBQUEsRUFDRjtBQUNBLFFBQU0sY0FBYyxNQUFNLENBQUM7QUFDM0IsUUFBTSxhQUFhLE1BQU0sSUFBSSxDQUFDLE1BQU0sRUFBRSxjQUFjLEVBQUUsS0FBSztBQUMzRCxRQUFNLFdBQVcsTUFBTSxJQUFJLENBQUMsTUFBTSxFQUFFLFlBQVksRUFBRSxLQUFLO0FBQ3ZELFFBQU0sT0FBTyxNQUFNLElBQUksQ0FBQyxNQUFNLEVBQUUsSUFBSSxFQUFFLEtBQUs7QUFDM0MsU0FBTztBQUFBLElBQ0wsR0FBRztBQUFBLElBQ0g7QUFBQSxJQUNBLGdCQUFnQkYsR0FBRSxNQUFNLFVBQVU7QUFBQSxJQUNsQyxjQUFjQSxHQUFFLEtBQUssUUFBUTtBQUFBLElBQzdCLEdBQUdBLEdBQUU7QUFBQSxNQUNIO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLElBQ0Y7QUFBQSxJQUNBLFFBQVE7QUFBQSxFQUNWO0FBQ0Y7QUFFTyxTQUFTLHVCQUNkLFFBQ3FDO0FBQ3JDLFNBQU87QUFBQSxJQUNMLEdBQUc7QUFBQSxJQUNILFFBQVE7QUFBQSxJQUNSLGlCQUFnQixvQkFBSSxLQUFLLEdBQUUsWUFBWTtBQUFBLElBQ3ZDLGVBQWMsb0JBQUksS0FBSyxHQUFFLFlBQVk7QUFBQSxJQUNyQyxNQUFNLENBQUM7QUFBQTtBQUFBLElBRVA7QUFBQSxFQUNGO0FBQ0Y7QUFDQSxJQUFNLGFBQWE7QUFBQSxFQUNqQixlQUFlO0FBQUEsRUFDZixhQUFhO0FBQUEsRUFDYixjQUFjO0FBQUEsRUFDZCxhQUFhO0FBQUEsRUFDYixjQUFjO0FBQUEsRUFDZCxhQUFhO0FBQUEsRUFDYixZQUFZO0FBQ2Q7QUFFQSxJQUFNLHFCQUFxQixDQUFDLE9BQWVFLFlBQW1CO0FBQUEsRUFDNUQsT0FBTyxDQUFDLFNBQVM7QUFBQSxFQUNqQixPQUFPO0FBQUEsRUFDUCxNQUFNO0FBQUEsRUFDTixjQUFjQTtBQUFBLEVBQ2QsVUFBVTtBQUFBLElBQ1I7QUFBQSxNQUNFLE9BQU87QUFBQSxNQUNQLFdBQVc7QUFBQSxNQUNYLFVBQVU7QUFBQSxNQUNWLGdCQUFnQjtBQUFBLE1BQ2hCLGFBQWEsQ0FBQztBQUFBLE1BQ2QsT0FBTztBQUFBLFFBQ0wsTUFBTTtBQUFBLFFBQ04sU0FBU0E7QUFBQSxRQUNULE9BQU87QUFBQSxNQUNUO0FBQUEsSUFDRjtBQUFBLEVBQ0Y7QUFDRjtBQUVPLFNBQVMscUJBQ2QsYUFDQTtBQUFBLEVBQ0U7QUFBQSxFQUNBLE9BQUFBO0FBQ0YsR0FJcUM7QUFDckMsUUFBTSxTQUFRLG9CQUFJLEtBQUssR0FBRSxZQUFZO0FBQ3JDLFFBQU0sT0FBTSxvQkFBSSxLQUFLLEdBQUUsWUFBWTtBQUNuQyxTQUFPO0FBQUE7QUFBQSxJQUVMLFFBQVEsWUFBWSxVQUFVLEtBQUssQ0FBQztBQUFBLElBQ3BDLFFBQVE7QUFBQSxJQUNSLGlCQUFnQixvQkFBSSxLQUFLLEdBQUUsWUFBWTtBQUFBLElBQ3ZDLGVBQWMsb0JBQUksS0FBSyxHQUFFLFlBQVk7QUFBQSxJQUNyQyxlQUFlO0FBQUEsSUFDZixhQUFhO0FBQUEsSUFDYixhQUFhO0FBQUEsSUFDYixhQUFhO0FBQUEsSUFDYixjQUFjO0FBQUEsSUFDZCxjQUFjO0FBQUEsSUFDZCxZQUFZO0FBQUEsSUFDWixhQUFhO0FBQUEsSUFDYixnQkFBZ0I7QUFBQSxJQUNoQixhQUFhO0FBQUEsSUFDYixRQUFRO0FBQUEsSUFDUixXQUFXO0FBQUEsSUFDWCxnQkFBZ0I7QUFBQSxJQUNoQixNQUFNLE1BQU0sSUFBSSxDQUFDLE9BQU87QUFBQSxNQUN0QixPQUFPO0FBQUEsUUFDTCxRQUFRO0FBQUEsUUFDUixPQUFPO0FBQUEsUUFDUCxRQUFRO0FBQUEsUUFDUixTQUFTO0FBQUEsUUFDVCxTQUFTO0FBQUEsUUFDVCxVQUFVO0FBQUEsUUFDVixXQUFXO0FBQUEsUUFDWCxTQUFTO0FBQUEsUUFDVCxVQUFVO0FBQUEsTUFDWjtBQUFBLE1BQ0EsVUFBVTtBQUFBLE1BQ1YsZUFBZSxDQUFDO0FBQUEsTUFDaEIsT0FBTyxDQUFDO0FBQUEsTUFDUixPQUFBQTtBQUFBLE1BQ0EsT0FBTztBQUFBLE1BQ1AsTUFBTTtBQUFBLFFBQ0osTUFBTTtBQUFBLFFBQ04sVUFBVTtBQUFBLFFBQ1YsVUFBVTtBQUFBLFFBQ1Ysc0JBQXNCO0FBQUEsTUFDeEI7QUFBQSxNQUNBLE9BQU8sQ0FBQyxtQkFBbUIsT0FBT0EsTUFBSyxDQUFDO0FBQUEsTUFDeEMsbUJBQW1CO0FBQUEsTUFDbkIsYUFBYTtBQUFBLElBQ2YsRUFBRTtBQUFBLEVBQ0o7QUFDRjtBQUVPLFNBQVMsMkJBQ2QsTUFDQSxlQUNpRDtBQUNqRCxNQUFJLENBQUMsZ0JBQWdCLGFBQWEsR0FBRztBQUNuQztBQUFBLEVBQ0Y7QUFFQSxRQUFNQyxPQUFNLGNBQWMsS0FBSyxLQUFLLENBQUMsTUFBTSxFQUFFLEtBQUssYUFBYSxJQUFJO0FBQ25FLE1BQUksQ0FBQ0EsTUFBSztBQUNSO0FBQUEsRUFDRjtBQUNBLFFBQU0sUUFBUSxTQUFTQSxLQUFJLEtBQUs7QUFFaEMsU0FBTztBQUFBLElBQ0wsR0FBRztBQUFBLElBQ0gsTUFBTSxDQUFDQSxJQUFHO0FBQUEsSUFDVixhQUFhO0FBQUEsSUFDYixlQUFlLE1BQU07QUFBQSxJQUNyQixZQUFZLE1BQU07QUFBQSxJQUNsQixhQUFhLE1BQU07QUFBQSxJQUNuQixhQUFhLE1BQU07QUFBQSxJQUNuQixjQUFjLE1BQU07QUFBQSxJQUNwQixjQUFjLE1BQU07QUFBQSxJQUNwQixnQkFBZ0IsTUFBTTtBQUFBLElBQ3RCLGNBQWMsTUFBTTtBQUFBLEVBQ3RCO0FBQ0Y7OztBQ2pUQSxPQUFPQyxTQUFPO0FBQ2QsT0FBTyxjQUFjO0FBQ3JCLFNBQVMsYUFBYTtBQUd0QixJQUFNLGNBQWMsSUFBSSxRQUFHO0FBQzNCLElBQU0sY0FBYyxNQUFNLFFBQUc7QUFFdEIsSUFBTSxlQUFlLENBQUMsTUFBMkM7QUFDdEUsUUFBTSxtQkFBbUIsRUFBRSxLQUFLO0FBQ2hDLFFBQU0sbUJBQW1CQyxJQUFFO0FBQUEsSUFDekIsRUFBRSxLQUFLLE9BQU8sQ0FBQyxNQUFNLEVBQUUsTUFBTSxXQUFXLEVBQUUsTUFBTSxVQUFVLENBQUMsRUFBRSxJQUFJLE1BQU0sQ0FBQztBQUFBLEVBQzFFO0FBQ0EsUUFBTSxZQUFZLG1CQUFtQjtBQUVyQyxRQUFNLFVBQVUsWUFDWixJQUFJLEdBQUcsdUJBQXVCLHlCQUF5QixJQUN2RCxtQkFBbUIsSUFDbkIsc0JBQ0E7QUFFSixRQUFNLE9BQU8sRUFBRSxLQUFLLElBQUksQ0FBQ0MsT0FBTTtBQUFBLElBQzdCQSxHQUFFLE1BQU0sV0FBV0EsR0FBRSxNQUFNLFVBQVUsSUFBSSxjQUFjO0FBQUEsSUFDdkRBLEdBQUUsS0FBSztBQUFBLElBQ1AsS0FBSyxTQUFTQSxHQUFFLE1BQU0sUUFBUSxDQUFDO0FBQUEsSUFDL0IsTUFBTUEsR0FBRSxNQUFNLFNBQVMsQ0FBQztBQUFBLElBQ3hCQSxHQUFFLE1BQU0sU0FBUyxNQUFNQSxHQUFFLE1BQU0sTUFBTSxJQUFJLEtBQUssR0FBRztBQUFBLElBQ2pEQSxHQUFFLE1BQU0sV0FBVyxJQUFJQSxHQUFFLE1BQU0sUUFBUSxJQUFJLEtBQUssR0FBRztBQUFBLElBQ25EQSxHQUFFLE1BQU0sVUFBVSxLQUFLQSxHQUFFLE1BQU0sT0FBTyxJQUFJLEtBQUssR0FBRztBQUFBLElBQ2xEQSxHQUFFLE1BQU0sVUFBVSxJQUFJQSxHQUFFLE1BQU0sT0FBTyxJQUFJLEtBQUssR0FBRztBQUFBLEVBQ25ELENBQUM7QUFFRCxTQUFPO0FBQUEsSUFDTDtBQUFBLE1BQ0U7QUFBQSxRQUNFO0FBQUE7QUFBQSxRQUNBLEtBQUssTUFBTTtBQUFBLFFBQ1g7QUFBQSxRQUNBLEtBQUssT0FBTztBQUFBLFFBQ1osS0FBSyxTQUFTO0FBQUEsUUFDZCxLQUFLLFNBQVM7QUFBQSxRQUNkLEtBQUssU0FBUztBQUFBLFFBQ2QsS0FBSyxTQUFTO0FBQUEsTUFDaEI7QUFBQSxNQUNBLEdBQUc7QUFBQSxNQUNIO0FBQUEsUUFDRSxZQUFZLGNBQWM7QUFBQTtBQUFBLFFBQzFCO0FBQUEsUUFDQSxLQUFLLFNBQVMsRUFBRSxpQkFBaUIsQ0FBQyxDQUFDO0FBQUEsUUFDbkMsbUJBQW1CLElBQUksTUFBTSxFQUFFLGNBQWMsQ0FBQyxJQUFJLEtBQUssR0FBRztBQUFBLFFBQzFELEVBQUUsY0FBYyxNQUFNLEVBQUUsV0FBVyxJQUFJLEtBQUssR0FBRztBQUFBLFFBQy9DLEVBQUUsY0FBYyxJQUFJLEVBQUUsV0FBVyxJQUFJLEtBQUssR0FBRztBQUFBLFFBQzdDLEVBQUUsZUFBZSxLQUFLLEVBQUUsWUFBWSxJQUFJLEtBQUssR0FBRztBQUFBLFFBQ2hELEVBQUUsZUFBZSxJQUFJLEVBQUUsWUFBWSxJQUFJLEtBQUssR0FBRztBQUFBLE1BQ2pEO0FBQUEsSUFDRjtBQUFBLElBQ0E7QUFBQSxNQUNFO0FBQUEsTUFDQSxlQUFlO0FBQUEsUUFDYixPQUFPO0FBQUEsTUFDVDtBQUFBLE1BQ0EsU0FBUztBQUFBLFFBQ1AsRUFBRSxXQUFXLFFBQVEsT0FBTyxFQUFFO0FBQUEsUUFDOUIsRUFBRSxXQUFXLFFBQVEsT0FBTyxHQUFHO0FBQUEsUUFDL0IsRUFBRSxXQUFXLFFBQVE7QUFBQSxRQUNyQixFQUFFLFdBQVcsUUFBUTtBQUFBLFFBQ3JCLEVBQUUsV0FBVyxRQUFRO0FBQUEsUUFDckIsRUFBRSxXQUFXLFFBQVE7QUFBQSxRQUNyQixFQUFFLFdBQVcsUUFBUTtBQUFBLFFBQ3JCLEVBQUUsV0FBVyxRQUFRO0FBQUEsTUFDdkI7QUFBQTtBQUFBLE1BRUEsb0JBQW9CLENBQUMsV0FBVyxhQUFhO0FBQzNDLGVBQ0UsY0FBYyxLQUNkLGNBQWMsS0FDZCxjQUFjLFdBQVcsS0FDekIsY0FBYztBQUFBLE1BRWxCO0FBQUEsTUFDQSxrQkFBa0IsQ0FBQyxXQUFXLGFBQWE7QUFDekMsZUFBTyxjQUFjLEtBQUssYUFBYTtBQUFBLE1BQ3pDO0FBQUEsSUFDRjtBQUFBLEVBQ0Y7QUFDRjtBQUVBLElBQU0sU0FBU0QsSUFBRTtBQUFBLEVBQ2Y7QUFBQSxJQUNFLFNBQVM7QUFBQSxJQUNULFNBQVM7QUFBQSxJQUNULFNBQVM7QUFBQSxJQUNULFVBQVU7QUFBQSxJQUVWLFlBQVk7QUFBQSxJQUNaLFlBQVk7QUFBQSxJQUNaLFlBQVk7QUFBQSxJQUNaLGFBQWE7QUFBQSxJQUViLFVBQVU7QUFBQSxJQUNWLFdBQVc7QUFBQSxJQUNYLFVBQVU7QUFBQSxJQUVWLFVBQVU7QUFBQSxJQUNWLFVBQVU7QUFBQSxJQUNWLFdBQVc7QUFBQSxJQUNYLFVBQVU7QUFBQSxFQUNaO0FBQUEsRUFDQSxDQUFDLE1BQU0sS0FBSyxDQUFDO0FBQ2Y7OztBQzdHQSxPQUFPRSxhQUFXOzs7QUNBbEIsT0FBT0MsYUFBVzs7O0FDQWxCLE9BQU9DLGFBQVc7QUFDbEIsT0FBT0MsU0FBUTtBQUVmLElBQU0sV0FBV0MsSUFBRyxTQUFTO0FBQzdCLElBQU1DLFVBQVFDLFFBQU0saUJBQWlCO0FBRTlCLFNBQVMsWUFBWUMsT0FBYyxLQUFhO0FBQ3JELFNBQU8sV0FBV0EsT0FBTSxLQUFLLFdBQVc7QUFDMUM7QUFFTyxTQUFTLFlBQVlBLE9BQWMsS0FBYTtBQUNyRCxTQUFPLFdBQVdBLE9BQU0sS0FBSyxXQUFXO0FBQzFDO0FBR0EsZUFBZSxXQUFXQSxPQUFjLEtBQWEsTUFBbUI7QUFDdEUsRUFBQUYsUUFBTSwrQkFBK0JFLE9BQU0sR0FBRztBQUM5QyxRQUFNLElBQUksTUFBTSxTQUFTQSxLQUFJO0FBQzdCLFFBQU0sWUFBWTtBQUFBLElBQ2hCO0FBQUEsSUFDQSxRQUFRO0FBQUEsSUFDUixNQUFNO0FBQUEsSUFDTixTQUFTO0FBQUEsTUFDUCxnQkFBZ0I7QUFBQSxNQUNoQix1QkFBdUI7QUFBQSxJQUN6QjtBQUFBLEVBQ0YsQ0FBQztBQUNIOzs7QURyQkEsSUFBTUMsVUFBUUMsUUFBTSxvQkFBb0I7QUFPeEMsZUFBc0IsZ0JBQWdCO0FBQUEsRUFDcEM7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFDRixHQUFvQjtBQUdsQixFQUFBRCxRQUFNLDJCQUEyQjtBQUFBLElBQy9CO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsRUFDRixDQUFDO0FBRUQsUUFBTSxnQkFBZ0IsWUFBWSxJQUFJLEtBQUssWUFBWTtBQUN2RCxNQUFJLGlCQUFpQixHQUFHO0FBRXRCO0FBQUEsRUFDRjtBQUdBLE1BQUksa0JBQWtCLFdBQVc7QUFDL0IsVUFBTTtBQUFBLE1BQ0o7QUFBQSxNQUNBLENBQUMsTUFBTUEsUUFBTSx3Q0FBd0MsV0FBVyxDQUFDO0FBQUEsTUFDakUsTUFBTUEsUUFBTSxxQkFBcUIsU0FBUztBQUFBLElBQzVDLEVBQUUsV0FBVyxjQUFjO0FBQUEsRUFDN0I7QUFFQSxNQUFJLHdCQUF3QixxQkFBcUIsUUFBUTtBQUN2RCxVQUFNLFFBQVE7QUFBQSxNQUNaLFlBQVksSUFBSSxDQUFDLGVBQWU7QUFDOUIsY0FBTSxNQUFNLHFCQUFxQjtBQUFBLFVBQy9CLENBQUMsU0FBUyxLQUFLLGlCQUFpQixXQUFXO0FBQUEsUUFDN0MsR0FBRztBQUNILFlBQUksQ0FBQyxLQUFLO0FBQ1IsVUFBQUE7QUFBQSxZQUNFO0FBQUEsWUFDQTtBQUFBLFlBQ0E7QUFBQSxVQUNGO0FBQ0EsZUFBSyw2Q0FBNkMsV0FBVyxJQUFJO0FBQ2pFLGlCQUFPLFFBQVEsUUFBUTtBQUFBLFFBQ3pCO0FBQ0EsZUFBTztBQUFBLFVBQ0w7QUFBQSxVQUNBLENBQUMsTUFDQ0E7QUFBQSxZQUNFO0FBQUEsWUFDQSxXQUFXO0FBQUEsWUFDWDtBQUFBLFVBQ0Y7QUFBQSxVQUNGLE1BQU1BLFFBQU0scUJBQXFCLFdBQVcsSUFBSTtBQUFBLFFBQ2xELEVBQUUsV0FBVyxNQUFNLEdBQUc7QUFBQSxNQUN4QixDQUFDO0FBQUEsSUFDSDtBQUFBLEVBQ0Y7QUFDRjtBQUVPLElBQU0sbUJBQW1CO0FBQUEsRUFDOUI7QUFBQSxFQUNBLE1BQU07QUFBQSxFQUFDO0FBQUEsRUFDUCxNQUFNO0FBQUEsRUFBQztBQUNUOzs7QUV4RUEsSUFBTSxRQUF3QjtBQUFBLEVBQzVCLG9CQUFvQjtBQUN0QjtBQUVPLElBQU0sd0JBQXdCLENBQUMsV0FBbUI7QUFDdkQsTUFBSSxNQUFNLG9CQUFvQjtBQUM1QjtBQUFBLEVBQ0Y7QUFDQSxRQUFNLHFCQUFxQjtBQUMzQixTQUFPLHlDQUEwQixNQUFNO0FBQ3pDOzs7QUhGQSxJQUFNRSxVQUFRQyxRQUFNLGtCQUFrQjtBQUV0QyxlQUFzQixxQkFDcEIsWUFDQSxTQUNBQyxTQUNBO0FBQ0EsUUFBTUMsT0FBTSxRQUFRLEtBQUssQ0FBQztBQUMxQixNQUFJLENBQUNBLE1BQUs7QUFDUixVQUFNLElBQUksTUFBTSxpQ0FBaUM7QUFBQSxFQUNuRDtBQUNBLFFBQU0sa0JBQWtCLHlCQUF5QkEsSUFBRztBQUNwRCxRQUFNLGdCQUFnQix3QkFBd0JBLE1BQUssUUFBUSxNQUFNO0FBRWpFLFFBQU0sRUFBRSxnQkFBZ0Isc0JBQXNCLE1BQU0sSUFBSSxNQUFNO0FBQUEsSUFDNUQ7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLEVBQ0Y7QUFFQSxNQUFJLE9BQU8sY0FBYztBQUN2QixJQUFBSCxRQUFNLDZCQUE2QixVQUFVO0FBQzdDLDBCQUFzQixNQUFNLFlBQVk7QUFBQSxFQUMxQztBQUVBLEVBQUFBLFFBQU0sK0NBQStDLFlBQVk7QUFBQSxJQUMvRDtBQUFBLElBQ0E7QUFBQSxFQUNGLENBQUM7QUFFRCxTQUFPLFFBQVEsSUFBSTtBQUFBLElBQ2pCLGdCQUFnQjtBQUFBLE1BQ2Q7QUFBQSxNQUNBLFdBQVdHLEtBQUk7QUFBQSxNQUNmO0FBQUEsTUFDQSxhQUFhLGdCQUFnQjtBQUFBLElBQy9CLENBQUM7QUFBQSxJQUNELGlCQUFpQixZQUFZLGlCQUFpQixJQUFJRCxPQUFNO0FBQUEsRUFDMUQsQ0FBQztBQUNIO0FBRUEsZUFBZSxjQUNiLFlBQ0EsZUFDQSxpQkFDQTtBQUNBLEVBQUFGLFFBQU0sb0NBQW9DLFVBQVU7QUFDcEQsTUFBSSxXQUFXLEdBQUc7QUFDaEIsV0FBTyw0QkFBNEIsWUFBWTtBQUFBLE1BQzdDLE9BQU87QUFBQSxNQUNQLFNBQVM7QUFBQSxJQUNYLENBQUM7QUFBQSxFQUNIO0FBR0EsUUFBTSxpQkFBaUIsWUFBWSxhQUFhO0FBQ2hELFNBQU8sc0JBQXNCLFlBQVksZUFBZTtBQUMxRDs7O0FJOURBLE9BQU9JLGFBQVc7OztBQ1BsQixPQUFPQyxhQUFXO0FBS2xCLElBQU1DLFVBQVFDLFFBQU0scUJBQXFCO0FBRWxDLElBQU0sY0FBOEIsQ0FBQztBQUVyQyxJQUFNLG1CQUFtQixDQUM5QixhQUNBLGdCQUNBLGVBQ0c7QUFDSCxRQUFNLFdBQVcsZUFBZSxZQUFZLFVBQVU7QUFDdEQsTUFBSSxDQUFDLFVBQVU7QUFDYixVQUFNLCtDQUErQyxVQUFVO0FBQy9EO0FBQUEsRUFDRjtBQUNBLE1BQUksU0FBUyxpQkFBaUI7QUFDNUIsSUFBQUQsUUFBTSwrQ0FBK0MsVUFBVTtBQUMvRDtBQUFBLEVBQ0Y7QUFFQSxXQUFTLGtCQUFrQixvQkFBSSxLQUFLO0FBRXBDLEVBQUFBLFFBQU0sMENBQTBDLFVBQVU7QUFDMUQsY0FBWTtBQUFBLElBQ1Y7QUFBQSxNQUNFO0FBQUEsTUFDQSxlQUFlLG1CQUFtQixhQUFhLFVBQVU7QUFBQSxNQUN6RCxTQUFTLFVBQVU7QUFBQSxJQUNyQixFQUFFLE1BQU0sS0FBSztBQUFBLEVBQ2Y7QUFDRjtBQUVPLElBQU0sdUJBQXVCLENBQ2xDLGFBQ0EsZ0JBQ0EsU0FDRztBQUNILFFBQU0sSUFBSSxlQUFlLFFBQVEsSUFBSTtBQUNyQyxNQUFJLENBQUMsR0FBRztBQUNOLFVBQU0sMkNBQTJDLElBQUk7QUFDckQ7QUFBQSxFQUNGO0FBQ0EsRUFBQUEsUUFBTSxvQ0FBb0MsSUFBSTtBQUM5QyxTQUFPLGlCQUFpQixhQUFhLGdCQUFnQixFQUFFLFVBQVU7QUFDbkU7OztBRDNCQSxJQUFNRSxVQUFRQyxRQUFNLGlCQUFpQjtBQUVyQyxlQUFzQixZQUNwQixnQkFDQSxhQUNBO0FBQUEsRUFDRTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQSxVQUFBQztBQUFBLEVBQ0EsT0FBTztBQUNULEdBR0EsUUFDQTtBQUNBLE1BQUksVUFBVTtBQUVkLFNBQU8sU0FBUztBQUNkLFVBQU0sV0FBVyxNQUFNLFNBQVMsZ0JBQWdCLGFBQWE7QUFBQSxNQUMzRCxTQUFTO0FBQUEsUUFDUDtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQSxVQUFBQTtBQUFBLE1BQ0Y7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLElBQ0YsQ0FBQztBQUNELFFBQUksQ0FBQyxTQUFTLFFBQVE7QUFDcEIsTUFBQUYsUUFBTSwyQ0FBMkMsWUFBWSxNQUFNO0FBQ25FLGdCQUFVO0FBQ1Y7QUFBQSxJQUNGO0FBQ0EsYUFBUztBQUFBLE1BQVEsQ0FBQyxNQUNoQixpQkFBaUIsYUFBYSxnQkFBZ0IsRUFBRSxVQUFVO0FBQUEsSUFDNUQ7QUFBQSxFQUNGO0FBQ0Y7QUFFQSxlQUFlLFNBQ2IsZ0JBQ0EsYUFDQTtBQUFBLEVBQ0U7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUNGLEdBVUE7QUFDQSxNQUFJLFFBQVE7QUFBQSxJQUNWLE9BQU8sQ0FBQztBQUFBLElBQ1Isa0JBQWtCO0FBQUEsSUFDbEIsZ0JBQWdCO0FBQUEsRUFDbEI7QUFFQSxNQUFJLFdBQVcsR0FBRztBQUNoQixJQUFBQSxRQUFNLDZCQUE2QixPQUFPLFNBQVM7QUFDbkQsWUFBUSxNQUFNLHVCQUF1QjtBQUFBLE1BQ25DLEdBQUc7QUFBQSxNQUNILFdBQVcsT0FBTztBQUFBLElBQ3BCLENBQUM7QUFDRCxJQUFBQSxRQUFNLHlCQUF5QixLQUFLO0FBQUEsRUFDdEMsT0FBTztBQUNMLFVBQU0sV0FBVyxNQUFNLGVBQWUsT0FBTztBQUU3QyxRQUFJLFNBQVMsU0FBUyxRQUFRLFNBQVMsZUFBZSxNQUFNO0FBQzFELFlBQU0sTUFBTSxLQUFLO0FBQUEsUUFDZixNQUFNLFNBQVM7QUFBQSxRQUNmLFlBQVksU0FBUztBQUFBLE1BQ3ZCLENBQUM7QUFBQSxJQUNIO0FBQ0EsVUFBTSxtQkFBbUIsU0FBUztBQUNsQyxVQUFNLGlCQUFpQixTQUFTO0FBQUEsRUFDbEM7QUFFQSxNQUFJLE1BQU0sTUFBTSxXQUFXLEdBQUc7QUFDNUIsV0FBTyxDQUFDO0FBQUEsRUFDVjtBQW1CQSxRQUFNLE1BQU0sUUFBUSxDQUFDLE1BQU0sZUFBZSxhQUFhLENBQUMsQ0FBQztBQUV6RCxVQUFRO0FBQ1I7QUFBQSxJQUNFO0FBQUEsSUFDQSxNQUFNLE1BQU0sSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLEVBQUUsS0FBSyxJQUFJO0FBQUEsSUFDeEMsTUFBTTtBQUFBLElBQ04sTUFBTTtBQUFBLEVBQ1I7QUFFQSxRQUFNLFlBQVksTUFBTTtBQUFBLElBQ3RCO0FBQUE7QUFBQTtBQUFBLE1BR0UsTUFBTSxNQUFNLE1BQ1QsSUFBSSxDQUFDLE9BQU8sb0JBQW9CLFVBQVUsR0FBRyxJQUFJLENBQUMsRUFDbEQsS0FBSyxHQUFHO0FBQUEsSUFDYjtBQUFBLElBQ0E7QUFBQSxFQUNGO0FBRUEsUUFBTSxRQUFRLGtEQUFrRDtBQUVoRSxRQUFNLFNBQVMsa0JBQWtCO0FBR2pDLFFBQU0sTUFBTSxRQUFRLENBQUMsU0FBUztBQUM1QixtQkFBZSxrQkFBa0IsS0FBSyxZQUFZLE1BQU07QUFDeEQsVUFBTSxnQkFBZ0IsMkJBQTJCLEtBQUssTUFBTSxTQUFTO0FBQ3JFLFFBQUksQ0FBQyxlQUFlO0FBQ2xCO0FBQUEsSUFDRjtBQUNBLG1CQUFlO0FBQUEsTUFDYjtBQUFBLE1BQ0EsS0FBSztBQUFBLE1BQ0w7QUFBQSxJQUNGO0FBQUEsRUFDRixDQUFDO0FBRUQsZUFBYTtBQUViLFNBQU8sTUFBTTtBQUNmO0FBRUEsU0FBUyxvQkFDUCxVQUNBLFVBQ0E7QUFDQSxRQUFNLGVBQWUsU0FBUyxLQUFLLENBQUMsTUFBTSxFQUFFLGFBQWEsUUFBUSxHQUFHO0FBQ3BFLE1BQUksQ0FBQyxjQUFjO0FBQ2pCO0FBQUEsTUFDRTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsSUFDRjtBQUNBLFVBQU0sSUFBSSxNQUFNLG9DQUFvQztBQUFBLEVBQ3REO0FBQ0EsU0FBTztBQUNUOzs7QUVwTEEsSUFBSSxjQUVPO0FBRVgsU0FBUyxlQUFlLFFBQWdCO0FBQ3RDO0FBQUEsSUFDRTtBQUFBLElBQ0E7QUFBQSxFQUNGO0FBQ0EsZUFBYSxPQUFPO0FBQ3RCO0FBQ0EsZUFBc0IsMEJBQ2pCLE1BQ0g7QUFDQSxTQUFPLElBQUksUUFBUSxDQUFDLFVBQVUsWUFBWTtBQUN4QyxrQkFBYyxJQUFJLFNBQVMsQ0FBQyxTQUFTLFFBQVEsYUFBYTtBQUN4RCxVQUFJLENBQUMsVUFBVTtBQUNiLGdCQUFRLElBQUksTUFBTSxrREFBa0QsQ0FBQztBQUNyRTtBQUFBLE1BQ0Y7QUFDQSxlQUFTLE1BQU0sU0FBUyxNQUFNLENBQUM7QUFDL0Isa0JBQVksR0FBRyxJQUFJLEVBQUU7QUFBQSxRQUNuQixNQUFNO0FBQ0osa0JBQVE7QUFDUixtQkFBUyxNQUFNO0FBQUEsUUFDakI7QUFBQSxRQUNBLENBQUNHLFdBQVU7QUFDVCxpQkFBTztBQUNQLGtCQUFRQSxNQUFLO0FBQUEsUUFDZjtBQUFBLE1BQ0Y7QUFBQSxJQUNGLENBQUM7QUFFRCxXQUFPLGdEQUFpQyxjQUFjO0FBQUEsRUFDeEQsQ0FBQyxFQUFFLFFBQVEsTUFBTTtBQUNmLFdBQU8sbURBQW9DLGNBQWM7QUFBQSxFQUMzRCxDQUFDO0FBQ0g7OztBQ3hDQSxlQUFzQixXQUFXO0FBQy9CLFFBQU0sUUFBUTtBQUNoQjs7O0FDeUJBLE9BQU9DLGFBQVc7QUFDbEIsT0FBT0MsV0FBVTtBQUVqQixPQUFPLHNCQUFzQjtBQUM3QixPQUFPLFlBQStCO0FBQ3RDLE9BQU9DLFNBQU87QUFDZCxPQUFPLFFBQVE7OztBQ25DZixPQUFPQyxXQUFVO0FBRVYsU0FBUyxRQUFRLEtBQXlCO0FBQy9DLFNBQU8sTUFBTyxPQUFPLFFBQVEsV0FBVyxDQUFDLEdBQUcsSUFBSSxNQUFPLENBQUM7QUFDMUQ7QUFFTyxTQUFTLFFBQVFDLE9BQWMsTUFBY0QsTUFBSyxLQUFLO0FBQzVELFNBQU9DLE1BQUssTUFBTSxHQUFHLEVBQUUsS0FBS0QsTUFBSyxNQUFNLEdBQUc7QUFDNUM7OztBRG9DQSxJQUFNRSxVQUFRQyxRQUFNLGdCQUFnQjtBQVNwQyxlQUFzQixVQUFVO0FBQUEsRUFDOUI7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUNGLEdBQWtFO0FBQ2hFLHNCQUFvQixRQUFRLGlCQUFpQjtBQUM3QyxnQkFBYyxRQUFRLFdBQVc7QUFDakMsdUJBQXFCLFFBQVEsa0JBQWtCLEtBQUssQ0FBQztBQUdyRCw0QkFBMEIsUUFBUSx1QkFBdUIsS0FBSyxDQUFDO0FBRS9ELEVBQUFELFFBQU0seUNBQXlDO0FBQUEsSUFDN0M7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLEVBQ0YsQ0FBQztBQUVELE1BQUksQ0FBQyxlQUFlLENBQUMsbUJBQW1CO0FBQ3RDLFVBQU0sTUFBTSxrREFBa0Q7QUFBQSxFQUNoRTtBQUVBLE1BQUksb0JBQW9CLE1BQU0sZUFBZSxhQUFhLGFBQWE7QUFBQSxJQUNyRSxVQUFVO0FBQUEsSUFDVixRQUFRLENBQUMsR0FBRyxvQkFBb0IsR0FBRyx1QkFBdUI7QUFBQSxFQUM1RCxDQUFDO0FBYUQsTUFBSSxDQUFDRSxJQUFFLFFBQVEsYUFBYSxpQkFBaUIsR0FBRztBQUM5QyxVQUFNLDJCQUEyQixNQUFNO0FBQUEsTUFDckM7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLFFBQ0UsVUFBVTtBQUFBLFFBQ1YsUUFBUSxDQUFDLEdBQUcsb0JBQW9CLEdBQUcsdUJBQXVCO0FBQUEsTUFDNUQ7QUFBQSxJQUNGO0FBRUEsd0JBQW9CQSxJQUFFO0FBQUEsTUFDcEI7QUFBQSxNQUNBO0FBQUEsSUFDRjtBQUFBLEVBQ0Y7QUFFQSxTQUFPLGFBQWE7QUFBQSxJQUNsQjtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLEVBQ0YsQ0FBQztBQUNIO0FBRUEsZUFBZSxlQUNiLGFBQ0EsTUFDQSxhQUNBO0FBQ0EsUUFBTSx5QkFBeUJDLE1BQUssS0FBSyxhQUFhQSxNQUFLLEdBQUc7QUFDOUQsUUFBTSxRQUFTLENBQUMsRUFDYixPQUFPLElBQUksRUFDWDtBQUFBLElBQUksQ0FBQyxnQkFDSixZQUFZLFdBQVcsSUFBSSxJQUFJLFlBQVksUUFBUSxNQUFNLEVBQUUsSUFBSTtBQUFBLEVBQ2pFLEVBQ0MsSUFBSSxDQUFDLGdCQUFnQjtBQUtwQixRQUFJLFlBQVksV0FBVyxzQkFBc0IsR0FBRztBQUNsRCxhQUFPLFlBQVksUUFBUSx3QkFBd0IsRUFBRTtBQUFBLElBQ3ZEO0FBRUEsV0FBTztBQUFBLEVBQ1QsQ0FBQztBQUVILE1BQUksR0FBRyxTQUFTLE1BQU0sU0FBUztBQUc3QixJQUFBSCxRQUFNLGlDQUFpQztBQUN2QyxlQUFXLEtBQUssT0FBTztBQUNyQixZQUFNLE1BQU0sTUFBTSxDQUFDO0FBRW5CLFVBQUksQ0FBQztBQUFLLGNBQU0sSUFBSSxNQUFNLHlCQUF5QjtBQUVuRCxZQUFNLENBQUMsSUFBSSxRQUFRLEdBQUc7QUFBQSxJQUN4QjtBQUFBLEVBQ0Y7QUFFQSxNQUFJO0FBQ0YsSUFBQUEsUUFBTSwyQkFBMkIsS0FBSztBQUN0QyxJQUFBQSxRQUFNLHdCQUF3QixXQUFXO0FBRXpDLFdBQU8sV0FBVyxPQUFPO0FBQUEsTUFDdkIsV0FBVztBQUFBLE1BQ1gsVUFBVTtBQUFBLE1BQ1YsS0FBSztBQUFBLE1BQ0wsR0FBRztBQUFBLE1BQ0gsU0FBUyxhQUFhLFVBQVUsQ0FBQyxHQUFHLE9BQU8sb0JBQW9CO0FBQUEsSUFDakUsQ0FBQztBQUFBLEVBQ0gsU0FBUyxHQUFQO0FBQ0EsSUFBQUEsUUFBTSw4QkFBOEIsQ0FBQztBQUNyQyxXQUFPLENBQUM7QUFBQSxFQUNWO0FBQ0Y7QUFFQSxJQUFNLGFBQWEsT0FBTyxPQUFvQixrQkFBaUM7QUFDN0UsU0FBTyxNQUFNLE9BQU8sT0FBTyxhQUFhO0FBQzFDO0FBU0EsU0FBUyxhQUFhO0FBQUEsRUFDcEI7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUNGLEdBQWlCO0FBQ2YsRUFBQUEsUUFBTSxrQkFBa0IsaUJBQWlCO0FBRXpDLE1BQUksYUFBYTtBQUVqQixNQUFJLGtCQUFrQixXQUFXLEdBQUc7QUFDbEMsaUJBQWFHLE1BQUssUUFBUSxrQkFBa0IsQ0FBQyxDQUFDO0FBQUEsRUFDaEQsT0FBTztBQUNMLGlCQUFhLGlCQUFpQixpQkFBaUI7QUFBQSxFQUNqRDtBQUVBLFNBQU8sa0JBQWtCO0FBQUEsSUFBSSxDQUFDLGFBQzVCLGNBQWM7QUFBQSxNQUNaO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQSxVQUFVLEdBQUcsU0FBUztBQUFBLE1BQ3RCLEtBQUtBLE1BQUs7QUFBQSxJQUNaLENBQUM7QUFBQSxFQUNIO0FBQ0Y7QUFXQSxTQUFTLGNBQWM7QUFBQSxFQUNyQjtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0EsVUFBQUM7QUFBQSxFQUNBO0FBQ0YsR0FBa0I7QUFDaEIsTUFBSUEsY0FBYSxTQUFTO0FBQ3hCLGVBQVcsUUFBUSxVQUFVLEdBQUc7QUFDaEMsa0JBQWMsUUFBUSxhQUFhLEdBQUc7QUFBQSxFQUN4QztBQUVBLFFBQU0sV0FBV0QsTUFBSyxTQUFTLGFBQWEsUUFBUTtBQUNwRCxRQUFNLGFBQWFBLE1BQUssTUFBTSxRQUFRO0FBQ3RDLFFBQU0sZ0JBQWdCQSxNQUFLLFFBQVEsUUFBUTtBQUUzQyxRQUFNLG9CQUNKLENBQUMsU0FBUyxTQUFTLFNBQVMsU0FBUyxLQUFLLEVBQ3ZDLElBQUksQ0FBQyxRQUFRLE1BQU0sYUFBYSxFQUNoQyxLQUFLLENBQUMsUUFBUSxTQUFTLFNBQVMsR0FBRyxDQUFDLEtBQUs7QUFFOUMsUUFBTSxRQUFRLFNBQVMsTUFBTSxXQUFXO0FBQ3hDLE1BQUksT0FBTyxNQUFNLE1BQU0sU0FBUyxDQUFDLEtBQUs7QUFFdEMsTUFBSSxLQUFLLFdBQVcsR0FBRyxHQUFHO0FBQ3hCLFdBQU8sS0FBSyxNQUFNLENBQUM7QUFBQSxFQUNyQjtBQUVBLFFBQU0sZ0JBQWdCO0FBQ3RCLFFBQU0sdUJBQXVCLFNBQzFCLFFBQVEsWUFBWSxFQUFFLEVBQ3RCLFFBQVEsZUFBZSxFQUFFO0FBRTVCLFNBQU87QUFBQSxJQUNMO0FBQUEsSUFDQSxVQUFVLFdBQVc7QUFBQSxJQUNyQixVQUFVLFdBQVcsS0FBSyxRQUFRLG1CQUFtQixFQUFFO0FBQUEsSUFDdkQ7QUFBQSxJQUNBO0FBQUEsSUFDQSxVQUFXLGdCQUFnQixjQUN2QixjQUNBO0FBQUEsSUFDSjtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsRUFDRjtBQUNGOzs7QUVwUU8sSUFBTSxlQUFlLE9BQU87QUFBQSxFQUNqQztBQUFBLEVBQ0E7QUFDRixNQUdNO0FBQ0osUUFBTSxjQUFjLGVBQWUsT0FBTyxhQUFhLE9BQU8sSUFBSTtBQUVsRSxRQUFNLFFBQVEsTUFBTSxVQUFVO0FBQUE7QUFBQSxJQUU1QixhQUFhLE9BQU8sV0FBVyxPQUFPO0FBQUEsSUFDdEMsYUFBYSxPQUFPO0FBQUEsSUFDcEI7QUFBQSxJQUNBLG1CQUFtQixPQUFPO0FBQUEsSUFDMUIsb0JBQW9CLE9BQU87QUFBQSxJQUMzQix5QkFBeUIsT0FBTztBQUFBLEVBQ2xDLENBQUM7QUFDRCxNQUFJLE1BQU0sV0FBVyxHQUFHO0FBQ3RCO0FBQUEsTUFDRTtBQUFBLE1BQ0E7QUFBQSxRQUNFLGFBQWEsT0FBTztBQUFBLFFBQ3BCO0FBQUEsUUFDQSxtQkFBbUIsT0FBTztBQUFBLFFBQzFCLG9CQUFvQjtBQUFBLFVBQ2xCLE9BQU87QUFBQSxVQUNQLE9BQU87QUFBQSxRQUNULEVBQUUsS0FBSyxDQUFDO0FBQUEsUUFDUixhQUFhLE9BQU87QUFBQSxNQUN0QjtBQUFBLElBQ0Y7QUFBQSxFQUNGO0FBQ0EsU0FBTyxFQUFFLE9BQU8sWUFBWTtBQUM5QjtBQUVBLFNBQVMsZUFDUCxlQUNBLFVBQ0E7QUFDQSxTQUFPLFlBQVk7QUFDckI7OztBQ2pETyxJQUFNLGNBQU4sTUFBa0I7QUFBQSxFQUFsQjtBQUNMLFNBQVEsVUFBcUQ7QUFBQTtBQUFBLEVBQ3RELFVBQVUsR0FBd0I7QUFDdkMsU0FBSyxVQUFVO0FBQUEsRUFDakI7QUFBQSxFQUNPLFlBQVk7QUFDakIsV0FBTyxLQUFLO0FBQUEsRUFDZDtBQUNGOzs7QUNHQSxTQUFTLGNBQWMsR0FBNEM7QUFDakUsU0FBTztBQUFBLElBQ0wsR0FBRztBQUFBLElBQ0gsTUFBTSxFQUFFLFFBQVE7QUFBQSxFQUNsQjtBQUNGO0FBRUEsU0FBU0UsZ0JBQ1AsU0FDQSxhQUNvQjtBQUNwQixTQUFPO0FBQUEsSUFDTCxHQUFHO0FBQUEsSUFDSCxXQUFXLFFBQVE7QUFBQSxJQUNuQixVQUFVLFFBQVE7QUFBQSxJQUNsQixhQUFhLFlBQVksSUFBSSxhQUFhO0FBQUEsRUFDNUM7QUFDRjtBQUVBLFNBQVMsUUFDUCxHQUNBLGFBQ2E7QUFDYixRQUFNLGVBQWUsWUFBWSxPQUFPLENBQUMsTUFBTSxFQUFFLFdBQVcsRUFBRSxNQUFNO0FBQ3BFLFNBQU87QUFBQSxJQUNMLEdBQUc7QUFBQSxJQUNILFVBQVUsRUFBRSxTQUFTO0FBQUEsTUFBSSxDQUFDLEdBQUcsTUFDM0JBO0FBQUEsUUFDRTtBQUFBLFFBQ0EsYUFBYSxPQUFPLENBQUMsTUFBTSxFQUFFLHFCQUFxQixDQUFDO0FBQUEsTUFDckQ7QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUNGO0FBRU8sU0FBUyw0QkFDZCxhQUNBLGlCQUNxQztBQUNyQyxTQUFPO0FBQUEsSUFDTCxRQUFRO0FBQUE7QUFBQSxJQUVSLFFBQVEsWUFBWSxVQUFVO0FBQUEsSUFDOUIsZUFBZSxnQkFBZ0IsTUFBTTtBQUFBLElBQ3JDLGFBQWEsZ0JBQWdCLE1BQU07QUFBQSxJQUNuQyxZQUFZLGdCQUFnQixNQUFNO0FBQUEsSUFDbEMsYUFBYSxnQkFBZ0IsTUFBTTtBQUFBLElBQ25DLGFBQWEsZ0JBQWdCLE1BQU07QUFBQSxJQUNuQyxjQUFjLGdCQUFnQixNQUFNO0FBQUEsSUFDcEMsY0FBYyxnQkFBZ0IsTUFBTTtBQUFBLElBQ3BDLGdCQUFnQixnQkFBZ0IsTUFBTTtBQUFBLElBQ3RDLGNBQWMsZ0JBQWdCLE1BQU07QUFBQSxJQUNwQyxNQUFNO0FBQUEsTUFDSjtBQUFBLFFBQ0UsT0FBTztBQUFBLFVBQ0wsR0FBRyxnQkFBZ0I7QUFBQSxVQUNuQixXQUFXLGdCQUFnQixNQUFNO0FBQUEsVUFDakMsU0FBUyxnQkFBZ0IsTUFBTTtBQUFBLFVBQy9CLFVBQVUsZ0JBQWdCLE1BQU07QUFBQSxRQUNsQztBQUFBLFFBQ0EsVUFBVSxnQkFBZ0I7QUFBQSxRQUMxQixlQUFlLGdCQUFnQixpQkFBaUIsQ0FBQztBQUFBLFFBQ2pELE1BQU0sZ0JBQWdCO0FBQUEsUUFDdEIsT0FBTyxnQkFBZ0I7QUFBQSxRQUN2QixPQUFPLGdCQUFnQjtBQUFBLFFBQ3ZCLG1CQUFtQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsUUFJbkIsT0FBTyxnQkFBZ0I7QUFBQSxRQUN2QixRQUFRLGdCQUFnQixTQUFTLENBQUMsR0FBRztBQUFBLFVBQUksQ0FBQyxNQUN4QyxRQUFRLEdBQUcsZ0JBQWdCLFdBQVc7QUFBQSxRQUN4QztBQUFBLE1BQ0Y7QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUNGO0FBRU8sSUFBTSxvQkFBb0IsQ0FDL0IsV0FDRztBQUNILFNBQU87QUFBQSxJQUNMLEdBQUc7QUFBQSxJQUNILE1BQU0sT0FBTyxLQUFLLElBQUksb0JBQW9CO0FBQUEsRUFDNUM7QUFDRjtBQUVBLElBQU0sdUJBQXVCLENBQUNDLFNBQW9CO0FBQ2hELE1BQUksQ0FBQ0EsS0FBSSxPQUFPO0FBQ2QsV0FBT0E7QUFBQSxFQUNUO0FBRUEsU0FBTztBQUFBLElBQ0wsR0FBR0E7QUFBQSxJQUNILE9BQU8sQ0FBQyx5QkFBeUJBLEtBQUksT0FBT0EsS0FBSSxLQUFLLENBQUM7QUFBQSxFQUN4RDtBQUNGOzs7QUNsR0EsT0FBT0MsYUFBVztBQUVsQixJQUFNQyxVQUFRRCxRQUFNLGdCQUFnQjtBQWU3QixJQUFNLGlCQUFOLE1BQXFCO0FBQUEsRUFBckI7QUFDTCxTQUFRLFFBQW9ELENBQUM7QUFBQTtBQUFBLEVBRXRELFdBQVcsYUFBMEI7QUFDMUMsV0FBTyxPQUFPLE9BQU8sS0FBSyxLQUFLLEVBQUU7QUFBQSxNQUFJLENBQUMsTUFDcEMsS0FBSyxtQkFBbUIsYUFBYSxFQUFFLFVBQVU7QUFBQSxJQUNuRDtBQUFBLEVBQ0Y7QUFBQSxFQUVPLFlBQVksWUFBd0I7QUFDekMsV0FBTyxLQUFLLE1BQU0sVUFBVTtBQUFBLEVBQzlCO0FBQUEsRUFFTyxRQUFRLE1BQWM7QUFDM0IsV0FBTyxPQUFPLE9BQU8sS0FBSyxLQUFLLEVBQUUsS0FBSyxDQUFDLE1BQU0sRUFBRSxTQUFTLElBQUk7QUFBQSxFQUM5RDtBQUFBLEVBRU8sYUFBYTtBQUFBLElBQ2xCO0FBQUEsSUFDQTtBQUFBLEVBQ0YsR0FHRztBQUNELElBQUFDLFFBQU0saUNBQWlDLElBQUk7QUFDM0MsU0FBSyxNQUFNLFVBQVUsSUFBSTtBQUFBLE1BQ3ZCO0FBQUEsTUFDQTtBQUFBLE1BQ0EsV0FBVyxvQkFBSSxLQUFLO0FBQUEsSUFDdEI7QUFBQSxFQUNGO0FBQUEsRUFFTyxjQUFjLE1BQWM7QUFDakMsVUFBTSxJQUFJLEtBQUssUUFBUSxJQUFJO0FBQzNCLFFBQUksQ0FBQyxHQUFHO0FBQ04sV0FBSyw2Q0FBNkMsSUFBSTtBQUN0RDtBQUFBLElBQ0Y7QUFFQSxNQUFFLGFBQWEsb0JBQUksS0FBSztBQUFBLEVBQzFCO0FBQUEsRUFFTyxhQUFhLE1BQWMsU0FBcUI7QUFDckQsVUFBTSxJQUFJLEtBQUssUUFBUSxJQUFJO0FBQzNCLFFBQUksQ0FBQyxHQUFHO0FBQ04sV0FBSyw2Q0FBNkMsSUFBSTtBQUN0RDtBQUFBLElBQ0Y7QUFDQSxNQUFFLFlBQVksb0JBQUksS0FBSztBQUN2QixNQUFFLG1CQUFtQjtBQUFBLEVBQ3ZCO0FBQUEsRUFFTyxjQUFjLE1BQWMsUUFBZ0I7QUFDakQsVUFBTSxJQUFJLEtBQUssUUFBUSxJQUFJO0FBQzNCLFFBQUksQ0FBQyxHQUFHO0FBQ04sV0FBSyw2Q0FBNkMsSUFBSTtBQUN0RDtBQUFBLElBQ0Y7QUFDQSxTQUFLLGtCQUFrQixFQUFFLFlBQVksTUFBTTtBQUFBLEVBQzdDO0FBQUEsRUFFTyxrQkFBa0IsWUFBb0IsUUFBZ0I7QUFDM0QsVUFBTSxJQUFJLEtBQUssTUFBTSxVQUFVO0FBQy9CLFFBQUksQ0FBQyxHQUFHO0FBQ04sV0FBSyxpREFBaUQsVUFBVTtBQUNoRTtBQUFBLElBQ0Y7QUFDQSxRQUFJLEVBQUUsUUFBUTtBQUNaLE1BQUFBLFFBQU0sb0NBQW9DLFVBQVU7QUFDcEQ7QUFBQSxJQUNGO0FBQ0EsTUFBRSxTQUFTO0FBQUEsRUFDYjtBQUFBLEVBRU8sa0JBQ0wsYUFDQSxZQUNBLFNBQ0E7QUFDQSxVQUFNLElBQUksS0FBSyxNQUFNLFVBQVU7QUFDL0IsUUFBSSxDQUFDLEdBQUc7QUFDTixXQUFLLGlEQUFpRCxVQUFVO0FBQ2hFO0FBQUEsSUFDRjtBQUNBLE1BQUUsYUFBYTtBQUNmLE1BQUUsdUJBQXVCLG9CQUFJLEtBQUs7QUFBQSxFQUNwQztBQUFBLEVBRU8sbUJBQ0wsYUFDQSxZQUNxQztBQUNyQyxVQUFNLElBQUksS0FBSyxZQUFZLFVBQVU7QUFFckMsUUFBSSxDQUFDLEdBQUc7QUFDTixZQUFNLGlEQUFpRCxVQUFVO0FBRWpFLGFBQU8scUJBQXFCLGFBQWE7QUFBQSxRQUN2QyxPQUFPLENBQUMsU0FBUztBQUFBLFFBQ2pCLE9BQU87QUFBQSxNQUNULENBQUM7QUFBQSxJQUNIO0FBR0EsUUFBSSxFQUFFLGtCQUFrQjtBQUN0QixhQUFPO0FBQUEsUUFDTCw0QkFBNEIsYUFBYSxFQUFFLGdCQUFnQjtBQUFBLE1BQzdEO0FBQUEsSUFDRjtBQUVBLFFBQUksRUFBRSxZQUFZO0FBQ2hCLGFBQU8sa0JBQWtCLEVBQUUsVUFBVTtBQUFBLElBQ3ZDO0FBRUEsSUFBQUEsUUFBTSxnQ0FBZ0MsRUFBRSxJQUFJO0FBQzVDLFdBQU8scUJBQXFCLGFBQWE7QUFBQSxNQUN2QyxPQUFPLENBQUMsRUFBRSxJQUFJO0FBQUEsTUFDZCxPQUFPO0FBQUEsSUFDVCxDQUFDO0FBQUEsRUFDSDtBQUNGOzs7QTVCakhBLElBQU1DLFVBQVFDLFFBQU0sY0FBYztBQUVsQyxlQUFzQixJQUFJLFNBQWdDLENBQUMsR0FBRztBQUM1RCxRQUFNLGlCQUFpQixJQUFJLGVBQWU7QUFDMUMsUUFBTSxjQUFjLElBQUksWUFBWTtBQUNwQyxnQkFBYyxPQUFPLFVBQVU7QUFDL0IsRUFBQUQsUUFBTSxpQkFBaUIsTUFBTTtBQUM3QixXQUFTLGlCQUFpQixNQUFNO0FBQ2hDLEVBQUFBLFFBQU0sOEJBQThCLE1BQU07QUFFMUMsTUFBSSxVQUFVLE1BQU0sR0FBRztBQUNyQixTQUFLLCtEQUErRDtBQUNwRSxXQUFPLGVBQWUsTUFBTTtBQUFBLEVBQzlCO0FBRUEsUUFBTSxrQkFBa0IsTUFBTSxlQUFlLE1BQU07QUFDbkQsZ0JBQWMsZ0JBQWdCLGVBQWU7QUFFN0MsTUFBSSxDQUFDLFdBQVcsR0FBRztBQUNqQixZQUFRLElBQUksZUFBZSxDQUFDO0FBQUEsRUFDOUI7QUFFQSxRQUFNO0FBQUEsSUFDSjtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsRUFDRixJQUFJO0FBRUosUUFBTSxTQUFTLE1BQU0sZ0JBQWdCLGVBQWU7QUFDcEQsY0FBWSxVQUFVLFFBQVEsUUFBUTtBQUV0QyxRQUFNLEVBQUUsT0FBTyxZQUFZLElBQUksTUFBTSxhQUFhO0FBQUEsSUFDaEQ7QUFBQSxJQUNBLFFBQVE7QUFBQSxFQUNWLENBQUM7QUFFRCxNQUFJLE1BQU0sV0FBVyxHQUFHO0FBQ3RCO0FBQUEsRUFDRjtBQUVBLFFBQU1FLFlBQVcsTUFBTSxZQUFZO0FBQUEsSUFDakM7QUFBQSxJQUNBLFNBQVMsZ0JBQWdCO0FBQUEsRUFDM0IsQ0FBQztBQUVELE9BQUssNEJBQTRCLE1BQU0sTUFBTTtBQUM3QztBQUFBLElBQ0UsU0FBUyxJQUFJLFNBQVMsSUFBSSxJQUFJLEtBQUssR0FBRyxJQUFJLGlCQUN4QyxTQUFTLG9CQUNJLFlBQVksc0JBQXNCO0FBQUEsRUFDbkQ7QUFDQSxPQUFLLDhDQUE4QztBQUVuRCxRQUFNQyxPQUFNLE1BQU0sVUFBVTtBQUFBLElBQzFCLElBQUksTUFBTSxTQUFTO0FBQUEsSUFDbkIsT0FBTyxNQUFNLElBQUksQ0FBQyxTQUFTLEtBQUssUUFBUTtBQUFBLElBQ3hDLFFBQVEsTUFBTSxXQUFXLE9BQU8sV0FBVztBQUFBLElBQzNDO0FBQUEsSUFDQSxVQUFBRDtBQUFBLElBQ0EsVUFBVSxZQUFZO0FBQUEsSUFDdEI7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0EsYUFBYSxDQUFDLFdBQVcsRUFBRSxLQUFLLENBQUM7QUFBQSxJQUNqQyxNQUFNO0FBQUEsSUFDTjtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsRUFDRixDQUFDO0FBRUQsV0FBU0MsS0FBSSxLQUFLO0FBQ2xCLE9BQUssc0JBQWUsS0FBS0EsS0FBSSxNQUFNLENBQUM7QUFDcEMsbUJBQWlCO0FBRWpCLFFBQU0sU0FBUztBQUNmLHFCQUFtQixhQUFhLGNBQWM7QUFFOUMsUUFBTTtBQUFBLElBQ0o7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLE1BQ0UsT0FBT0EsS0FBSTtBQUFBLE1BQ1gsU0FBU0EsS0FBSTtBQUFBLE1BQ2IsV0FBV0EsS0FBSTtBQUFBLE1BQ2YsVUFBQUQ7QUFBQSxNQUNBO0FBQUEsSUFDRjtBQUFBLElBQ0E7QUFBQSxFQUNGO0FBRUEsVUFBUTtBQUVSLFFBQU0sUUFBUSxXQUFXLFdBQVc7QUFDcEMsUUFBTSxXQUFXO0FBQUEsSUFDZixlQUFlLFdBQVcsV0FBVztBQUFBLElBQ3JDO0FBQUEsRUFDRjtBQUVBLFFBQU0sU0FBUyxvQkFBb0I7QUFDbkMsVUFBUSxJQUFJLGFBQWEsUUFBUSxDQUFDO0FBQ2xDLE9BQUssMkJBQW9CLEtBQUtDLEtBQUksTUFBTSxDQUFDO0FBRXpDLFFBQU0sU0FBUztBQUVmLFNBQU87QUFDUCxNQUFJLFNBQVMsV0FBVyxZQUFZO0FBQ2xDLFdBQU87QUFBQSxNQUNMLEdBQUc7QUFBQSxNQUNILFFBQVFBLEtBQUk7QUFBQSxJQUNkO0FBQUEsRUFDRjtBQUVBLFNBQU87QUFDVDtBQUVBLFNBQVMsbUJBQ1AsYUFDQSxnQkFDQTtBQUNBLFNBQU8sR0FBRyxlQUFlLE9BQU8sRUFBRSxLQUFLLE1BQThCO0FBQ25FLElBQUFILFFBQU0sa0JBQWtCLElBQUk7QUFDNUIsbUJBQWUsY0FBYyxLQUFLLFFBQVE7QUFBQSxFQUM1QyxDQUFDO0FBRUQsU0FBTztBQUFBLElBQ0w7QUFBQSxJQUNBLE9BQU8sRUFBRSxNQUFNLFFBQVEsTUFBNEM7QUFDakUsTUFBQUEsUUFBTSxvQkFBb0IsTUFBTSxPQUFPO0FBQ3ZDLHFCQUFlLGFBQWEsS0FBSyxVQUFVLE9BQU87QUFDbEQscUJBQWUsY0FBYyxLQUFLLFVBQVUsa0JBQWtCLENBQUM7QUFDL0QsMkJBQXFCLGFBQWEsZ0JBQWdCLEtBQUssUUFBUTtBQUFBLElBQ2pFO0FBQUEsRUFDRjtBQUNGOzs7QWxCaEtPLFNBQVNJLEtBQUksUUFBeUI7QUFDM0MsU0FBTyxJQUFZLE1BQU07QUFDM0I7IiwKICAibmFtZXMiOiBbInJlcXVpcmUiLCAicHJvY2VzcyIsICJlcnJvciIsICJEZWJ1ZyIsICJkZWJ1ZyIsICJkZWJ1ZyIsICJsb2ciLCAiRGVidWciLCAiXyIsICJEZWJ1ZyIsICJQIiwgIm1hdGNoIiwgIkRlYnVnIiwgInBhdGgiLCAiRGVidWciLCAiZGVidWciLCAiRGVidWciLCAiZGVidWciLCAiRGVidWciLCAicmVxdWlyZSIsICJzdGRvdXQiLCAiXyIsICJkZWJ1ZyIsICJEZWJ1ZyIsICJtYXRjaCIsICJQIiwgIkRlYnVnIiwgIl8iLCAiZGVidWciLCAiRGVidWciLCAiXyIsICJfIiwgIl8iLCAiZGVidWciLCAiRGVidWciLCAiXyIsICJlcnJvciIsICJyZXF1aXJlIiwgIkRlYnVnIiwgIl8iLCAiXyIsICJwbGF0Zm9ybSIsICJzdGRvdXQiLCAiXyIsICJkZWJ1ZyIsICJfIiwgIl8iLCAiZGVidWciLCAiRGVidWciLCAiXyIsICJkZWJ1ZyIsICJEZWJ1ZyIsICJfIiwgImVycm9yIiwgImRlYnVnIiwgIm1hdGNoIiwgIlAiLCAibWF0Y2giLCAiUCIsICJkZWJ1ZyIsICJEZWJ1ZyIsICJkZWJ1ZyIsICJEZWJ1ZyIsICJEZWJ1ZyIsICJkZWJ1ZyIsICJEZWJ1ZyIsICJfIiwgImRlYnVnIiwgImVycm9yIiwgInJ1biIsICJfIiwgIl8iLCAiciIsICJEZWJ1ZyIsICJEZWJ1ZyIsICJEZWJ1ZyIsICJmcyIsICJmcyIsICJkZWJ1ZyIsICJEZWJ1ZyIsICJmaWxlIiwgImRlYnVnIiwgIkRlYnVnIiwgImRlYnVnIiwgIkRlYnVnIiwgInN0ZG91dCIsICJydW4iLCAiRGVidWciLCAiRGVidWciLCAiZGVidWciLCAiRGVidWciLCAiZGVidWciLCAiRGVidWciLCAicGxhdGZvcm0iLCAiZXJyb3IiLCAiRGVidWciLCAicGF0aCIsICJfIiwgInBhdGgiLCAiZmlsZSIsICJkZWJ1ZyIsICJEZWJ1ZyIsICJfIiwgInBhdGgiLCAicGxhdGZvcm0iLCAiZ2V0VGVzdEF0dGVtcHQiLCAicnVuIiwgIkRlYnVnIiwgImRlYnVnIiwgImRlYnVnIiwgIkRlYnVnIiwgInBsYXRmb3JtIiwgInJ1biIsICJydW4iXQp9Cg==