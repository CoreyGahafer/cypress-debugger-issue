{"version":3,"file":"index.js","mappings":"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","sources":["webpack://@neuralegion/cypress-har-generator/webpack/bootstrap","webpack://@neuralegion/cypress-har-generator/webpack/runtime/compat get default export","webpack://@neuralegion/cypress-har-generator/webpack/runtime/define property getters","webpack://@neuralegion/cypress-har-generator/webpack/runtime/hasOwnProperty shorthand","webpack://@neuralegion/cypress-har-generator/webpack/runtime/make namespace object","webpack://@neuralegion/cypress-har-generator/external commonjs \"tslib\"","webpack://@neuralegion/cypress-har-generator/./src/network/EntryBuilder.ts","webpack://@neuralegion/cypress-har-generator/./src/utils/ErrorUtils.ts","webpack://@neuralegion/cypress-har-generator/external node-commonjs \"os\"","webpack://@neuralegion/cypress-har-generator/external node-commonjs \"util\"","webpack://@neuralegion/cypress-har-generator/./src/network/DefaultHarExporter.ts","webpack://@neuralegion/cypress-har-generator/external node-commonjs \"path\"","webpack://@neuralegion/cypress-har-generator/./src/network/NetworkCookie.ts","webpack://@neuralegion/cypress-har-generator/./src/network/NetworkRequest.ts","webpack://@neuralegion/cypress-har-generator/./src/network/CookieParser.ts","webpack://@neuralegion/cypress-har-generator/./src/utils/StringUtils.ts","webpack://@neuralegion/cypress-har-generator/./src/network/ExtraInfoBuilder.ts","webpack://@neuralegion/cypress-har-generator/./src/network/NetworkObserver.ts","webpack://@neuralegion/cypress-har-generator/./src/network/filters/HostFilter.ts","webpack://@neuralegion/cypress-har-generator/./src/network/filters/PathFilter.ts","webpack://@neuralegion/cypress-har-generator/./src/network/filters/MimeFilter.ts","webpack://@neuralegion/cypress-har-generator/./src/network/filters/MinStatusCodeFilter.ts","webpack://@neuralegion/cypress-har-generator/./src/network/filters/BlobFilter.ts","webpack://@neuralegion/cypress-har-generator/./src/network/filters/StatusCodeFilter.ts","webpack://@neuralegion/cypress-har-generator/./src/network/filters/CompositeFilter.ts","webpack://@neuralegion/cypress-har-generator/./src/network/HarBuilder.ts","webpack://@neuralegion/cypress-har-generator/./src/network/NetworkIdleMonitor.ts","webpack://@neuralegion/cypress-har-generator/./src/constants.ts","webpack://@neuralegion/cypress-har-generator/external commonjs \"chalk\"","webpack://@neuralegion/cypress-har-generator/./src/utils/Logger.ts","webpack://@neuralegion/cypress-har-generator/external node-commonjs \"fs\"","webpack://@neuralegion/cypress-har-generator/external node-commonjs \"crypto\"","webpack://@neuralegion/cypress-har-generator/./src/utils/FileManager.ts","webpack://@neuralegion/cypress-har-generator/./src/cdp/messages.ts","webpack://@neuralegion/cypress-har-generator/./src/cdp/DefaultNetwork.ts","webpack://@neuralegion/cypress-har-generator/external commonjs \"chrome-remote-interface\"","webpack://@neuralegion/cypress-har-generator/./src/cdp/CDPConnection.ts","webpack://@neuralegion/cypress-har-generator/./src/cdp/RetryStrategy.ts","webpack://@neuralegion/cypress-har-generator/./src/index.ts","webpack://@neuralegion/cypress-har-generator/./src/Plugin.ts","webpack://@neuralegion/cypress-har-generator/./src/cdp/DefaultConnectionFactory.ts","webpack://@neuralegion/cypress-har-generator/./src/network/DefaultObserverFactory.ts","webpack://@neuralegion/cypress-har-generator/./src/network/DefaultHarExporterFactory.ts","webpack://@neuralegion/cypress-har-generator/./src/utils/Loader.ts"],"sourcesContent":["// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"tslib\");","import { NetworkRequest } from './NetworkRequest';\nimport { NetworkCookie } from './NetworkCookie';\nimport type { ContentData } from './NetworkRequest';\nimport type {\n  Content,\n  Cookie,\n  Entry,\n  Param,\n  PostData,\n  Request,\n  Response,\n  Timings\n} from 'har-format';\n\nexport class EntryBuilder {\n  constructor(private readonly request: NetworkRequest) {}\n\n  public async build(): Promise<Entry> {\n    let serverIPAddress: string = this.request.remoteAddress;\n\n    const portPositionInString: number = serverIPAddress.lastIndexOf(':');\n\n    if (portPositionInString !== -1) {\n      serverIPAddress = serverIPAddress.substr(0, portPositionInString);\n    }\n\n    const timings: Timings = this.buildTimings();\n\n    const time: number = Object.values(timings).reduce(\n      (acc: number, t: number): number => acc + Math.max(t, 0),\n      0\n    );\n\n    const entry: any = {\n      startedDateTime: new Date(\n        this.request.getWallTime(this.request.issueTime) * 1000\n      ).toJSON(),\n      time,\n      timings,\n      request: await this.buildRequest(),\n      response: await this.buildResponse(),\n      cache: {},\n      // ADHOC: We should remove square brackets for IPv6 address (https://tools.ietf.org/html/rfc2373#section-2.2).\n      serverIPAddress: serverIPAddress.replace(/[[\\]]/g, ''),\n      _priority: this.request.priority,\n      _resourceType: this.request.resourceType,\n      _webSocketMessages: this.request.frames ?? [],\n      _eventSourceMessages: this.request.eventSourceMessages ?? []\n    };\n\n    if (this.request.connectionId !== '0') {\n      entry.connection = this.request.connectionId;\n    }\n\n    return entry;\n  }\n\n  private getResponseBodySize(): number {\n    if (this.request.statusCode === 304) {\n      return 0;\n    }\n\n    if (!this.request.responseHeadersText) {\n      return -1;\n    }\n\n    return this.request.transferSize - this.request.responseHeadersText.length;\n  }\n\n  private getResponseCompression(): number | undefined {\n    if (this.request.statusCode === 304 || this.request.statusCode === 206) {\n      return undefined;\n    }\n    if (!this.request.responseHeadersText) {\n      return undefined;\n    }\n\n    return this.request.resourceSize - this.getResponseBodySize();\n  }\n\n  private toMilliseconds(time: number): number {\n    return time === -1 ? -1 : time * 1000;\n  }\n\n  private async buildRequest(): Promise<Request> {\n    const res: Request = {\n      method: this.request.requestMethod,\n      url: this.buildRequestURL(this.request.url),\n      httpVersion: this.request.requestHttpVersion,\n      headers: this.request.requestHeaders,\n      queryString: [...(this.request.queryParameters ?? [])],\n      cookies: this.buildCookies(this.request.requestCookies ?? []),\n      headersSize: this.request.requestHeadersText?.length ?? -1,\n      bodySize: await this.requestBodySize()\n    };\n\n    const postData: PostData | undefined = await this.buildPostData();\n\n    if (postData) {\n      res.postData = postData;\n    }\n\n    return res;\n  }\n\n  private async buildResponse(): Promise<Response> {\n    return {\n      status: this.request.statusCode,\n      statusText: this.request.statusText,\n      httpVersion: this.request.responseHttpVersion(),\n      headers: this.request.responseHeaders,\n      cookies: this.buildCookies(this.request.responseCookies || []),\n      content: await this.buildContent(),\n      redirectURL: this.request.responseHeaderValue('Location') ?? '',\n      headersSize: this.request.responseHeadersText?.length ?? -1,\n      bodySize: this.getResponseBodySize(),\n      _transferSize: this.request.transferSize\n    };\n  }\n\n  private async buildContent(): Promise<Content> {\n    const data: ContentData | undefined = await this.request.contentData();\n\n    return Object.assign(\n      {\n        size: this.request.resourceSize,\n        mimeType: this.request.mimeType || 'x-unknown',\n        compression: this.getResponseCompression() ?? undefined\n      },\n      data\n    );\n  }\n\n  // eslint-disable-next-line complexity\n  private buildTimings(): Timings {\n    const timing = this.request.timing;\n    const issueTime: number = this.request.issueTime;\n    const startTime: number = this.request.startTime;\n\n    const result: Timings = {\n      blocked: -1,\n      dns: -1,\n      ssl: -1,\n      connect: -1,\n      send: 0,\n      wait: 0,\n      receive: 0\n    };\n\n    const queuedTime: number =\n      issueTime < startTime ? startTime - issueTime : -1;\n    result.blocked = this.toMilliseconds(queuedTime);\n\n    let highestTime = 0;\n\n    if (timing) {\n      const blockedStart = this.leastNonNegative([\n        timing.dnsStart,\n        timing.connectStart,\n        timing.sendStart\n      ]);\n      if (blockedStart !== Infinity) {\n        result.blocked += blockedStart;\n      }\n\n      const dnsStart: any = timing.dnsEnd >= 0 ? blockedStart : 0;\n      const dnsEnd: number = timing.dnsEnd >= 0 ? timing.dnsEnd : -1;\n      result.dns = dnsEnd - dnsStart;\n\n      const sslStart: number = timing.sslEnd > 0 ? timing.sslStart : 0;\n      const sslEnd: number = timing.sslEnd > 0 ? timing.sslEnd : -1;\n      result.ssl = sslEnd - sslStart;\n\n      const connectStart: number =\n        timing.connectEnd >= 0\n          ? this.leastNonNegative([dnsEnd, blockedStart])\n          : 0;\n      const connectEnd: number =\n        timing.connectEnd >= 0 ? timing.connectEnd : -1;\n      result.connect = connectEnd - connectStart;\n\n      const sendStart: number =\n        timing.sendEnd >= 0 ? Math.max(connectEnd, dnsEnd, blockedStart) : 0;\n      const sendEnd: number = timing.sendEnd >= 0 ? timing.sendEnd : 0;\n      result.send = sendEnd - sendStart;\n\n      if (result.send < 0) {\n        result.send = 0;\n      }\n\n      highestTime = Math.max(\n        sendEnd,\n        connectEnd,\n        sslEnd,\n        dnsEnd,\n        blockedStart,\n        0\n      );\n    } else if (this.request.responseReceivedTime === -1) {\n      result.blocked = this.request.endTime - issueTime;\n\n      return result;\n    }\n\n    const requestTime: number = timing?.requestTime ?? startTime;\n    const waitStart: number = highestTime;\n    const waitEnd: number = this.toMilliseconds(\n      this.request.responseReceivedTime - requestTime\n    );\n    result.wait = waitEnd - waitStart;\n\n    const receiveStart: number = waitEnd;\n    const receiveEnd: number = this.toMilliseconds(\n      this.request.endTime - requestTime\n    );\n    result.receive = Math.max(receiveEnd - receiveStart, 0);\n\n    return result;\n  }\n\n  private leastNonNegative(values: number[]): number {\n    const value: number | undefined = values.find(\n      (item: number): boolean => item >= 0\n    );\n\n    return value ?? -1;\n  }\n\n  private async buildPostData(): Promise<PostData | undefined> {\n    const postData: string | undefined = await this.request.requestFormData();\n\n    if (!postData) {\n      return undefined;\n    }\n\n    const res: Partial<PostData> = {\n      mimeType: this.request.requestContentType ?? '',\n      text: postData\n    };\n\n    const formParameters: Param[] = await this.request.formParameters();\n\n    if (formParameters) {\n      res.params = [...formParameters] as never;\n    }\n\n    return res as PostData;\n  }\n\n  private buildRequestURL(url: string): string {\n    return url.split('#', 2)[0];\n  }\n\n  private buildCookies(cookies: NetworkCookie[]): Cookie[] {\n    return cookies.map(this.buildCookie.bind(this));\n  }\n\n  private buildCookie(cookie: NetworkCookie): Cookie {\n    return {\n      name: cookie.name,\n      value: cookie.value,\n      path: cookie.path,\n      domain: cookie.domain,\n      expires: cookie\n        .expiresDate(\n          new Date(this.request.getWallTime(this.request.startTime) * 1000)\n        )\n        ?.toJSON(),\n      httpOnly: cookie.httpOnly,\n      secure: cookie.secure\n    };\n  }\n\n  private async requestBodySize(): Promise<number> {\n    const postData: string | undefined = await this.request.requestFormData();\n\n    if (!postData) {\n      return 0;\n    }\n\n    return this.request.contentLength;\n  }\n}\n","export class ErrorUtils {\n  public static isError(val: unknown): val is Error {\n    return val instanceof Error;\n  }\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"os\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"util\");","import { EntryBuilder } from './EntryBuilder';\nimport type { NetworkRequest } from './NetworkRequest';\nimport type { HarExporter } from './HarExporter';\nimport type { Logger } from '../utils/Logger';\nimport { ErrorUtils } from '../utils/ErrorUtils';\nimport type {\n  DefaultHarExporterOptions,\n  Filter,\n  Transformer\n} from './DefaultHarExporterOptions';\nimport type { Entry } from 'har-format';\nimport type { WriteStream } from 'fs';\nimport { EOL } from 'os';\nimport { format, promisify } from 'util';\n\nexport class DefaultHarExporter implements HarExporter {\n  get path(): string {\n    const { path } = this.buffer;\n\n    return Buffer.isBuffer(path) ? path.toString('utf-8') : path;\n  }\n\n  private get filter(): Filter | undefined {\n    return this.options?.filter;\n  }\n\n  private get transform(): Transformer | undefined {\n    return this.options?.transform;\n  }\n\n  constructor(\n    private readonly logger: Logger,\n    private readonly buffer: WriteStream,\n    private readonly options?: DefaultHarExporterOptions\n  ) {}\n\n  public async write(networkRequest: NetworkRequest): Promise<void> {\n    const entry = await new EntryBuilder(networkRequest).build();\n\n    if (await this.applyFilter(entry)) {\n      return;\n    }\n\n    const json = await this.serializeEntry(entry);\n\n    if (!this.buffer.closed && json) {\n      // @ts-expect-error signature mismatch due to overloading issues\n      await promisify(this.buffer.write).call(this.buffer, `${json}${EOL}`);\n    }\n  }\n\n  public async serializeEntry(entry: Entry): Promise<string | undefined> {\n    try {\n      const result =\n        typeof this.transform === 'function'\n          ? await this.transform(entry)\n          : entry;\n\n      return JSON.stringify(result);\n    } catch (e) {\n      const stack = ErrorUtils.isError(e) ? e.stack : e;\n\n      this.logger.debug(\n        format(`The entry has been filtered out due to an error: %j`, entry)\n      );\n      this.logger.err(\n        `The entry is missing as a result of an error in the 'transform' function.\n\nThe stack trace for this error is:\n${stack}`\n      );\n\n      return undefined;\n    }\n  }\n\n  public end(): void {\n    this.buffer.end();\n  }\n\n  private async applyFilter(entry: Entry): Promise<unknown> {\n    try {\n      return typeof this.filter === 'function' && (await this.filter(entry));\n    } catch (e) {\n      const message = ErrorUtils.isError(e) ? e.message : e;\n\n      this.logger.debug(\n        `The operation has encountered an error while processing the entry. ${message}`\n      );\n\n      return false;\n    }\n  }\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"path\");","export enum CookieAttribute {\n  NAME = 'name',\n  VALUE = 'value',\n  SIZE = 'size',\n  DOMAIN = 'domain',\n  PORT = 'port',\n  PATH = 'path',\n  EXPIRES = 'expires',\n  HTTPONLY = 'httponly',\n  SECURE = 'secure',\n  SAMESITE = 'samesite',\n  MAXAGE = 'max-age'\n}\n\nexport class NetworkCookie {\n  private readonly _name: string;\n  private readonly _value: string;\n  private _attributes = new Map<CookieAttribute, string | undefined>();\n\n  private _size: number = 0;\n\n  get size(): number {\n    return this._size;\n  }\n\n  set size(size: number) {\n    this._size = size;\n  }\n\n  get name(): string {\n    return this._name;\n  }\n\n  get value(): string {\n    return this._value;\n  }\n\n  get httpOnly(): boolean {\n    return this._attributes.has(CookieAttribute.HTTPONLY);\n  }\n\n  get secure(): boolean {\n    return this._attributes.has(CookieAttribute.SECURE);\n  }\n\n  get sameSite(): 'Strict' | 'Lax' | 'None' | undefined {\n    return this._attributes.get(CookieAttribute.SAMESITE) as any;\n  }\n\n  get session(): boolean | undefined {\n    return !(\n      this._attributes.has(CookieAttribute.EXPIRES) ||\n      this._attributes.has(CookieAttribute.MAXAGE)\n    );\n  }\n\n  get path(): string | undefined {\n    return this._attributes.get(CookieAttribute.PATH);\n  }\n\n  get port(): string | undefined {\n    return this._attributes.get(CookieAttribute.PORT);\n  }\n\n  get domain(): string | undefined {\n    return this._attributes.get(CookieAttribute.DOMAIN);\n  }\n\n  get expires(): string | undefined {\n    return this._attributes.get(CookieAttribute.EXPIRES);\n  }\n\n  get maxAge(): number | undefined {\n    const maxAge: string = this._attributes.get(CookieAttribute.MAXAGE) ?? '';\n\n    return isNaN(+maxAge) ? undefined : +maxAge;\n  }\n\n  get url(): string {\n    return (this.secure ? 'https://' : 'http://') + this.domain + this.path;\n  }\n\n  constructor(name: string, value: string) {\n    this._name = name;\n    this._value = value;\n  }\n\n  public expiresDate(requestDate: Date): Date | undefined {\n    if (this.maxAge) {\n      const targetDate = requestDate === null ? new Date() : requestDate;\n\n      return new Date(targetDate.getTime() + 1000 * this.maxAge);\n    }\n\n    if (this.expires) {\n      return new Date(this.expires);\n    }\n\n    return undefined;\n  }\n\n  public addAttribute(key: string, value?: string): void {\n    this._attributes.set(key.toLowerCase() as CookieAttribute, value);\n  }\n}\n","import { CookieParser } from './CookieParser';\nimport { NetworkCookie } from './NetworkCookie';\nimport { StringUtils } from '../utils/StringUtils';\nimport type { RequestExtraInfo, ResponseExtraInfo } from './ExtraInfoBuilder';\nimport type { Header, Param, QueryString } from 'har-format';\nimport type Protocol from 'devtools-protocol';\n\nexport interface ContentData {\n  error?: string;\n  text?: string;\n  encoding?: string;\n}\n\nexport enum WebSocketFrameType {\n  REQUEST = 'request',\n  RESPONSE = 'response',\n  ERROR = 'error'\n}\n\nexport interface WebSocket {\n  type: WebSocketFrameType;\n  data: string;\n  time: Protocol.Network.MonotonicTime;\n  opcode: number;\n  mask: boolean;\n}\n\nexport interface EventSourceMessage {\n  time: number;\n  eventName: string;\n  eventId: string;\n  data: string;\n}\n\nexport class NetworkRequest {\n  private _contentData?: Promise<ContentData>;\n  private _wallIssueTime: Protocol.Network.TimeSinceEpoch = -1;\n  private _requestHeaderValues: Map<string, string> = new Map<string, string>();\n  private _responseHeaderValues: Map<string, string> = new Map<\n    string,\n    string\n  >();\n  private _parsedQueryParameters?: QueryString[];\n  private _currentPriority?: Protocol.Network.ResourcePriority;\n  private _requestFormData: Promise<string | undefined> =\n    Promise.resolve(undefined);\n  private _formParametersPromise?: Promise<Param[]>;\n\n  private _signedExchangeInfo?: Protocol.Network.SignedExchangeInfo;\n\n  // TODO: use to finalize a response in the `requestWillBeSent` event handler or\n  //  update `transferSize` for the chain of redirects\n  get signedExchangeInfo() {\n    return this._signedExchangeInfo;\n  }\n\n  set signedExchangeInfo(info) {\n    this._signedExchangeInfo = info;\n  }\n\n  private _hasExtraResponseInfo: boolean = false;\n\n  get hasExtraResponseInfo(): boolean {\n    return this._hasExtraResponseInfo;\n  }\n\n  set hasExtraResponseInfo(value: boolean) {\n    this._hasExtraResponseInfo = value;\n  }\n\n  private _hasExtraRequestInfo: boolean = false;\n\n  get hasExtraRequestInfo(): boolean {\n    return this._hasExtraRequestInfo;\n  }\n\n  set hasExtraRequestInfo(value: boolean) {\n    this._hasExtraRequestInfo = value;\n  }\n\n  private _connectionId: string = '0';\n\n  get connectionId() {\n    return this._connectionId;\n  }\n\n  set connectionId(value: string) {\n    this._connectionId = value;\n  }\n\n  private _protocol: string = '';\n\n  get protocol(): string {\n    return this._protocol;\n  }\n\n  set protocol(value: string) {\n    this._protocol = value ?? '';\n  }\n\n  private _requestTime: number = 0;\n\n  get requestTime(): number {\n    return this._requestTime;\n  }\n\n  set requestTime(value: number) {\n    this._requestTime = value ?? 0;\n  }\n\n  private _requestMethod: string = '';\n\n  get requestMethod(): string {\n    return this._requestMethod;\n  }\n\n  set requestMethod(value: string) {\n    this._requestMethod = value ?? '';\n  }\n\n  private _statusText: string = '';\n\n  get statusText(): string {\n    return this._statusText;\n  }\n\n  set statusText(value: string) {\n    this._statusText = value ?? '';\n  }\n\n  private _parsedURL!: URL;\n\n  get parsedURL() {\n    return this._parsedURL;\n  }\n\n  private _url!: string;\n\n  get url(): string {\n    return this._url;\n  }\n\n  set url(value: string) {\n    if (this._url === value) {\n      return;\n    }\n\n    this._url = value;\n    this._parsedURL = new URL(value);\n    delete this._queryString;\n    delete this._parsedQueryParameters;\n  }\n\n  private _remoteAddress: string = '';\n\n  get remoteAddress(): string {\n    return this._remoteAddress;\n  }\n\n  private _startTime: Protocol.Network.MonotonicTime = -1;\n\n  get startTime(): Protocol.Network.MonotonicTime {\n    return this._startTime || -1;\n  }\n\n  private _issueTime: Protocol.Network.MonotonicTime = -1;\n\n  get issueTime(): Protocol.Network.MonotonicTime {\n    return this._issueTime;\n  }\n\n  private _endTime: number = -1;\n\n  get endTime(): number {\n    return this._endTime || -1;\n  }\n\n  set endTime(x: number) {\n    if (this.timing && this.timing.requestTime) {\n      this._endTime = Math.max(x, this.responseReceivedTime);\n    } else {\n      this._endTime = x;\n      if (this._responseReceivedTime > x) {\n        this._responseReceivedTime = x;\n      }\n    }\n  }\n\n  private _responseReceivedTime: number = -1;\n\n  get responseReceivedTime(): number {\n    return this._responseReceivedTime || -1;\n  }\n\n  set responseReceivedTime(value: number) {\n    this._responseReceivedTime = value;\n  }\n\n  private _resourceSize: number = 0;\n\n  get resourceSize(): number {\n    return this._resourceSize || 0;\n  }\n\n  set resourceSize(value: number) {\n    this._resourceSize = value ?? 0;\n  }\n\n  private _transferSize: number = 0;\n\n  get transferSize(): number {\n    return this._transferSize || 0;\n  }\n\n  set transferSize(value: number) {\n    this._transferSize = value ?? 0;\n  }\n\n  private _timing?: Protocol.Network.ResourceTiming;\n\n  get timing() {\n    return this._timing;\n  }\n\n  set timing(timingInfo) {\n    if (!timingInfo) {\n      return;\n    }\n\n    this._startTime = timingInfo.requestTime;\n\n    const headersReceivedTime: number =\n      timingInfo.requestTime + timingInfo.receiveHeadersEnd / 1000.0;\n\n    if (\n      (this._responseReceivedTime || -1) < 0 ||\n      this._responseReceivedTime > headersReceivedTime\n    ) {\n      this._responseReceivedTime = headersReceivedTime;\n    }\n\n    if (this._startTime > this._responseReceivedTime) {\n      this._responseReceivedTime = this._startTime;\n    }\n\n    this._timing = timingInfo;\n  }\n\n  private _mimeType?: string;\n\n  get mimeType() {\n    return this._mimeType;\n  }\n\n  set mimeType(value) {\n    this._mimeType = value;\n  }\n\n  private _resourceType: Protocol.Network.ResourceType = 'Other';\n\n  get resourceType(): Protocol.Network.ResourceType {\n    return this._resourceType;\n  }\n\n  set resourceType(resourceType: Protocol.Network.ResourceType) {\n    this._resourceType = resourceType ?? 'Other';\n  }\n\n  private _redirectSource?: NetworkRequest;\n\n  get redirectSource() {\n    return this._redirectSource;\n  }\n\n  set redirectSource(originatingRequest) {\n    this._redirectSource = originatingRequest;\n  }\n\n  private _requestHeaders: Header[] = [];\n\n  get requestHeaders(): Header[] {\n    return this._requestHeaders;\n  }\n\n  set requestHeaders(headers: Header[]) {\n    this._requestHeaders = headers;\n    this._requestHeaderValues.clear();\n    delete this._requestCookies;\n  }\n\n  private _requestCookies?: NetworkCookie[];\n\n  get requestCookies(): NetworkCookie[] | undefined {\n    if (!this._requestCookies) {\n      const cookie = this.requestHeaderValue('Cookie');\n      this._requestCookies = cookie\n        ? new CookieParser().parseCookie(cookie)\n        : undefined;\n    }\n\n    return this._requestCookies;\n  }\n\n  get contentLength(): number {\n    const contentLength: string | undefined =\n      this.requestHeaderValue('Content-Length');\n\n    return contentLength == null || isNaN(+contentLength)\n      ? 0\n      : parseInt(contentLength, 10);\n  }\n\n  private _requestHeadersText: string = '';\n\n  get requestHeadersText(): string {\n    return this._requestHeadersText;\n  }\n\n  set requestHeadersText(text: string) {\n    this._requestHeadersText = text;\n  }\n\n  private _connectionReused: boolean = false;\n\n  get connectionReused(): boolean {\n    return this._connectionReused;\n  }\n\n  set connectionReused(value: boolean) {\n    this._connectionReused = value;\n  }\n\n  private _responseHeaders: Header[] = [];\n\n  get responseHeaders(): Header[] {\n    return this._responseHeaders || [];\n  }\n\n  set responseHeaders(value: Header[]) {\n    this._responseHeaders = value;\n    delete this._responseCookies;\n    this._responseHeaderValues.clear();\n  }\n\n  private _responseHeadersText: string = '';\n\n  get responseHeadersText(): string {\n    return this._responseHeadersText;\n  }\n\n  set responseHeadersText(value: string) {\n    this._responseHeadersText = value;\n  }\n\n  private _responseCookies?: NetworkCookie[];\n\n  get responseCookies(): NetworkCookie[] | undefined {\n    if (!this._responseCookies) {\n      const cookie = this.responseHeaderValue('Set-Cookie');\n      this._responseCookies = cookie\n        ? new CookieParser().parseSetCookie(cookie)\n        : undefined;\n    }\n\n    return this._responseCookies;\n  }\n\n  private _queryString?: string;\n\n  get queryString() {\n    if (this._queryString || !this.url) {\n      return this._queryString;\n    }\n\n    let queryString: string | undefined;\n    const questionMarkPosition = this.url.indexOf('?');\n\n    if (questionMarkPosition !== -1) {\n      queryString = this.url.substring(questionMarkPosition + 1);\n      const hashSignPosition = queryString.indexOf('#');\n\n      if (hashSignPosition !== -1) {\n        queryString = queryString.substring(0, hashSignPosition);\n      }\n    }\n\n    this._queryString = queryString;\n\n    return this._queryString;\n  }\n\n  private _initialPriority?: Protocol.Network.ResourcePriority;\n\n  get initialPriority() {\n    return this._initialPriority;\n  }\n\n  set initialPriority(priority) {\n    this._initialPriority = priority;\n  }\n\n  private _eventSourceMessages: EventSourceMessage[] = [];\n\n  get eventSourceMessages(): EventSourceMessage[] {\n    return this._eventSourceMessages;\n  }\n\n  private _frames: WebSocket[] = [];\n\n  get frames(): WebSocket[] {\n    return this._frames;\n  }\n\n  private _statusCode: number = 0;\n\n  get statusCode(): number {\n    return this._statusCode;\n  }\n\n  set statusCode(value: number) {\n    this._statusCode = value;\n  }\n\n  get requestId(): Protocol.Network.RequestId {\n    return this._requestId;\n  }\n\n  get requestHttpVersion(): string {\n    if (this.requestHeadersText) {\n      const firstLine = this.requestHeadersText.split(/\\r\\n/)[0];\n      const match = firstLine.match(/(HTTP\\/\\d+\\.\\d+)$/);\n\n      return match ? match[1] : 'HTTP/0.9';\n    }\n\n    const version =\n      this.requestHeaderValue('version') || this.requestHeaderValue(':version');\n    if (version) {\n      return version;\n    }\n\n    return this.getFilteredProtocolName();\n  }\n\n  get queryParameters(): QueryString[] | undefined {\n    if (this._parsedQueryParameters) {\n      return this._parsedQueryParameters;\n    }\n\n    if (this.queryString) {\n      this._parsedQueryParameters = this.parseParameters(this.queryString);\n    }\n\n    return this._parsedQueryParameters;\n  }\n\n  get requestContentType(): string | undefined {\n    return this.requestHeaderValue('Content-Type');\n  }\n\n  get priority(): Protocol.Network.ResourcePriority | undefined {\n    return this._currentPriority ?? this.initialPriority ?? undefined;\n  }\n\n  set priority(priority) {\n    this._currentPriority = priority;\n  }\n\n  constructor(\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    private _requestId: Protocol.Network.RequestId,\n    url: string,\n    public readonly documentURL: string,\n    public readonly loaderId: Protocol.Network.LoaderId,\n    public readonly initiator?: Protocol.Network.Initiator,\n    public readonly frameId: Protocol.Page.FrameId = ''\n  ) {\n    this.url = url;\n  }\n\n  public async waitForCompletion(): Promise<void> {\n    await Promise.all([this._contentData, this._formParametersPromise]);\n  }\n\n  public isBlob(): boolean {\n    return this._url.startsWith('blob:');\n  }\n\n  public setRemoteAddress(ip: string, port: number): void {\n    this._remoteAddress = `${ip}:${port}`;\n  }\n\n  public setIssueTime(\n    monotonicTime: Protocol.Network.MonotonicTime,\n    wallTime: Protocol.Network.TimeSinceEpoch\n  ): void {\n    this._issueTime = monotonicTime;\n    this._wallIssueTime = wallTime;\n    this._startTime = monotonicTime;\n  }\n\n  public increaseTransferSize(value: number): void {\n    this._transferSize = (this._transferSize || 0) + value;\n  }\n\n  public requestFormData(): Promise<string | undefined> {\n    return this._requestFormData;\n  }\n\n  public setRequestFormData(data: string | Promise<string | undefined>): void {\n    this._requestFormData =\n      typeof data === 'string' ? Promise.resolve(data) : data;\n    this._formParametersPromise = undefined;\n  }\n\n  public getWallTime(monotonicTime: Protocol.Network.MonotonicTime): number {\n    return this._wallIssueTime\n      ? this._wallIssueTime - this._issueTime + monotonicTime\n      : monotonicTime;\n  }\n\n  public formParameters(): Promise<Param[]> {\n    if (!this._formParametersPromise) {\n      this._formParametersPromise = this.parseFormParameters();\n    }\n\n    return this._formParametersPromise;\n  }\n\n  public responseHttpVersion(): string {\n    if (this._responseHeadersText) {\n      const firstLine: string = this._responseHeadersText.split(/\\r\\n/)[0];\n      const match: RegExpMatchArray | null =\n        firstLine.match(/^(HTTP\\/\\d+\\.\\d+)/);\n\n      return match ? match[1] : 'HTTP/0.9';\n    }\n\n    const version =\n      this.responseHeaderValue('version') ||\n      this.responseHeaderValue(':version');\n\n    if (version) {\n      return version;\n    }\n\n    return this.getFilteredProtocolName();\n  }\n\n  public setContentData(\n    data: Promise<Protocol.Network.GetResponseBodyResponse>\n  ): void {\n    if (this.resourceType === 'WebSocket') {\n      this._contentData = Promise.resolve({\n        error: 'Content for WebSockets is currently not supported'\n      });\n\n      return;\n    }\n\n    this._contentData = data\n      .then(\n        ({\n          body: text,\n          base64Encoded\n        }: Protocol.Network.GetResponseBodyResponse): ContentData => ({\n          text,\n          encoding: base64Encoded ? 'base64' : undefined\n        })\n      )\n      .catch((e: Error): ContentData => ({ error: e.message }));\n  }\n\n  public contentData(): Promise<ContentData> | undefined {\n    return this._contentData;\n  }\n\n  public addProtocolFrameError(\n    errorMessage: string,\n    time: Protocol.Network.MonotonicTime\n  ): void {\n    this.addFrame({\n      time,\n      type: WebSocketFrameType.ERROR,\n      data: errorMessage,\n      opcode: -1,\n      mask: false\n    });\n  }\n\n  public addProtocolFrame(\n    response: Protocol.Network.WebSocketFrame,\n    time: Protocol.Network.MonotonicTime,\n    sent: boolean\n  ): void {\n    const type: WebSocketFrameType = sent\n      ? WebSocketFrameType.REQUEST\n      : WebSocketFrameType.RESPONSE;\n\n    this.addFrame({\n      type,\n      time,\n      data: response.payloadData,\n      opcode: response.opcode,\n      mask: response.mask\n    });\n  }\n\n  public addEventSourceMessage(\n    time: number,\n    eventName: string,\n    eventId: string,\n    data: string\n  ) {\n    const message = { time, eventName, eventId, data };\n    this._eventSourceMessages.push(message);\n  }\n\n  public markAsRedirect(redirectCount: number): void {\n    this._requestId = `${this.requestId}:redirected.${redirectCount}`;\n  }\n\n  public addExtraRequestInfo(extraRequestInfo: RequestExtraInfo): void {\n    this.requestHeaders = extraRequestInfo.requestHeaders;\n    this._hasExtraRequestInfo = true;\n    this.requestHeadersText = '';\n  }\n\n  public addExtraResponseInfo(extraResponseInfo: ResponseExtraInfo): void {\n    this.responseHeaders = extraResponseInfo.responseHeaders;\n\n    if (extraResponseInfo.responseHeadersText) {\n      this.responseHeadersText = extraResponseInfo.responseHeadersText;\n\n      if (this.requestHeadersText) {\n        let requestHeadersText = `${this._requestMethod} ${this.parsedURL.pathname}`;\n\n        // eslint-disable-next-line max-depth\n        if (this.parsedURL.search) {\n          requestHeadersText += this.parsedURL.search;\n        }\n\n        requestHeadersText += ` HTTP/1.1\\r\\n`;\n\n        // eslint-disable-next-line max-depth\n        for (const { name, value } of this.requestHeaders) {\n          requestHeadersText += `${name}: ${value}\\r\\n`;\n        }\n\n        this.requestHeadersText = requestHeadersText;\n      }\n    }\n\n    this._hasExtraResponseInfo = true;\n  }\n\n  public responseHeaderValue(headerName: string): string | undefined {\n    if (!this._responseHeaderValues.has(headerName)) {\n      const headerValue = this.computeHeaderValue(\n        this.responseHeaders,\n        headerName\n      );\n      headerValue && this._responseHeaderValues.set(headerName, headerValue);\n    }\n\n    return this._responseHeaderValues.get(headerName);\n  }\n\n  private async parseFormParameters(): Promise<Param[]> {\n    if (\n      this.requestContentType?.match(\n        /^application\\/x-www-form-urlencoded\\s*(;.*)?$/i\n      )\n    ) {\n      const formUrlencoded = await this.requestFormData();\n\n      if (!formUrlencoded) {\n        return [];\n      }\n\n      return this.parseParameters(formUrlencoded);\n    }\n\n    const multipartDetails = this.requestContentType?.match(\n      /^multipart\\/form-data\\s*;\\s*boundary\\s*=\\s*(\\S+)\\s*$/\n    );\n\n    if (!multipartDetails) {\n      return [];\n    }\n\n    const boundary = multipartDetails[1];\n    const formData = await this.requestFormData();\n\n    if (!boundary || !formData) {\n      return [];\n    }\n\n    return this.parseMultipartFormDataParameters(formData, boundary);\n  }\n\n  private parseMultipartFormDataParameters(\n    data: string,\n    boundary: string\n  ): Param[] {\n    const sanitizedBoundary: string = StringUtils.escapeCharacters(boundary);\n    const keyValuePattern = new RegExp(\n      // Header with an optional file name.\n      '^\\\\r\\\\ncontent-disposition\\\\s*:\\\\s*form-data\\\\s*;\\\\s*name=\"([^\"]*)\"(?:\\\\s*;\\\\s*filename=\"([^\"]*)\")?' +\n        // Optional secondary header with the content type.\n        '(?:\\\\r\\\\ncontent-type\\\\s*:\\\\s*([^\\\\r\\\\n]*))?' +\n        // Padding.\n        '\\\\r\\\\n\\\\r\\\\n' +\n        // Value\n        '(.*)' +\n        // Padding.\n        '\\\\r\\\\n$',\n      'is'\n    );\n    const fields: string[] = data.split(\n      // eslint-disable-next-line no-useless-escape\n      new RegExp(`--${sanitizedBoundary}(?:--\\s*$)?`, 'g')\n    );\n\n    return fields.reduce((result: Param[], field: string): Param[] => {\n      const [match, name, fileName, contentType, value]: RegExpMatchArray =\n        field.match(keyValuePattern) ?? [];\n\n      if (!match) {\n        return result;\n      }\n\n      result.push({ name, value, fileName, contentType });\n\n      return result;\n    }, []);\n  }\n\n  private addFrame(frame: WebSocket): void {\n    this._frames.push(frame);\n  }\n\n  private requestHeaderValue(headerName: string): string | undefined {\n    if (!this._requestHeaderValues.has(headerName)) {\n      const headerValue = this.computeHeaderValue(\n        this.requestHeaders,\n        headerName\n      );\n      headerValue && this._requestHeaderValues.set(headerName, headerValue);\n    }\n\n    return this._requestHeaderValues.get(headerName);\n  }\n\n  private getFilteredProtocolName(): string {\n    const protocol = this._protocol.toLowerCase();\n\n    if (protocol === 'h2') {\n      return 'http/2.0';\n    }\n\n    return protocol.replace(/^http\\/2(\\.0)?\\+/, 'http/2.0+');\n  }\n\n  private parseParameters(queryString: string): QueryString[] {\n    return queryString.split('&').map((pair: string): QueryString => {\n      const position: number = pair.indexOf('=');\n      if (position === -1) {\n        return { name: pair, value: '' };\n      } else {\n        return {\n          name: pair.substring(0, position),\n          value: pair.substring(position + 1)\n        };\n      }\n    });\n  }\n\n  private computeHeaderValue(\n    headers: Header[],\n    headerName: string\n  ): string | undefined {\n    headerName = headerName.toLowerCase();\n\n    const values: string[] = headers\n      .filter(({ name }: Header): boolean => name.toLowerCase() === headerName)\n      .map(({ value }: Header): string => value);\n\n    if (!values.length) {\n      return undefined;\n    }\n\n    // Set-Cookie values should be separated by '\\n', not comma, otherwise cookies could not be parsed.\n    if (headerName === 'set-cookie') {\n      return values.join('\\n');\n    }\n\n    return values.join(', ');\n  }\n}\n","import { NetworkCookie } from './NetworkCookie';\n\ninterface KeyValue {\n  key: string;\n  value?: string;\n  position: number;\n}\n\nexport class CookieParser {\n  private _input?: string;\n  private _originalInputLength?: number;\n  private _lastCookie?: NetworkCookie;\n  private _lastCookiePosition: number = 0;\n  private _cookies?: NetworkCookie[];\n\n  public parseCookie(cookieHeader: string): NetworkCookie[] | undefined {\n    this._initialize(cookieHeader);\n\n    for (let kv = this._extractKeyValue(); kv; kv = this._extractKeyValue()) {\n      if (kv.key.charAt(0) === '$' && this._lastCookie) {\n        this._lastCookie.addAttribute(kv.key.slice(1), kv.value);\n      } else if (\n        kv.key.toLowerCase() !== '$version' &&\n        typeof kv.value === 'string'\n      ) {\n        this.addCookie(kv);\n      }\n\n      this.advanceAndCheckCookieDelimiter();\n    }\n\n    this.flushCookie();\n\n    return this._cookies;\n  }\n\n  public parseSetCookie(setCookieHeader: string): NetworkCookie[] | undefined {\n    this._initialize(setCookieHeader);\n\n    for (let kv = this._extractKeyValue(); kv; kv = this._extractKeyValue()) {\n      if (this._lastCookie) {\n        this._lastCookie.addAttribute(kv.key, kv.value);\n      } else {\n        this.addCookie(kv);\n      }\n      if (this.advanceAndCheckCookieDelimiter()) {\n        this.flushCookie();\n      }\n    }\n    this.flushCookie();\n\n    return this._cookies;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  private _initialize(headerValue: string): void {\n    this._input = headerValue;\n    this._cookies = [];\n    this._lastCookie = undefined;\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    this._originalInputLength = this._input.length;\n  }\n\n  private flushCookie(): void {\n    if (this._lastCookie) {\n      /* eslint-disable @typescript-eslint/no-non-null-assertion */\n      this._lastCookie.size =\n        this._originalInputLength! -\n        this._input!.length -\n        this._lastCookiePosition;\n      /* eslint-enable @typescript-eslint/no-non-null-assertion */\n    }\n\n    delete this._lastCookie;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  private _extractKeyValue(): KeyValue | undefined {\n    if (!this._input?.length) {\n      return undefined;\n    }\n\n    // Note: RFCs offer an option for quoted values that may contain commas and semicolons.\n    // Many browsers/platforms do not support this, however (see http://webkit.org/b/16699\n    // and http://crbug.com/12361). The logic below matches latest versions of IE, Firefox,\n    // Chrome and Safari on some old platforms. The latest version of Safari supports quoted\n    // cookie values, though.\n    const keyValueMatch = /^[ \\t]*([^\\s=;]+)[ \\t]*(?:=[ \\t]*([^;\\n]*))?/i.exec(\n      this._input\n    );\n\n    if (!keyValueMatch) {\n      return undefined;\n    }\n\n    const result: KeyValue = {\n      key: this.toCamelCase(keyValueMatch[1]),\n      value: keyValueMatch[2]?.trim(),\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      position: this._originalInputLength! - this._input.length\n    };\n\n    this._input = this._input.slice(keyValueMatch[0].length);\n\n    return result;\n  }\n\n  private toCamelCase(str: string): string {\n    return str\n      .replace(/\\s(.)/g, (m: string): string => m.toUpperCase())\n      .replace(/\\s/g, '')\n      .replace(/^(.)/, (m: string): string => m.toLowerCase());\n  }\n\n  private advanceAndCheckCookieDelimiter(): boolean {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const match: RegExpExecArray | null = /^\\s*[\\n;]\\s*/.exec(this._input!);\n\n    if (!match) {\n      return false;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    this._input = this._input!.slice(match[0].length);\n\n    return match[0].match('\\n') !== null;\n  }\n\n  private addCookie(keyValue: KeyValue): void {\n    if (this._lastCookie) {\n      this._lastCookie.size = keyValue.position - this._lastCookiePosition;\n    }\n\n    this._lastCookie =\n      typeof keyValue.value === 'string'\n        ? new NetworkCookie(keyValue.key, keyValue.value)\n        : new NetworkCookie('', keyValue.key);\n\n    this._lastCookiePosition = keyValue.position;\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    this._cookies!.push(this._lastCookie);\n  }\n}\n","export class StringUtils {\n  public static isString(value: unknown): value is string {\n    return typeof value === 'string';\n  }\n\n  public static toRegexSource(pattern: RegExp | string): string {\n    return this.isString(pattern) ? pattern : pattern.source;\n  }\n\n  public static toRegex(pattern: RegExp | string): RegExp {\n    return this.isString(pattern) ? new RegExp(pattern) : pattern;\n  }\n\n  public static dirname(path: string): string {\n    const normalizedPath = this.removeTrailingSlash(path);\n    const fileNameIdx = this.fileNameIdx(normalizedPath);\n    const dirname = normalizedPath.substring(0, fileNameIdx);\n\n    return this.removeTrailingSlash(dirname);\n  }\n\n  public static normalizeName(\n    path: string,\n    options?: { ext?: string }\n  ): string {\n    const fileNameIdx = this.fileNameIdx(path);\n    const name = this.removeLeadingSlash(path.substring(fileNameIdx));\n\n    const extIdx = name.lastIndexOf('.');\n\n    let ext: string | undefined;\n    let nameWithoutExt = name;\n\n    if (extIdx >= 0) {\n      ext = options?.ext ?? name.substring(extIdx);\n      nameWithoutExt = name.substring(0, extIdx);\n    }\n\n    return `${nameWithoutExt}${ext ?? '.har'}`;\n  }\n\n  public static escapeCharacters(\n    str: string,\n    chars: string = '^[]{}()\\\\\\\\.$*+?|'\n  ): string {\n    let foundChar = false;\n\n    const length = chars.length;\n\n    for (let i = 0; i < length; ++i) {\n      if (str.indexOf(chars.charAt(i)) !== -1) {\n        foundChar = true;\n        break;\n      }\n    }\n\n    if (!foundChar) {\n      return str;\n    }\n\n    let result = '';\n\n    for (let j = 0; j < str.length; ++j) {\n      if (chars.indexOf(str.charAt(j)) !== -1) {\n        result += '\\\\';\n      }\n\n      result += str.charAt(j);\n    }\n\n    return result;\n  }\n\n  private static fileNameIdx(path: string): number {\n    return path.indexOf('\\\\') >= 0\n      ? path.lastIndexOf('\\\\')\n      : path.lastIndexOf('/');\n  }\n\n  private static removeLeadingSlash(path: string): string {\n    return path.replace(/^\\/|^\\\\/, '');\n  }\n\n  private static removeTrailingSlash(path: string): string {\n    return path.replace(/\\/+$|\\\\+$/, '');\n  }\n}\n","import { NetworkRequest } from './NetworkRequest';\nimport type { Header } from 'har-format';\n\nexport interface RequestExtraInfo {\n  requestHeaders: Header[];\n}\n\nexport interface ResponseExtraInfo {\n  responseHeaders: Header[];\n  responseHeadersText?: string;\n}\n\nexport class ExtraInfoBuilder {\n  private _hasExtraInfo: boolean = false;\n  private _finished: boolean = false;\n  private readonly _requests: NetworkRequest[] = [];\n  private readonly _requestExtraInfo: RequestExtraInfo[] = [];\n  private readonly _responseExtraInfo: ResponseExtraInfo[] = [];\n\n  constructor(private readonly deleteCallback: () => void) {}\n\n  public addRequest(request: NetworkRequest): void {\n    this._requests.push(request);\n    this.sync();\n  }\n\n  public addRequestExtraInfo(info: RequestExtraInfo): void {\n    this._requestExtraInfo.push(info);\n    this._hasExtraInfo = true;\n    this.sync();\n  }\n\n  public addResponseExtraInfo(info: ResponseExtraInfo): void {\n    this._responseExtraInfo.push(info);\n    this.sync();\n  }\n\n  public finished(): void {\n    this._finished = true;\n    this.deleteIfComplete();\n  }\n\n  private deleteIfComplete(): void {\n    if (!this._finished) {\n      return;\n    }\n\n    if (this._hasExtraInfo) {\n      const lastRequest: NetworkRequest | undefined = this.getLastRequest();\n\n      if (!lastRequest?.hasExtraResponseInfo) {\n        return;\n      }\n    }\n\n    this.deleteCallback();\n  }\n\n  private getLastRequest(): NetworkRequest | undefined {\n    return this._requests[this._requests.length - 1];\n  }\n\n  private getRequestIndex(req: NetworkRequest): number {\n    return this._requests.indexOf(req);\n  }\n\n  private sync(): void {\n    const req: NetworkRequest | undefined = this.getLastRequest();\n\n    if (!req) {\n      return;\n    }\n\n    const index: number = this.getRequestIndex(req);\n\n    const requestExtraInfo: RequestExtraInfo | undefined =\n      this._requestExtraInfo[index];\n\n    if (requestExtraInfo) {\n      req.addExtraRequestInfo(requestExtraInfo);\n      delete this._requestExtraInfo[index];\n    }\n\n    const responseExtraInfo: ResponseExtraInfo | undefined =\n      this._responseExtraInfo[index];\n    if (responseExtraInfo) {\n      req.addExtraResponseInfo(responseExtraInfo);\n      delete this._responseExtraInfo[index];\n    }\n\n    this.deleteIfComplete();\n  }\n}\n","import { Logger } from '../utils/Logger';\nimport { NetworkRequest } from './NetworkRequest';\nimport { ExtraInfoBuilder } from './ExtraInfoBuilder';\nimport type { NetworkObserverOptions } from './NetworkObserverOptions';\nimport type { Observer } from './Observer';\nimport type { RequestFilter } from './filters';\nimport type { Network, NetworkEvent } from './Network';\nimport type Protocol from 'devtools-protocol';\nimport type { Header } from 'har-format';\n\nexport class NetworkObserver implements Observer<NetworkRequest> {\n  private readonly _entries: Map<Protocol.Network.RequestId, NetworkRequest>;\n  private readonly _extraInfoBuilders: Map<\n    Protocol.Network.RequestId,\n    ExtraInfoBuilder\n  >;\n  private destination?: (chromeEntry: NetworkRequest) => unknown;\n\n  get empty(): boolean {\n    return this._entries.size === 0;\n  }\n\n  constructor(\n    private readonly options: NetworkObserverOptions,\n    private readonly network: Network,\n    private readonly logger: Logger,\n    private readonly requestFilter?: RequestFilter\n  ) {\n    this._entries = new Map<Protocol.Network.RequestId, NetworkRequest>();\n    this._extraInfoBuilders = new Map<\n      Protocol.Network.RequestId,\n      ExtraInfoBuilder\n    >();\n  }\n\n  public async subscribe(\n    callback: (chromeEntry: NetworkRequest) => unknown\n  ): Promise<void> {\n    this.destination = callback;\n\n    await this.network.attachToTargets((event: NetworkEvent): void =>\n      this.handleEvent(event)\n    );\n  }\n\n  public async unsubscribe(): Promise<void> {\n    await this.network.detachFromTargets();\n    delete this.destination;\n    this._entries.clear();\n    this._extraInfoBuilders.clear();\n  }\n\n  public signedExchangeReceived(\n    params: Protocol.Network.SignedExchangeReceivedEvent\n  ): void {\n    const entry: NetworkRequest | undefined = this._entries.get(\n      params.requestId\n    );\n    if (!entry) {\n      return;\n    }\n\n    entry.signedExchangeInfo = params.info;\n    entry.resourceType = 'SignedExchange';\n\n    this.updateNetworkRequestWithResponse(entry, params.info.outerResponse);\n  }\n\n  public requestWillBeSent({\n    type,\n    loaderId,\n    initiator,\n    redirectResponse,\n    documentURL,\n    frameId,\n    timestamp,\n    requestId,\n    request,\n    wallTime\n  }: Protocol.Network.RequestWillBeSentEvent): void {\n    let entry: NetworkRequest | undefined = this._entries.get(requestId);\n\n    if (entry) {\n      if (!redirectResponse) {\n        return;\n      }\n\n      if (!entry.signedExchangeInfo) {\n        this.responseReceived({\n          requestId,\n          loaderId,\n          timestamp,\n          frameId,\n          type: 'Other',\n          response: redirectResponse\n        });\n      }\n      entry = this._appendRedirect(requestId, timestamp, request.url);\n    } else {\n      entry = this.createRequest(\n        requestId,\n        frameId,\n        loaderId,\n        request.url,\n        documentURL,\n        initiator\n      );\n    }\n\n    this.updateNetworkRequestWithRequest(entry, request);\n\n    entry.setIssueTime(timestamp, wallTime);\n    entry.resourceType = type ?? 'Other';\n\n    this.getExtraInfoBuilder(requestId).addRequest(entry);\n\n    this.startRequest(entry);\n  }\n\n  public dataReceived({\n    requestId,\n    dataLength,\n    encodedDataLength,\n    timestamp\n  }: Protocol.Network.DataReceivedEvent): void {\n    const entry: NetworkRequest | undefined = this._entries.get(requestId);\n    if (!entry) {\n      return;\n    }\n    entry.resourceSize += dataLength;\n    if (encodedDataLength !== -1) {\n      entry.increaseTransferSize(encodedDataLength);\n    }\n    entry.endTime = timestamp;\n  }\n\n  public responseReceived({\n    requestId,\n    response,\n    timestamp,\n    type\n  }: Omit<Protocol.Network.ResponseReceivedEvent, 'hasExtraInfo'>): void {\n    const entry: NetworkRequest | undefined = this._entries.get(requestId);\n\n    if (!entry) {\n      return;\n    }\n\n    entry.responseReceivedTime = timestamp;\n    entry.resourceType = type;\n\n    this.updateNetworkRequestWithResponse(entry, response);\n  }\n\n  public resourceChangedPriority({\n    requestId,\n    newPriority\n  }: Protocol.Network.ResourceChangedPriorityEvent): void {\n    const entry: NetworkRequest | undefined = this._entries.get(requestId);\n\n    if (!entry) {\n      return;\n    }\n\n    entry.priority = newPriority;\n  }\n\n  public async loadingFinished({\n    requestId,\n    timestamp,\n    encodedDataLength\n  }: Protocol.Network.LoadingFinishedEvent): Promise<void> {\n    const entry: NetworkRequest | undefined = this._entries.get(requestId);\n\n    if (!entry) {\n      return;\n    }\n\n    this.finishRequest(entry, timestamp, encodedDataLength);\n  }\n\n  public loadingFailed({\n    requestId,\n    errorText,\n    canceled,\n    type,\n    timestamp\n  }: Protocol.Network.LoadingFailedEvent): void {\n    const entry: NetworkRequest | undefined = this._entries.get(requestId);\n    if (!entry) {\n      return;\n    }\n\n    entry.resourceType = type;\n\n    this.finishRequest(entry, timestamp, -1);\n\n    const message = errorText || (canceled && 'Canceled');\n    this.logger.debug(`Failed request: ${requestId}. Reason: ${message}`);\n  }\n\n  public webSocketCreated({\n    initiator,\n    requestId,\n    url\n  }: Protocol.Network.WebSocketCreatedEvent): void {\n    const entry: NetworkRequest = this.createRequest(\n      requestId,\n      '',\n      '',\n      url,\n      '',\n      initiator\n    );\n    this.startRequest(entry);\n  }\n\n  public eventSourceMessageReceived({\n    requestId,\n    timestamp,\n    eventName,\n    eventId,\n    data\n  }: Protocol.Network.EventSourceMessageReceivedEvent): void {\n    const entry: NetworkRequest | undefined = this._entries.get(requestId);\n    if (!entry) {\n      return;\n    }\n    entry.addEventSourceMessage(timestamp, eventName, eventId, data);\n  }\n\n  public webSocketWillSendHandshakeRequest({\n    request,\n    requestId,\n    timestamp,\n    wallTime\n  }: Protocol.Network.WebSocketWillSendHandshakeRequestEvent): void {\n    const entry: NetworkRequest | undefined = this._entries.get(requestId);\n    if (!entry) {\n      return;\n    }\n    entry.requestMethod = 'GET';\n    entry.requestHeaders = this.headersMapToHeadersArray(request.headers);\n    entry.setIssueTime(timestamp, wallTime);\n  }\n\n  public webSocketHandshakeResponseReceived({\n    timestamp,\n    response,\n    requestId\n  }: Protocol.Network.WebSocketHandshakeResponseReceivedEvent): void {\n    const entry: NetworkRequest | undefined = this._entries.get(requestId);\n\n    if (!entry) {\n      return;\n    }\n\n    entry.statusCode = response.status;\n    entry.statusText = response.statusText;\n    entry.responseHeaders = this.headersMapToHeadersArray(response.headers);\n    entry.responseHeadersText = response.headersText || '';\n\n    if (response.requestHeaders) {\n      entry.requestHeaders = this.headersMapToHeadersArray(\n        response.requestHeaders\n      );\n    }\n\n    if (response.requestHeadersText) {\n      entry.requestHeadersText = response.requestHeadersText;\n    }\n\n    entry.responseReceivedTime = timestamp;\n    entry.protocol = 'websocket';\n  }\n\n  public webSocketFrameSent({\n    requestId,\n    timestamp,\n    response\n  }: Protocol.Network.WebSocketFrameSentEvent): void {\n    const entry: NetworkRequest | undefined = this._entries.get(requestId);\n\n    if (!entry) {\n      return;\n    }\n\n    entry.addProtocolFrame(response, timestamp, true);\n    entry.responseReceivedTime = timestamp;\n  }\n\n  public webSocketFrameReceived({\n    requestId,\n    timestamp,\n    response\n  }: Protocol.Network.WebSocketFrameReceivedEvent): void {\n    const entry: NetworkRequest | undefined = this._entries.get(requestId);\n\n    if (!entry) {\n      return;\n    }\n\n    entry.addProtocolFrame(response, timestamp, false);\n    entry.responseReceivedTime = timestamp;\n  }\n\n  public webSocketFrameError({\n    errorMessage,\n    requestId,\n    timestamp\n  }: Protocol.Network.WebSocketFrameErrorEvent): void {\n    const entry: NetworkRequest | undefined = this._entries.get(requestId);\n\n    if (!entry) {\n      return;\n    }\n\n    entry.addProtocolFrameError(errorMessage, timestamp);\n    entry.responseReceivedTime = timestamp;\n  }\n\n  public webSocketClosed({\n    requestId,\n    timestamp\n  }: Protocol.Network.WebSocketClosedEvent): void {\n    const entry: NetworkRequest | undefined = this._entries.get(requestId);\n\n    if (!entry) {\n      return;\n    }\n\n    this.finishRequest(entry, timestamp, -1);\n  }\n\n  public requestWillBeSentExtraInfo({\n    requestId,\n    headers\n  }: Protocol.Network.RequestWillBeSentExtraInfoEvent): void {\n    this.getExtraInfoBuilder(requestId).addRequestExtraInfo({\n      requestHeaders: this.headersMapToHeadersArray(headers)\n    });\n  }\n\n  public responseReceivedExtraInfo({\n    requestId,\n    headers,\n    headersText\n  }: Protocol.Network.ResponseReceivedExtraInfoEvent): void {\n    this.getExtraInfoBuilder(requestId).addResponseExtraInfo({\n      responseHeaders: this.headersMapToHeadersArray(headers),\n      responseHeadersText: headersText\n    });\n  }\n\n  private getExtraInfoBuilder(\n    requestId: Protocol.Network.RequestId\n  ): ExtraInfoBuilder {\n    if (!this._extraInfoBuilders.has(requestId)) {\n      this._extraInfoBuilders.set(\n        requestId,\n        new ExtraInfoBuilder((): void => {\n          this._extraInfoBuilders.delete(requestId);\n        })\n      );\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this._extraInfoBuilders.get(requestId)!;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  private _appendRedirect(\n    requestId: Protocol.Network.RequestId,\n    time: Protocol.Network.MonotonicTime,\n    redirectURL: string\n  ): NetworkRequest {\n    const originalNetworkRequest: NetworkRequest = this._entries.get(\n      requestId\n    ) as NetworkRequest;\n\n    let redirectCount = 0;\n    let redirect: NetworkRequest | undefined =\n      originalNetworkRequest.redirectSource;\n\n    while (redirect) {\n      redirectCount++;\n      redirect = redirect.redirectSource;\n    }\n\n    originalNetworkRequest.markAsRedirect(redirectCount);\n\n    this.finishRequest(originalNetworkRequest, time, -1);\n\n    const newNetworkRequest: NetworkRequest = this.createRequest(\n      requestId,\n      originalNetworkRequest.frameId,\n      originalNetworkRequest.loaderId,\n      redirectURL,\n      originalNetworkRequest.documentURL,\n      originalNetworkRequest.initiator\n    );\n\n    newNetworkRequest.redirectSource = originalNetworkRequest;\n\n    return newNetworkRequest;\n  }\n\n  private finishRequest(\n    networkRequest: NetworkRequest,\n    finishTime: Protocol.Network.MonotonicTime,\n    encodedDataLength: number\n  ): void {\n    networkRequest.endTime = finishTime;\n\n    if (encodedDataLength >= 0) {\n      const redirectSource: NetworkRequest | undefined =\n        networkRequest.redirectSource;\n\n      if (redirectSource?.signedExchangeInfo) {\n        networkRequest.transferSize = 0;\n        redirectSource.transferSize = encodedDataLength;\n      } else {\n        networkRequest.transferSize = encodedDataLength;\n      }\n    }\n\n    this.loadContent(networkRequest);\n\n    this.getExtraInfoBuilder(networkRequest.requestId).finished();\n\n    if (!this.shouldExcludeRequest(networkRequest)) {\n      networkRequest\n        .waitForCompletion()\n        .then(() => this.destination?.(networkRequest))\n        .finally(() => this._entries.delete(networkRequest.requestId));\n    }\n  }\n\n  private loadContent(networkRequest: NetworkRequest): void {\n    if (networkRequest.mimeType && this.options.content) {\n      networkRequest.setContentData(\n        this.network.getResponseBody(networkRequest.requestId)\n      );\n    }\n  }\n\n  private startRequest(networkRequest: NetworkRequest): void {\n    this._entries.set(networkRequest.requestId, networkRequest);\n  }\n\n  private updateNetworkRequestWithRequest(\n    chromeRequest: NetworkRequest,\n    request: Protocol.Network.Request\n  ): void {\n    chromeRequest.requestMethod = request.method;\n    chromeRequest.requestHeaders = this.headersMapToHeadersArray(\n      request.headers\n    );\n    chromeRequest.setRequestFormData(\n      request.hasPostData\n        ? this.getRequestPostData(chromeRequest, request)\n        : Promise.resolve(undefined)\n    );\n    chromeRequest.initialPriority = request.initialPriority;\n  }\n\n  private getRequestPostData(\n    request: NetworkRequest,\n    rawRequest: Protocol.Network.Request\n  ): Promise<string | undefined> {\n    return rawRequest.postData !== undefined\n      ? Promise.resolve(rawRequest.postData)\n      : this.network\n          .getRequestBody(request.requestId)\n          .then(\n            ({\n              postData\n            }: Protocol.Network.GetRequestPostDataResponse): string => postData\n          )\n          .catch(() => undefined);\n  }\n\n  private createRequest(\n    requestId: Protocol.Network.RequestId,\n    frameId: string | undefined,\n    loaderId: Protocol.Network.LoaderId,\n    url: string,\n    documentURL: string,\n    initiator?: Protocol.Network.Initiator\n  ): NetworkRequest {\n    return new NetworkRequest(\n      requestId,\n      url,\n      documentURL,\n      loaderId,\n      initiator,\n      frameId\n    );\n  }\n\n  // eslint-disable-next-line complexity\n  private updateNetworkRequestWithResponse(\n    networkRequest: NetworkRequest,\n    response: Protocol.Network.Response\n  ): void {\n    if (response.url && networkRequest.url !== response.url) {\n      networkRequest.url = response.url;\n    }\n    networkRequest.mimeType = response.mimeType;\n    networkRequest.statusCode = response.status;\n    networkRequest.statusText = response.statusText;\n\n    if (!networkRequest.hasExtraResponseInfo) {\n      networkRequest.responseHeaders = this.headersMapToHeadersArray(\n        response.headers\n      );\n    }\n\n    if (response.encodedDataLength >= 0) {\n      networkRequest.transferSize = response.encodedDataLength;\n    }\n\n    if (response.requestHeaders && !networkRequest.hasExtraRequestInfo) {\n      networkRequest.requestHeaders = this.headersMapToHeadersArray(\n        response.requestHeaders\n      );\n      networkRequest.requestHeadersText = response.requestHeadersText ?? '';\n    }\n\n    networkRequest.connectionReused = response.connectionReused;\n    networkRequest.connectionId = String(response.connectionId);\n\n    if (response.remoteIPAddress) {\n      networkRequest.setRemoteAddress(\n        response.remoteIPAddress,\n        response.remotePort || -1\n      );\n    }\n\n    if (response.timing) {\n      networkRequest.timing = response.timing;\n    }\n\n    networkRequest.protocol = response.protocol ?? '';\n  }\n\n  private headersMapToHeadersArray(\n    headersMap: Protocol.Network.Headers\n  ): Header[] {\n    return Object.keys(headersMap).reduce(\n      (acc: Header[], name: string): Header[] => {\n        const values: string[] = headersMap[name].split('\\n');\n\n        acc.push(...values.map((value: string): Header => ({ name, value })));\n\n        return acc;\n      },\n      []\n    );\n  }\n\n  private shouldExcludeRequest(request: NetworkRequest): boolean {\n    return this.requestFilter?.wouldApply(this.options)\n      ? !this.requestFilter.apply(request, this.options)\n      : false;\n  }\n\n  private handleEvent({ method, params, sessionId }: NetworkEvent): void {\n    const methodName = method.substring(method.indexOf('.') + 1);\n\n    if (typeof this[methodName] === 'function') {\n      this[methodName](params, sessionId);\n    }\n  }\n}\n","import { NetworkRequest } from '../NetworkRequest';\nimport type { RequestFilter, RequestFilterOptions } from './RequestFilter';\nimport { StringUtils } from '../../utils/StringUtils';\n\nexport class HostFilter implements RequestFilter {\n  public apply(\n    request: NetworkRequest,\n    { includeHosts }: RequestFilterOptions\n  ): boolean {\n    const { host } = request.parsedURL;\n\n    return !!includeHosts?.some(pattern =>\n      StringUtils.toRegex(pattern).test(host)\n    );\n  }\n\n  public wouldApply(options: RequestFilterOptions): boolean {\n    return (\n      Array.isArray(options.includeHosts) && options.includeHosts.length > 0\n    );\n  }\n}\n","import { NetworkRequest } from '../NetworkRequest';\nimport type { RequestFilter, RequestFilterOptions } from './RequestFilter';\nimport { StringUtils } from '../../utils/StringUtils';\n\nexport class PathFilter implements RequestFilter {\n  public apply(\n    request: NetworkRequest,\n    { excludePaths }: RequestFilterOptions\n  ): boolean {\n    const { pathname = '/' } = request.parsedURL;\n\n    return !excludePaths?.some(pattern =>\n      StringUtils.toRegex(pattern).test(pathname)\n    );\n  }\n\n  public wouldApply(options: RequestFilterOptions): boolean {\n    return (\n      Array.isArray(options.excludePaths) && options.excludePaths.length > 0\n    );\n  }\n}\n","import { NetworkRequest } from '../NetworkRequest';\nimport type { RequestFilter, RequestFilterOptions } from './RequestFilter';\n\nexport class MimeFilter implements RequestFilter {\n  public apply(\n    request: NetworkRequest,\n    { includeMimes }: RequestFilterOptions\n  ): boolean {\n    return !!(request.mimeType && includeMimes?.includes(request.mimeType));\n  }\n\n  public wouldApply(options: RequestFilterOptions): boolean {\n    return (\n      Array.isArray(options.includeMimes) && options.includeMimes.length > 0\n    );\n  }\n}\n","import { NetworkRequest } from '../NetworkRequest';\nimport type { RequestFilter, RequestFilterOptions } from './RequestFilter';\n\nexport class MinStatusCodeFilter implements RequestFilter {\n  public apply(\n    request: NetworkRequest,\n    { minStatusCodeToInclude }: RequestFilterOptions\n  ): boolean {\n    const threshold = this.normalizeThreshold(minStatusCodeToInclude) ?? 0;\n\n    return request.statusCode >= threshold;\n  }\n\n  public wouldApply(options: RequestFilterOptions): boolean {\n    const threshold = this.normalizeThreshold(options.minStatusCodeToInclude);\n\n    return typeof threshold === 'number';\n  }\n\n  private normalizeThreshold(\n    value: number | string | undefined\n  ): number | undefined {\n    return value != null && !isNaN(+value)\n      ? Math.round(Math.abs(+value))\n      : undefined;\n  }\n}\n","import { NetworkRequest } from '../NetworkRequest';\nimport type { RequestFilter, RequestFilterOptions } from './RequestFilter';\n\nexport class BlobFilter implements RequestFilter {\n  public apply(request: NetworkRequest, _: RequestFilterOptions): boolean {\n    return !request.isBlob();\n  }\n\n  public wouldApply({ includeBlobs }: RequestFilterOptions): boolean {\n    return !(includeBlobs ?? true);\n  }\n}\n","import { NetworkRequest } from '../NetworkRequest';\nimport type { RequestFilter, RequestFilterOptions } from './RequestFilter';\n\nexport class StatusCodeFilter implements RequestFilter {\n  public apply(\n    request: NetworkRequest,\n    { excludeStatusCodes }: RequestFilterOptions\n  ): boolean {\n    return !excludeStatusCodes?.includes(request.statusCode);\n  }\n\n  public wouldApply(options: RequestFilterOptions): boolean {\n    return (\n      Array.isArray(options.excludeStatusCodes) &&\n      options.excludeStatusCodes.length > 0\n    );\n  }\n}\n","import { NetworkRequest } from '../NetworkRequest';\nimport { HostFilter } from './HostFilter';\nimport { PathFilter } from './PathFilter';\nimport { MimeFilter } from './MimeFilter';\nimport { MinStatusCodeFilter } from './MinStatusCodeFilter';\nimport { BlobFilter } from './BlobFilter';\nimport { StatusCodeFilter } from './StatusCodeFilter';\nimport type { RequestFilter, RequestFilterOptions } from './RequestFilter';\n\nexport class CompositeFilter implements RequestFilter {\n  constructor(\n    private readonly children: RequestFilter[] = [\n      new HostFilter(),\n      new PathFilter(),\n      new MimeFilter(),\n      new BlobFilter(),\n      new MinStatusCodeFilter(),\n      new StatusCodeFilter()\n    ]\n  ) {}\n\n  public apply(\n    request: NetworkRequest,\n    options: RequestFilterOptions\n  ): boolean {\n    return this.children\n      .filter(x => x.wouldApply(options))\n      .every(x => x.apply(request, options));\n  }\n\n  public wouldApply(options: RequestFilterOptions): boolean {\n    return this.children.some(x => x.wouldApply(options));\n  }\n}\n","import type { Entry, Har } from 'har-format';\n\nexport class HarBuilder {\n  constructor(private readonly entries: Entry[]) {}\n\n  public build(): Har {\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    const { name, version, homepage: comment } = require('../../package.json');\n\n    return {\n      log: {\n        version: '1.2',\n        pages: [],\n        creator: {\n          name,\n          version,\n          comment\n        },\n        entries: this.entries\n      }\n    };\n  }\n}\n","import { NetworkRequest } from './NetworkRequest';\nimport type { Observer } from './Observer';\nimport { promisify } from 'util';\n\nexport class NetworkIdleMonitor {\n  private startIdleTime?: number;\n\n  constructor(private readonly networkObservable: Observer<NetworkRequest>) {}\n\n  public async waitForIdle(idleTime: number): Promise<void> {\n    for (;;) {\n      this.startIdleTime = this.networkObservable.empty\n        ? this.startIdleTimer()\n        : undefined;\n\n      if (this.shouldResolve(idleTime)) {\n        return;\n      }\n\n      await promisify(setTimeout)(idleTime);\n    }\n  }\n\n  private startIdleTimer(): number {\n    if (!this.startIdleTime) {\n      this.startIdleTime = Date.now();\n    }\n\n    return this.startIdleTime;\n  }\n\n  private shouldResolve(idleTime: number): boolean {\n    return !!(\n      this.startIdleTime && Date.now() - this.startIdleTime >= idleTime\n    );\n  }\n}\n","export const PORT_OPTION_NAME = '--remote-debugging-port';\nexport const ADDRESS_OPTION_NAME = '--remote-debugging-address';\nexport const SUPPORTED_BROWSERS: readonly string[] = ['chromium'];\nexport const MAX_NETWORK_IDLE_THRESHOLD = 100;\nexport const MAX_NETWORK_IDLE_DURATION = 5000;\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"chalk\");","import chalk from 'chalk';\nimport { debuglog } from 'util';\n\nexport class Logger {\n  private static _instance: Logger;\n  private readonly _debug = debuglog('cypress-har-generator');\n\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  static get Instance(): Logger {\n    if (!this._instance) {\n      this._instance = new Logger();\n    }\n\n    return this._instance;\n  }\n\n  public info(msg: string): void {\n    this.log(chalk.blue(` ${msg}`));\n  }\n\n  public err(msg: string | Error | unknown): void {\n    this.log(chalk.red(` ${msg}`));\n  }\n\n  public warn(msg: string): void {\n    this.log(chalk.yellow(` ${msg}`));\n  }\n\n  public debug(msg: string): void {\n    this._debug(msg);\n  }\n\n  private log(msg: string): void {\n    // eslint-disable-next-line no-console\n    console.log(msg);\n  }\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"fs\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"crypto\");","import { Logger } from './Logger';\nimport { promisify } from 'util';\nimport {\n  access,\n  constants,\n  mkdir,\n  open,\n  unlink,\n  writeFile,\n  readFile,\n  WriteStream,\n  createWriteStream\n} from 'fs';\nimport { randomBytes } from 'crypto';\nimport { tmpdir } from 'os';\nimport { join } from 'path';\n\nexport class FileManager {\n  private static _instance: FileManager;\n\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  static get Instance(): FileManager {\n    if (!this._instance) {\n      this._instance = new FileManager();\n    }\n\n    return this._instance;\n  }\n\n  public async readFile(path: string): Promise<string | undefined> {\n    try {\n      return await promisify(readFile)(path, { encoding: 'utf-8' });\n    } catch (e) {\n      Logger.Instance.err(e);\n\n      return undefined;\n    }\n  }\n\n  public async writeFile(path: string, data: string): Promise<void> {\n    try {\n      await this.removeFile(path);\n      await promisify(writeFile)(path, data);\n    } catch (e) {\n      Logger.Instance.err(e);\n    }\n  }\n\n  public async createFolder(path: string): Promise<void> {\n    try {\n      if (await this.exists(path)) {\n        return;\n      }\n\n      await promisify(mkdir)(path);\n    } catch (e) {\n      Logger.Instance.err(e);\n    }\n  }\n\n  public async removeFile(path: string): Promise<void> {\n    try {\n      if (await this.exists(path)) {\n        await promisify(unlink)(path);\n      }\n    } catch (e) {\n      Logger.Instance.err(e);\n    }\n  }\n\n  public async exists(path: string): Promise<boolean> {\n    try {\n      await promisify(access)(path, constants.F_OK);\n\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  public async createTmpWriteStream(): Promise<WriteStream> {\n    const { fd, path } = await this.openTmpFd();\n\n    const stream = createWriteStream(path, {\n      fd,\n      flags: 'w',\n      mode: 0o666,\n      encoding: 'utf-8'\n    });\n\n    stream.path = path;\n\n    return stream;\n  }\n\n  private async openTmpFd(): Promise<{ path: string; fd: number }> {\n    const name = randomBytes(16).toString('hex').substring(16);\n    const path = join(tmpdir(), name);\n    const fd = await promisify(open)(path, 'w', 0o600);\n\n    return { path, fd };\n  }\n}\n","export const FAILED_ATTEMPT_TO_CONNECT =\n  'Failed to connect to Chrome Debugging Protocol';\nexport const ATTEMPT_TO_CONNECT =\n  'Attempting to connect to Chrome Debugging Protocol';\nexport const CONNECTED = 'Connected to Chrome Debugging Protocol';\nexport const DISCONNECTED = 'Chrome Debugging Protocol disconnected';\nexport const CONNECTION_NOT_ESTABLISHED = `Chrome Debugging Protocol connection has not been established.`;\nexport const TARGET_OR_BROWSER_CLOSED =\n  'The target or browser may have closed before completion of initialization';\nexport const UNABLE_TO_ATTACH_TO_TARGET = `Unable to attach to the target (e.g. page, worker, etc). \n\nPossible reasons for the failure include:\n  - Chrome not running in headless mode.\n  - The target may have closed during initialization.\n  - The target may have crashed due to memory issues.\n\nPlease open an issue on the repository: https://github.com/NeuraLegion/cypress-har-generator/issues for assistance.\n\nThe stack trace for this error is:`;\nexport const FAILED_TO_CONNECT = `${FAILED_ATTEMPT_TO_CONNECT}\n\nPossible reasons for failure:\n  - Chrome not running in headless mode\n  - Using Chrome version 58 or earlier\n  - Inconsistent RDP configuration settings.\n  \nThe stack trace for this error is:`;\n","import type { Network, NetworkEvent } from '../network';\nimport { ErrorUtils } from '../utils/ErrorUtils';\nimport type { Logger } from '../utils/Logger';\nimport {\n  TARGET_OR_BROWSER_CLOSED,\n  UNABLE_TO_ATTACH_TO_TARGET\n} from './messages';\nimport type { NetworkOptions } from './NetworkOptions';\nimport type { Client, EventMessage } from 'chrome-remote-interface';\nimport type Protocol from 'devtools-protocol';\n\nexport class DefaultNetwork implements Network {\n  private readonly DOMAIN = 'Network';\n  private readonly ALLOWED_TARGETS = new Set([\n    'service_worker',\n    'page',\n    'worker',\n    'background_page',\n    'webview',\n    'shared_worker'\n  ]);\n\n  private listener?: (event: NetworkEvent) => unknown;\n  private readonly sessions = new Map<string, string | undefined>();\n\n  constructor(\n    private readonly cdp: Client,\n    private readonly logger: Logger,\n    private readonly options?: NetworkOptions\n  ) {}\n\n  public async attachToTargets(\n    listener: (event: NetworkEvent) => unknown\n  ): Promise<void> {\n    this.listener = listener;\n\n    this.cdp.on('event', this.networkEventListener);\n    this.cdp.on('Target.attachedToTarget', this.attachedToTargetListener);\n    this.cdp.on('Network.requestWillBeSent', this.sessionListener);\n    this.cdp.on('Network.webSocketCreated', this.sessionListener);\n    await this.ignoreCertificateError();\n    await this.recursivelyAttachToTargets({ type: 'browser' });\n  }\n\n  public async detachFromTargets(): Promise<void> {\n    if (this.listener) {\n      this.cdp.off('event', this.networkEventListener);\n      this.cdp.off('Security.certificateError', this.certificateErrorListener);\n      this.cdp.off('Target.attachedToTarget', this.attachedToTargetListener);\n      this.cdp.off('Network.requestWillBeSent', this.sessionListener);\n      this.cdp.off('Network.webSocketCreated', this.sessionListener);\n      delete this.listener;\n    }\n\n    try {\n      await Promise.all([\n        this.cdp.send('Security.disable'),\n        this.enableAutoAttach(false)\n      ]);\n    } catch (e) {\n      // ADHOC: handle any unforeseen issues while detaching from targets.\n      this.logger.debug(`Unexpected error while detaching from targets: ${e}`);\n    }\n\n    this.sessions.clear();\n  }\n\n  public getRequestBody(\n    requestId: string\n  ): Promise<Protocol.Network.GetRequestPostDataResponse> {\n    return this.cdp.send(\n      'Network.getRequestPostData',\n      {\n        requestId\n      },\n      this.sessions.get(requestId)\n    );\n  }\n\n  public getResponseBody(\n    requestId: string\n  ): Promise<Protocol.Network.GetResponseBodyResponse> {\n    return this.cdp.send(\n      'Network.getResponseBody',\n      {\n        requestId\n      },\n      this.sessions.get(requestId)\n    );\n  }\n\n  private async ignoreCertificateError(): Promise<void> {\n    this.cdp.on('Security.certificateError', this.certificateErrorListener);\n    try {\n      await this.cdp.send('Security.enable');\n      await this.cdp.send('Security.setOverrideCertificateErrors', {\n        override: true\n      });\n    } catch (e) {\n      // ADHOC: The CDP protocol may not support the Security domain.\n      this.logger.debug(\n        ErrorUtils.isError(e) ? e.message : `Something went wrong: ${e}`\n      );\n    }\n  }\n\n  private networkEventListener = (eventMessage: EventMessage) => {\n    if (this.matchNetworkEvents(eventMessage)) {\n      setImmediate(() => this.listener?.(eventMessage));\n    }\n  };\n\n  private certificateErrorListener = ({\n    eventId\n  }: Protocol.Security.CertificateErrorEvent) =>\n    this.cdp.send('Security.handleCertificateError', {\n      eventId,\n      action: 'continue'\n    });\n\n  private matchNetworkEvents(message: EventMessage): message is NetworkEvent {\n    const [domain]: string[] = message.method.split('.');\n\n    return domain === this.DOMAIN;\n  }\n\n  private async recursivelyAttachToTargets(options: {\n    sessionId?: string;\n    type: string;\n  }): Promise<void> {\n    await this.enableAutoAttach(true, options.sessionId);\n\n    if (this.ALLOWED_TARGETS.has(options.type)) {\n      await this.trackNetworkEvents(options.sessionId);\n    }\n  }\n\n  private enableAutoAttach(\n    autoAttach: boolean,\n    sessionId?: string\n  ): Promise<void> {\n    return this.cdp.send(\n      'Target.setAutoAttach',\n      {\n        autoAttach,\n        flatten: true,\n        waitForDebuggerOnStart: true\n      },\n      sessionId\n    );\n  }\n\n  private sessionListener = (\n    {\n      requestId\n    }:\n      | Protocol.Network.RequestWillBeSentEvent\n      | Protocol.Network.WebSocketCreatedEvent,\n    sessionId?: string\n  ) => {\n    this.sessions.set(requestId, sessionId);\n    this.logger.debug(\n      `Session ${sessionId ?? 'N/A'} associated with request: ${requestId}`\n    );\n  };\n\n  private attachedToTargetListener = async ({\n    sessionId,\n    targetInfo,\n    waitingForDebugger\n  }: Protocol.Target.AttachedToTargetEvent): Promise<void> => {\n    try {\n      await this.recursivelyAttachToTargets({\n        sessionId,\n        type: targetInfo.type\n      });\n\n      if (waitingForDebugger) {\n        await this.cdp.send(\n          'Runtime.runIfWaitingForDebugger',\n          undefined,\n          sessionId\n        );\n      }\n    } catch (e) {\n      const stack = ErrorUtils.isError(e) ? e.stack : e;\n\n      this.logger.debug(\n        `We encountered an issue while initializing the target for the session: ${sessionId}.`\n      );\n      this.logger.debug(\n        `The information about the target is as follows: ${JSON.stringify(\n          targetInfo\n        )}`\n      );\n      this.logger.warn(`${UNABLE_TO_ATTACH_TO_TARGET}\\n${stack}`);\n    }\n  };\n\n  private async trackNetworkEvents(sessionId?: string): Promise<void> {\n    try {\n      await Promise.all([\n        this.cdp.send('Network.enable', this.options ?? {}, sessionId),\n        this.cdp.send(\n          'Network.setCacheDisabled',\n          {\n            cacheDisabled: true\n          },\n          sessionId\n        )\n      ]);\n    } catch (e) {\n      if (this.targetClosedError(e)) {\n        this.logger.debug(TARGET_OR_BROWSER_CLOSED);\n\n        return;\n      }\n\n      throw e;\n    }\n  }\n\n  private targetClosedError(e: unknown): e is Error {\n    return (\n      ErrorUtils.isError(e) &&\n      (e.message.includes('Target closed') ||\n        e.message.includes('Session closed'))\n    );\n  }\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"chrome-remote-interface\");","import { RetryStrategy } from './RetryStrategy';\nimport { Logger } from '../utils/Logger';\nimport {\n  ATTEMPT_TO_CONNECT,\n  CONNECTED,\n  CONNECTION_NOT_ESTABLISHED,\n  DISCONNECTED,\n  FAILED_ATTEMPT_TO_CONNECT,\n  FAILED_TO_CONNECT\n} from './messages';\nimport type { Connection } from './Connection';\nimport type { Network } from '../network';\nimport { DefaultNetwork } from './DefaultNetwork';\nimport { ErrorUtils } from '../utils/ErrorUtils';\nimport type { NetworkOptions } from './NetworkOptions';\nimport CDP, { Version } from 'chrome-remote-interface';\nimport type { Client, Options } from 'chrome-remote-interface';\n\nexport class CDPConnection implements Connection {\n  private _network?: Network;\n  private _cdp?: Client;\n\n  get cdp() {\n    return this._cdp;\n  }\n\n  constructor(\n    private readonly options: Options,\n    private readonly logger: Logger,\n    private readonly retryStrategy: RetryStrategy\n  ) {}\n\n  public async open(): Promise<void> {\n    try {\n      this.logger.debug(ATTEMPT_TO_CONNECT);\n\n      const target = await this.populateBrowserTarget();\n\n      const cdp = await CDP({\n        target\n      });\n\n      this.logger.debug(CONNECTED);\n\n      cdp.once('disconnect', (): void => this.logger.debug(DISCONNECTED));\n\n      this._cdp = cdp;\n    } catch (e) {\n      const message = ErrorUtils.isError(e) ? e.message : e;\n      this.logger.debug(`${FAILED_ATTEMPT_TO_CONNECT}: ${message}`);\n\n      if (\n        !(await this.retryStrategy.execute((): Promise<void> => this.open()))\n      ) {\n        throw new Error(FAILED_TO_CONNECT);\n      }\n    }\n  }\n\n  public async close(): Promise<void> {\n    if (this._cdp) {\n      await this._cdp.close();\n      this._cdp.removeAllListeners();\n      delete this._cdp;\n      this.logger.debug(DISCONNECTED);\n    }\n  }\n\n  public discoverNetwork(options?: NetworkOptions): Network {\n    if (!this.cdp) {\n      throw new Error(CONNECTION_NOT_ESTABLISHED);\n    }\n\n    if (!this._network) {\n      this._network = new DefaultNetwork(this.cdp, this.logger, options);\n    }\n\n    return this._network;\n  }\n\n  private async populateBrowserTarget(): Promise<string> {\n    const { port, host } = this.options;\n    const { webSocketDebuggerUrl } = await Version({\n      host,\n      port\n    });\n\n    return webSocketDebuggerUrl ?? `ws://${host}:${port}/devtools/browser`;\n  }\n}\n","import Timeout = NodeJS.Timeout;\n\nexport class RetryStrategy {\n  private _times: number;\n  private backoffTime: number;\n  private readonly maximumBackoff: number;\n  private readonly maxRetries: number;\n\n  constructor(\n    maxRetries: number = 3,\n    initialBackoff: number = 5,\n    maximumBackoff: number = 25\n  ) {\n    this._times = 0;\n    this.maxRetries = maxRetries;\n    this.backoffTime = initialBackoff;\n    this.maximumBackoff = maximumBackoff;\n  }\n\n  public async execute<T extends (...args: any[]) => unknown>(\n    task: T\n  ): Promise<number> {\n    const timeout: number | undefined = this.nextTime();\n\n    if (timeout) {\n      await this.delay(timeout);\n\n      await task();\n    }\n\n    return this.maxRetries - this._times;\n  }\n\n  private delay(timeout: number): Promise<void> {\n    return new Promise<void>(\n      (resolve): Timeout => setTimeout(resolve, timeout)\n    );\n  }\n\n  private nextTime(): number | undefined {\n    if (this._times < this.maxRetries) {\n      return this.increaseBackoffTime();\n    }\n\n    return undefined;\n  }\n\n  private increaseBackoffTime(): number {\n    this.backoffTime *= Math.pow(2, ++this._times - 1);\n\n    return Math.min(this.backoffTime, this.maximumBackoff);\n  }\n}\n","import { Plugin } from './Plugin';\nimport { Logger } from './utils/Logger';\nimport { FileManager } from './utils/FileManager';\nimport { DefaultConnectionFactory } from './cdp';\nimport { DefaultHarExporterFactory, DefaultObserverFactory } from './network';\nimport { StringUtils } from './utils/StringUtils';\nimport type { RecordOptions, SaveOptions } from './Plugin';\n\ndeclare global {\n  // eslint-disable-next-line @typescript-eslint/no-namespace\n  namespace Cypress {\n    interface Chainable<Subject> {\n      saveHar(options?: Partial<SaveOptions>): Chainable<Subject>;\n      recordHar(options?: Partial<RecordOptions>): Chainable<Subject>;\n      disposeOfHar(): Chainable<Subject>;\n    }\n  }\n}\n\nconst plugin = new Plugin(\n  Logger.Instance,\n  FileManager.Instance,\n  new DefaultConnectionFactory(Logger.Instance),\n  new DefaultObserverFactory(Logger.Instance),\n  new DefaultHarExporterFactory(FileManager.Instance, Logger.Instance)\n);\n\nexport const install = (on: Cypress.PluginEvents): void => {\n  // ADHOC: Cypress expect the return value to be null to signal that the given event has been handled properly.\n  // https://docs.cypress.io/api/commands/task#Usage\n  on('task', {\n    saveHar: async (options: SaveOptions): Promise<null> => {\n      await plugin.saveHar(options);\n\n      return null;\n    },\n    recordHar: async (options: RecordOptions): Promise<null> => {\n      await plugin.recordHar(options);\n\n      return null;\n    },\n    disposeOfHar: async (): Promise<null> => {\n      await plugin.disposeOfHar();\n\n      return null;\n    }\n  });\n\n  on(\n    'before:browser:launch',\n    (\n      browser: Cypress.Browser | null,\n      launchOptions: Cypress.BrowserLaunchOptions\n    ) => {\n      ensureBrowserFlags((browser ?? {}) as Cypress.Browser, launchOptions);\n\n      return launchOptions;\n    }\n  );\n};\n\nexport const enableExperimentalLifecycle = (\n  on: Cypress.PluginEvents,\n  config: Cypress.PluginConfigOptions\n) => {\n  // FIXME: `isInteractive` is always true. For details see https://github.com/cypress-io/cypress/issues/20789\n  if (!config.isTextTerminal && !config.experimentalInteractiveRunEvents) {\n    Logger.Instance.warn(\n      'To activate the experimental mechanism for setting up lifecycle, you must either disable the interactive mode or activate the \"experimentalInteractiveRunEvents\" feature. For further information, please refer to: https://docs.cypress.io/guides/references/experiments#Configuration'\n    );\n  } else {\n    on('before:spec', (_: Cypress.Spec) =>\n      plugin.recordHar({\n        content: true,\n        includeBlobs: true,\n        rootDir: StringUtils.dirname(Cypress.spec.absolute)\n      })\n    );\n    on('after:spec', (spec: Cypress.Spec, _: CypressCommandLine.RunResult) =>\n      plugin.saveHar({\n        fileName: StringUtils.normalizeName(spec.name, { ext: '.har' }),\n        outDir: config.env.hars_folders ?? '.'\n      })\n    );\n  }\n};\n\n/**\n * Function has been deprecated. Use {@link install} instead as follows:\n * ```diff\n * setupNodeEvents(on) {\n *   install(on);\n * -  // bind to the event we care about\n * -  on('before:browser:launch', (browser = {}, launchOptions) => {\n * -    ensureBrowserFlags(browser, launchOptions);\n * -    return launchOptions;\n * -  });\n * }\n * ```\n * In case of any issues please refer to {@link https://github.com/cypress-io/cypress/issues/5240}\n */\nexport const ensureBrowserFlags = (\n  browser: Cypress.Browser,\n  launchOptions: Cypress.BrowserLaunchOptions\n): void => {\n  launchOptions.args.push(\n    ...plugin.ensureBrowserFlags(browser, launchOptions.args)\n  );\n};\n\nexport type { SaveOptions, RecordOptions } from './Plugin';\n","import { Logger } from './utils/Logger';\nimport { FileManager } from './utils/FileManager';\nimport type {\n  HarExporter,\n  HarExporterFactory,\n  HarExporterOptions,\n  NetworkObserverOptions,\n  Observer,\n  ObserverFactory\n} from './network';\nimport { HarBuilder, NetworkIdleMonitor, NetworkRequest } from './network';\nimport { ErrorUtils } from './utils/ErrorUtils';\nimport type { Connection, ConnectionFactory, NetworkOptions } from './cdp';\nimport {\n  ADDRESS_OPTION_NAME,\n  MAX_NETWORK_IDLE_THRESHOLD,\n  MAX_NETWORK_IDLE_DURATION,\n  PORT_OPTION_NAME,\n  SUPPORTED_BROWSERS\n} from './constants';\nimport { join } from 'path';\nimport { EOL } from 'os';\nimport { promisify } from 'util';\n\nexport interface SaveOptions {\n  fileName: string;\n  outDir: string;\n  waitForIdle?: boolean;\n  minIdleDuration?: number;\n  maxWaitDuration?: number;\n}\n\nexport type RecordOptions = NetworkObserverOptions &\n  HarExporterOptions &\n  NetworkOptions;\n\ninterface Addr {\n  port: number;\n  host: string;\n}\n\nexport class Plugin {\n  private exporter?: HarExporter;\n  private networkObservable?: Observer<NetworkRequest>;\n  private addr?: Addr;\n  private _connection?: Connection;\n\n  constructor(\n    private readonly logger: Logger,\n    private readonly fileManager: FileManager,\n    private readonly connectionFactory: ConnectionFactory,\n    private readonly observerFactory: ObserverFactory,\n    private readonly exporterFactory: HarExporterFactory\n  ) {}\n\n  public ensureBrowserFlags(\n    browser: Cypress.Browser,\n    args: string[]\n  ): string[] {\n    if (!this.isSupportedBrowser(browser)) {\n      throw new Error(\n        `An unsupported browser family was used: ${browser.name}`\n      );\n    }\n\n    const electronUsed = browser.name === 'electron';\n\n    if (electronUsed) {\n      args = this.parseElectronSwitches(browser);\n    }\n\n    const browserFlags: string[] = this.ensureRdpAddrArgs(args);\n\n    return electronUsed\n      ? []\n      : browserFlags.filter((x: string): boolean => !args.includes(x));\n  }\n\n  public async recordHar(options: RecordOptions): Promise<void> {\n    await this.closeConnection();\n\n    if (!this.addr) {\n      throw new Error(\n        `Please call the 'ensureBrowserFlags' before attempting to start the recording.`\n      );\n    }\n\n    this.exporter = await this.exporterFactory.create(options);\n    this._connection = this.connectionFactory.create({\n      ...this.addr,\n      maxRetries: 20,\n      maximumBackoff: 100,\n      initialBackoff: 5\n    });\n\n    await this._connection.open();\n\n    await this.listenNetworkEvents(options);\n  }\n\n  public async saveHar(options: SaveOptions): Promise<void> {\n    const filePath = join(options.outDir, options.fileName);\n\n    if (!this._connection) {\n      this.logger.err(`Failed to save HAR. First you should start recording.`);\n\n      return;\n    }\n\n    try {\n      await this.fileManager.createFolder(options.outDir);\n\n      if (options.waitForIdle) {\n        await this.waitForNetworkIdle(options);\n      }\n\n      const har: string | undefined = await this.buildHar();\n\n      if (har) {\n        await this.fileManager.writeFile(filePath, har);\n      }\n    } catch (e) {\n      const message = ErrorUtils.isError(e) ? e.message : e;\n      this.logger.err(\n        `An error occurred while attempting to save the HAR file. Error details: ${message}`\n      );\n    } finally {\n      await this.disposeOfHar();\n    }\n  }\n\n  public async disposeOfHar(): Promise<void> {\n    await this.networkObservable?.unsubscribe();\n    delete this.networkObservable;\n\n    if (this.exporter) {\n      this.exporter.end();\n      await this.fileManager.removeFile(this.exporter.path);\n      delete this.exporter;\n    }\n  }\n\n  private parseElectronSwitches(browser: Cypress.Browser): string[] {\n    if (!process.env.ELECTRON_EXTRA_LAUNCH_ARGS?.includes(PORT_OPTION_NAME)) {\n      this.logger\n        .err(`The '${browser.name}' browser was detected, however, the required '${PORT_OPTION_NAME}' command line switch was not provided. \nThis switch is necessary to enable remote debugging over HTTP on the specified port. \n\nPlease refer to the documentation:\n  - https://www.electronjs.org/docs/latest/api/command-line-switches#--remote-debugging-portport\n  - https://docs.cypress.io/api/plugins/browser-launch-api#Modify-Electron-app-switches`);\n      throw new Error(\n        `Missing '${PORT_OPTION_NAME}' command line switch for Electron browser`\n      );\n    }\n\n    return process.env.ELECTRON_EXTRA_LAUNCH_ARGS.split(' ');\n  }\n\n  private async buildHar(): Promise<string | undefined> {\n    if (this.exporter) {\n      const content = await this.fileManager.readFile(this.exporter.path);\n\n      if (content) {\n        const entries = content\n          .split(EOL)\n          .filter(Boolean)\n          .map(x => JSON.parse(x));\n\n        const har = new HarBuilder(entries).build();\n\n        return JSON.stringify(har, null, 2);\n      }\n    }\n\n    return undefined;\n  }\n\n  private async waitForNetworkIdle(\n    options: Pick<SaveOptions, 'minIdleDuration' | 'maxWaitDuration'>\n  ): Promise<void> {\n    const {\n      minIdleDuration = MAX_NETWORK_IDLE_THRESHOLD,\n      maxWaitDuration = MAX_NETWORK_IDLE_DURATION\n    } = options;\n    const cancellation = promisify(setTimeout)(maxWaitDuration);\n\n    return Promise.race([\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      new NetworkIdleMonitor(this.networkObservable!).waitForIdle(\n        minIdleDuration\n      ),\n      cancellation\n    ]);\n  }\n\n  private async listenNetworkEvents(options: RecordOptions): Promise<void> {\n    const network = this._connection?.discoverNetwork(options);\n\n    this.networkObservable = this.observerFactory.createNetworkObserver(\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      network!,\n      options\n    );\n\n    return this.networkObservable.subscribe((request: NetworkRequest) =>\n      this.exporter?.write(request)\n    );\n  }\n\n  private async closeConnection(): Promise<void> {\n    if (this._connection) {\n      await this._connection.close();\n      delete this._connection;\n    }\n  }\n\n  private isSupportedBrowser(browser: Cypress.Browser): boolean {\n    return SUPPORTED_BROWSERS.includes(browser?.family);\n  }\n\n  private ensureRdpAddrArgs(args: string[]): string[] {\n    const {\n      host = 'localhost',\n      port = 40000 + Math.round(Math.random() * 25000)\n    } = this.extractAddrFromArgs(args);\n\n    this.addr = { host, port };\n\n    return [\n      ...args,\n      `${PORT_OPTION_NAME}=${port}`,\n      `${ADDRESS_OPTION_NAME}=${host}`\n    ];\n  }\n\n  private extractAddrFromArgs(args: string[]): Partial<Addr> {\n    const port: string | undefined = this.findAndParseIfPossible(\n      args,\n      PORT_OPTION_NAME\n    );\n    const host: string | undefined = this.findAndParseIfPossible(\n      args,\n      ADDRESS_OPTION_NAME\n    );\n\n    let addr: { port?: number; host?: string } = {};\n\n    if (port && !isNaN(+port)) {\n      addr = { port: +port };\n    }\n\n    if (host) {\n      addr = { ...addr, host };\n    }\n\n    return addr;\n  }\n\n  private findAndParseIfPossible(\n    args: string[],\n    optionName: string\n  ): string | undefined {\n    const arg: string | undefined = args.find((x: string): boolean =>\n      x.startsWith(optionName)\n    );\n    const [, value]: string[] = arg?.split('=', 2) ?? [];\n\n    return value;\n  }\n}\n","import type { ConnectionFactory, ConnectionOptions } from './ConnectionFactory';\nimport { RetryStrategy } from './RetryStrategy';\nimport type { Connection } from './Connection';\nimport { CDPConnection } from './CDPConnection';\nimport { Logger } from '../utils/Logger';\n\nexport class DefaultConnectionFactory implements ConnectionFactory {\n  constructor(private readonly logger: Logger) {}\n\n  public create({\n    maxRetries,\n    initialBackoff,\n    maximumBackoff,\n    ...options\n  }: ConnectionOptions): Connection {\n    const retryStrategy = new RetryStrategy(\n      maxRetries,\n      initialBackoff,\n      maximumBackoff\n    );\n\n    return new CDPConnection(options, this.logger, retryStrategy);\n  }\n}\n","import { NetworkObserver } from './NetworkObserver';\nimport { Logger } from '../utils/Logger';\nimport { NetworkRequest } from './NetworkRequest';\nimport { CompositeFilter } from './filters';\nimport type { ObserverFactory } from './ObserverFactory';\nimport type { NetworkObserverOptions } from './NetworkObserverOptions';\nimport type { Observer } from './Observer';\nimport type { Network } from './Network';\n\nexport class DefaultObserverFactory implements ObserverFactory {\n  private readonly defaultRequestFilter = new CompositeFilter();\n\n  constructor(private readonly logger: Logger) {}\n\n  public createNetworkObserver(\n    network: Network,\n    options: NetworkObserverOptions\n  ): Observer<NetworkRequest> {\n    return new NetworkObserver(\n      options,\n      network,\n      this.logger,\n      this.defaultRequestFilter\n    );\n  }\n}\n","import type {\n  HarExporterFactory,\n  HarExporterOptions\n} from './HarExporterFactory';\nimport type { HarExporter } from './HarExporter';\nimport { DefaultHarExporter } from './DefaultHarExporter';\nimport { Loader } from '../utils/Loader';\nimport type { FileManager } from '../utils/FileManager';\nimport type { Logger } from '../utils/Logger';\nimport type {\n  DefaultHarExporterOptions,\n  Filter,\n  Transformer\n} from './DefaultHarExporterOptions';\nimport { resolve } from 'path';\n\nexport class DefaultHarExporterFactory implements HarExporterFactory {\n  constructor(\n    private readonly fileManager: FileManager,\n    private readonly logger: Logger\n  ) {}\n\n  public async create(options: HarExporterOptions): Promise<HarExporter> {\n    const settings = await this.createSettings(options);\n    const stream = await this.fileManager.createTmpWriteStream();\n\n    return new DefaultHarExporter(this.logger, stream, settings);\n  }\n\n  private async createSettings({\n    filter,\n    transform,\n    rootDir\n  }: HarExporterOptions) {\n    const [preProcessor, postProcessor]: (Filter | Transformer | undefined)[] =\n      await Promise.all(\n        [filter, transform].map(path => this.loadCustomProcessor(path, rootDir))\n      );\n\n    return {\n      filter: preProcessor,\n      transform: postProcessor\n    } as DefaultHarExporterOptions;\n  }\n\n  private async loadCustomProcessor<T extends Filter | Transformer>(\n    path: string | undefined,\n    rootDir: string\n  ): Promise<T | undefined> {\n    let processor: T | undefined;\n\n    if (path) {\n      const absolutePath = resolve(rootDir, path);\n      processor = await Loader.load(absolutePath);\n    }\n\n    return processor;\n  }\n}\n","import { ErrorUtils } from './ErrorUtils';\n\nexport class Loader {\n  public static async load<T>(path: string): Promise<T | undefined> {\n    let module: unknown;\n\n    try {\n      module = require(/* webpackIgnore: true */ path);\n    } catch (err) {\n      if (!this.shouldUseDynamicImport(err)) {\n        throw err;\n      }\n\n      module = (await import(/* webpackIgnore: true */ path)).default;\n    }\n\n    return this.interopRequireDefault<T | undefined>(module);\n  }\n\n  private static shouldUseDynamicImport(err: unknown): boolean {\n    const stack = ErrorUtils.isError(err) ? err.stack : undefined;\n\n    return !!(\n      stack?.includes('[ERR_REQUIRE_ESM]') ||\n      stack?.includes(\n        'SyntaxError: Cannot use import statement outside a module'\n      )\n    );\n  }\n\n  private static interopRequireDefault<T>(m: unknown): T | undefined {\n    // @ts-expect-error unknown is not assignable to the module type\n    return m && m.__esModule && m.default ? m.default : m;\n  }\n}\n"],"names":["__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","n","getter","__esModule","d","a","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","require","EntryBuilder","constructor","request","build","serverIPAddress","this","remoteAddress","portPositionInString","lastIndexOf","substr","timings","buildTimings","time","values","reduce","acc","t","Math","max","entry","startedDateTime","Date","getWallTime","issueTime","toJSON","buildRequest","response","buildResponse","cache","replace","_priority","priority","_resourceType","resourceType","_webSocketMessages","frames","_eventSourceMessages","eventSourceMessages","connectionId","connection","getResponseBodySize","statusCode","responseHeadersText","transferSize","length","getResponseCompression","resourceSize","toMilliseconds","res","method","requestMethod","url","buildRequestURL","httpVersion","requestHttpVersion","headers","requestHeaders","queryString","queryParameters","cookies","buildCookies","requestCookies","headersSize","requestHeadersText","bodySize","requestBodySize","postData","buildPostData","status","statusText","responseHttpVersion","responseHeaders","responseCookies","content","buildContent","redirectURL","responseHeaderValue","_transferSize","data","contentData","assign","size","mimeType","compression","timing","startTime","result","blocked","dns","ssl","connect","send","wait","receive","queuedTime","highestTime","blockedStart","leastNonNegative","dnsStart","connectStart","sendStart","Infinity","dnsEnd","sslStart","sslEnd","connectEnd","sendEnd","responseReceivedTime","endTime","requestTime","waitStart","waitEnd","receiveStart","receiveEnd","find","item","requestFormData","requestContentType","text","formParameters","params","split","map","buildCookie","bind","cookie","name","path","domain","expires","expiresDate","httpOnly","secure","contentLength","ErrorUtils","static","val","Error","DefaultHarExporter","logger","buffer","options","Buffer","isBuffer","toString","filter","transform","write","networkRequest","applyFilter","json","serializeEntry","closed","promisify","EOL","JSON","stringify","e","stack","isError","debug","format","err","end","message","CookieAttribute","WebSocketFrameType","NetworkCookie","_attributes","Map","_size","_name","_value","has","HTTPONLY","SECURE","sameSite","SAMESITE","session","EXPIRES","MAXAGE","PATH","port","PORT","DOMAIN","maxAge","isNaN","requestDate","targetDate","getTime","addAttribute","set","toLowerCase","CookieParser","_lastCookiePosition","parseCookie","cookieHeader","_initialize","kv","_extractKeyValue","charAt","_lastCookie","slice","addCookie","advanceAndCheckCookieDelimiter","flushCookie","_cookies","parseSetCookie","setCookieHeader","headerValue","_input","_originalInputLength","keyValueMatch","exec","toCamelCase","trim","position","str","m","toUpperCase","match","keyValue","push","StringUtils","pattern","isString","source","RegExp","normalizedPath","removeTrailingSlash","fileNameIdx","dirname","substring","removeLeadingSlash","extIdx","ext","nameWithoutExt","chars","foundChar","i","indexOf","j","NetworkRequest","_requestId","documentURL","loaderId","initiator","frameId","_wallIssueTime","_requestHeaderValues","_responseHeaderValues","_requestFormData","Promise","resolve","_hasExtraResponseInfo","_hasExtraRequestInfo","_connectionId","_protocol","_requestTime","_requestMethod","_statusText","_remoteAddress","_startTime","_issueTime","_endTime","_responseReceivedTime","_resourceSize","_requestHeaders","_requestHeadersText","_connectionReused","_responseHeaders","_responseHeadersText","_frames","_statusCode","signedExchangeInfo","_signedExchangeInfo","info","hasExtraResponseInfo","hasExtraRequestInfo","protocol","parsedURL","_parsedURL","_url","URL","_queryString","_parsedQueryParameters","x","_timing","timingInfo","headersReceivedTime","receiveHeadersEnd","_mimeType","redirectSource","_redirectSource","originatingRequest","clear","_requestCookies","requestHeaderValue","parseInt","connectionReused","_responseCookies","questionMarkPosition","hashSignPosition","initialPriority","_initialPriority","requestId","getFilteredProtocolName","parseParameters","_currentPriority","waitForCompletion","all","_contentData","_formParametersPromise","isBlob","startsWith","setRemoteAddress","ip","setIssueTime","monotonicTime","wallTime","increaseTransferSize","setRequestFormData","parseFormParameters","setContentData","then","body","base64Encoded","encoding","catch","error","addProtocolFrameError","errorMessage","addFrame","type","ERROR","opcode","mask","addProtocolFrame","sent","REQUEST","RESPONSE","payloadData","addEventSourceMessage","eventName","eventId","markAsRedirect","redirectCount","addExtraRequestInfo","extraRequestInfo","addExtraResponseInfo","extraResponseInfo","pathname","search","headerName","computeHeaderValue","formUrlencoded","multipartDetails","boundary","formData","parseMultipartFormDataParameters","sanitizedBoundary","escapeCharacters","keyValuePattern","field","fileName","contentType","frame","pair","join","ExtraInfoBuilder","deleteCallback","_hasExtraInfo","_finished","_requests","_requestExtraInfo","_responseExtraInfo","addRequest","sync","addRequestExtraInfo","addResponseExtraInfo","finished","deleteIfComplete","lastRequest","getLastRequest","getRequestIndex","req","index","requestExtraInfo","responseExtraInfo","NetworkObserver","network","requestFilter","_entries","_extraInfoBuilders","empty","subscribe","callback","destination","attachToTargets","event","handleEvent","unsubscribe","detachFromTargets","signedExchangeReceived","updateNetworkRequestWithResponse","outerResponse","requestWillBeSent","redirectResponse","timestamp","responseReceived","_appendRedirect","createRequest","updateNetworkRequestWithRequest","getExtraInfoBuilder","startRequest","dataReceived","dataLength","encodedDataLength","resourceChangedPriority","newPriority","loadingFinished","finishRequest","loadingFailed","errorText","canceled","webSocketCreated","eventSourceMessageReceived","webSocketWillSendHandshakeRequest","headersMapToHeadersArray","webSocketHandshakeResponseReceived","headersText","webSocketFrameSent","webSocketFrameReceived","webSocketFrameError","webSocketClosed","requestWillBeSentExtraInfo","responseReceivedExtraInfo","delete","originalNetworkRequest","redirect","newNetworkRequest","finishTime","loadContent","shouldExcludeRequest","finally","getResponseBody","chromeRequest","hasPostData","getRequestPostData","rawRequest","getRequestBody","String","remoteIPAddress","remotePort","headersMap","keys","wouldApply","apply","sessionId","methodName","HostFilter","includeHosts","host","some","toRegex","test","Array","isArray","PathFilter","excludePaths","MimeFilter","includeMimes","includes","MinStatusCodeFilter","minStatusCodeToInclude","threshold","normalizeThreshold","round","abs","BlobFilter","_","includeBlobs","StatusCodeFilter","excludeStatusCodes","CompositeFilter","children","every","HarBuilder","entries","version","homepage","comment","log","pages","creator","NetworkIdleMonitor","networkObservable","waitForIdle","idleTime","startIdleTime","startIdleTimer","shouldResolve","setTimeout","now","PORT_OPTION_NAME","ADDRESS_OPTION_NAME","SUPPORTED_BROWSERS","MAX_NETWORK_IDLE_THRESHOLD","MAX_NETWORK_IDLE_DURATION","Logger","_debug","debuglog","Instance","_instance","msg","warn","console","FileManager","readFile","writeFile","removeFile","createFolder","exists","mkdir","unlink","access","constants","createTmpWriteStream","fd","openTmpFd","stream","createWriteStream","flags","mode","randomBytes","tmpdir","open","FAILED_ATTEMPT_TO_CONNECT","DISCONNECTED","FAILED_TO_CONNECT","DefaultNetwork","cdp","ALLOWED_TARGETS","Set","sessions","networkEventListener","eventMessage","matchNetworkEvents","setImmediate","listener","certificateErrorListener","action","sessionListener","attachedToTargetListener","targetInfo","waitingForDebugger","recursivelyAttachToTargets","on","ignoreCertificateError","off","enableAutoAttach","override","trackNetworkEvents","autoAttach","flatten","waitForDebuggerOnStart","cacheDisabled","targetClosedError","CDPConnection","retryStrategy","_cdp","target","populateBrowserTarget","once","execute","close","removeAllListeners","discoverNetwork","_network","webSocketDebuggerUrl","Version","RetryStrategy","maxRetries","initialBackoff","maximumBackoff","_times","backoffTime","task","timeout","nextTime","delay","increaseBackoffTime","pow","min","fileManager","connectionFactory","observerFactory","exporterFactory","ensureBrowserFlags","browser","args","isSupportedBrowser","electronUsed","parseElectronSwitches","browserFlags","ensureRdpAddrArgs","recordHar","closeConnection","addr","exporter","create","_connection","listenNetworkEvents","saveHar","filePath","outDir","waitForNetworkIdle","har","buildHar","disposeOfHar","process","env","ELECTRON_EXTRA_LAUNCH_ARGS","Boolean","parse","minIdleDuration","maxWaitDuration","cancellation","race","createNetworkObserver","family","random","extractAddrFromArgs","findAndParseIfPossible","optionName","arg","defaultRequestFilter","settings","createSettings","rootDir","preProcessor","postProcessor","loadCustomProcessor","processor","absolutePath","shouldUseDynamicImport","import","default","interopRequireDefault","load","install","launchOptions","enableExperimentalLifecycle","config","isTextTerminal","experimentalInteractiveRunEvents","Cypress","spec","absolute","normalizeName","hars_folders"],"sourceRoot":""}